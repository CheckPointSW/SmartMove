/********************************************************************
Copyright (c) 2017, Check Point Software Technologies Ltd.
All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
********************************************************************/

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Text;
using System.Globalization;
using CheckPointObjects;
using CommonUtils;
using MigrationBase;

namespace JuniperMigration
{
    /// <summary>
    /// Converts Juniper SRX objects repository into Check Point objects repository.
    /// Generates conversion reports for objects and policy packages.
    /// </summary>
    public class JuniperConverter : VendorConverter
    {
        #region Helper Classes

        private class DuplicateNameInfo
        {
            public bool IsJuniperApplicationFromTerm { get; set; }
            public bool IsCPPredefinedName { get; private set; }
            public List<string> Zones { get; private set; }

            public DuplicateNameInfo(bool isCPPredefinedName)
            {
                IsJuniperApplicationFromTerm = false;
                IsCPPredefinedName = isCPPredefinedName;
                Zones = new List<string>();
            }
        }

        private static class NetworkObjectNameGenerator
        {
            private static int _networkGroupNamecounter;

            public static string AutoGeneratedNetworkName(Subnet subnet)
            {
                return subnet.IsHost()
                           ? "host_" + subnet.IpAddress
                           : "network_" + subnet.IpAddress + "_" + NetworkUtils.GetMaskLength(subnet.Netmask);
            }

            public static string AutoGeneratedNetworkGroupName()
            {
                return string.Format("network_group_{0}", ++_networkGroupNamecounter);
            }
        }

        private static class CheckPointServiceObjectsFactory
        {
            public static CheckPointObject CreateServiceObj(CheckPointObjectsRepository cpObjects, string sProtocol, string sPort, out bool alreadyExists)
            {
                alreadyExists = false;

                string serviceName;

                switch (sProtocol)
                {
                    case "tcp":
                        serviceName = "TCP_" + sPort;
                        break;

                    case "udp":
                        serviceName = "UDP_" + sPort;
                        break;

                    case "sctp":
                        serviceName = "SCTP_" + sPort;   // dummy, just for the flow...
                        break;

                    case "other":
                        serviceName = "OTHER_" + sPort;
                        break;

                    default:
                        Console.WriteLine("Error: Unknown service protocol '{0}'", sProtocol);
                        return null;
                }

                bool serviceFound = false;
                serviceName = cpObjects.GetKnownServiceName(serviceName, out serviceFound);

                if (serviceFound || cpObjects.HasObject(serviceName))
                {
                    alreadyExists = true;
                    return cpObjects.GetObject(serviceName);
                }

                CheckPointObject serviceObj;

                switch (sProtocol)
                {
                    case "tcp":
                        serviceObj = new CheckPoint_TcpService();
                        ((CheckPoint_TcpService)serviceObj).Port = sPort;
                        break;
                    case "udp":
                        serviceObj = new CheckPoint_UdpService();
                        ((CheckPoint_UdpService)serviceObj).Port = sPort;
                        break;
                    case "sctp":
                        serviceObj = new CheckPoint_SctpService();
                        ((CheckPoint_SctpService)serviceObj).Port = sPort;
                        break;
                    default:   // "other"
                        serviceObj = new CheckPoint_OtherService();
                        ((CheckPoint_OtherService)serviceObj).IpProtocol = sPort;
                        break;
                }

                serviceObj.Name = serviceName;
                return serviceObj;
            }
        }

        private class JuniperNatCustomData
        {
            // Traffic matching priority according to rule-set's from/to values.
            public enum RulePriority
            {
                StaticInterface = 1,
                StaticZone,
                DestinationInterface,
                DestinationZone,
                SourceInterface2Interface,
                SourceMixed,
                SourceZone2Zone
            };

            public RulePriority Priority { get; set; }
            public bool IsStaticMirrorRule { get; set; }
            public List<string> SourceZonesOrInterfaces = new List<string>();
        }
        
        #endregion

        #region Private Members

        private JuniperParser _juniperParser;

        private Dictionary<string, DuplicateNameInfo> _duplicateNamesLookup = new Dictionary<string, DuplicateNameInfo>(StringComparer.InvariantCultureIgnoreCase);
        private Dictionary<string, string> _juniper2CheckpointServiceDuplicates = new Dictionary<string, string>();
        private Dictionary<string, string> _juniperInvalidApplicationsReferences = new Dictionary<string, string>();
        private Dictionary<string, List<IPNetwork>> _juniperInterfacesTopology = new Dictionary<string, List<IPNetwork>>();
        private List<string> _cpUnsafeNames = new List<string>();
        private List<string> _cpServiceInvalidNames = new List<string>();
        private List<string> _policyZonesLookup = new List<string>();
        private List<CheckPointObject> _cpNetworkObjectsInMultipleZones = new List<CheckPointObject>();
        private List<CheckPoint_NAT_Rule> _cpPreorderedNatRules = new List<CheckPoint_NAT_Rule>();
        private Dictionary<int, List<CheckPoint_Rule>> _natMatchedFirewallRules = new Dictionary<int, List<CheckPoint_Rule>>();

        private IEnumerable<JuniperObject> _juniperZones;
        public IEnumerable<JuniperObject> JuniperZones
        {
            get { return _juniperZones ?? (_juniperZones = _juniperParser.Filter("_Zone")); }
        }

        private IEnumerable<JuniperObject> _juniperInterfaces;
        private IEnumerable<JuniperObject> JuniperInterfaces
        {
            get { return _juniperInterfaces ?? (_juniperInterfaces = _juniperParser.Filter("_Interface")); }
        }

        private IEnumerable<JuniperObject> _juniperZonePolicies;
        private IEnumerable<JuniperObject> JuniperZonePolicies
        {
            get { return _juniperZonePolicies ?? (_juniperZonePolicies = _juniperParser.Filter("_ZonePolicy")); }
        }
        
        #endregion

        #region Private Methods

        protected override bool AddCheckPointObject(CheckPointObject cpObject)
        {
            if (base.AddCheckPointObject(cpObject))
            {
                string vendor = Vendor.JuniperJunosOS.ToString();
                if (!cpObject.Tags.Contains(vendor))
                {
                    cpObject.Tags.Add(vendor);
                }
            }

            return false;
        }

        private void Add_NetworkObjects()
        {
            bool inMultipleZones = false;
            var networkAndZoneNamesDuplicates = new List<CheckPointObject>();

            foreach (Juniper_Fqdn fqdn in _juniperParser.Filter("_Fqdn"))
            {
                if (string.IsNullOrEmpty(fqdn.DnsName))
                {
                    _conversionIncidents.Add(new ConversionIncident(fqdn.LineNumber,
                                                                    fqdn.ConversionIncidentMessage,
                                                                    "Fqdn details :" + fqdn.Name + ".",
                                                                    fqdn.ConversionIncidentType));
                    continue;
                }

                var cpDomain = new CheckPoint_Domain();
                cpDomain.Name = fqdn.Name;
                cpDomain.Comments = fqdn.Description;
                cpDomain.Fqdn = fqdn.DnsName;
                cpDomain.Tag = fqdn.ZoneName;
                ApplyConversionIncidentOnCheckPointObject(cpDomain, fqdn);
                inMultipleZones = IsNetworkObjectContainedInMultipleZones(cpDomain, fqdn);
                AlertOnDomainNameModification(fqdn, inMultipleZones);
                if (!inMultipleZones)
                {
                    AddCheckPointObject(cpDomain);
                }
            }

            foreach (Juniper_Host host in _juniperParser.Filter("_Host"))
            {
                var cpHost = new CheckPoint_Host();
                cpHost.Name = host.Name;
                cpHost.Comments = host.Description;
                cpHost.IpAddress = host.IpAddress;
                cpHost.Tag = host.ZoneName;
                ApplyConversionIncidentOnCheckPointObject(cpHost, host);
                inMultipleZones = IsNetworkObjectContainedInMultipleZones(cpHost, host);
                CheckObjectNameValidity(cpHost, host, inMultipleZones);
                if (!inMultipleZones)
                {
                    if (AreNetworkAndZoneNamesDuplicated(cpHost.Name))
                    {
                        networkAndZoneNamesDuplicates.Add(cpHost);
                    }
                    else
                    {
                        AddCheckPointObject(cpHost);
                    }
                }
            }

            foreach (Juniper_Network network in _juniperParser.Filter("_Network"))
            {
                var cpNetwork = new CheckPoint_Network();
                cpNetwork.Name = network.Name;
                cpNetwork.Comments = network.Description;
                cpNetwork.Subnet = network.IpAddress;
                cpNetwork.Netmask = network.Netmask;
                cpNetwork.Tag = network.ZoneName;
                ApplyConversionIncidentOnCheckPointObject(cpNetwork, network);
                inMultipleZones = IsNetworkObjectContainedInMultipleZones(cpNetwork, network);
                CheckObjectNameValidity(cpNetwork, network, inMultipleZones);
                if (!inMultipleZones)
                {
                    if (AreNetworkAndZoneNamesDuplicated(cpNetwork.Name))
                    {
                        networkAndZoneNamesDuplicates.Add(cpNetwork);
                    }
                    else
                    {
                        AddCheckPointObject(cpNetwork);
                    }
                }
            }

            foreach (Juniper_Range range in _juniperParser.Filter("_Range"))
            {
                var cpRange = new CheckPoint_Range();
                cpRange.Name = range.Name;
                cpRange.Comments = range.Description;
                cpRange.RangeFrom = range.RangeFrom;
                cpRange.RangeTo = range.RangeTo;
                cpRange.Tag = range.ZoneName;
                ApplyConversionIncidentOnCheckPointObject(cpRange, range);
                inMultipleZones = IsNetworkObjectContainedInMultipleZones(cpRange, range);
                CheckObjectNameValidity(cpRange, range, inMultipleZones);
                if (!inMultipleZones)
                {
                    if (AreNetworkAndZoneNamesDuplicated(cpRange.Name))
                    {
                        networkAndZoneNamesDuplicates.Add(cpRange);
                    }
                    else
                    {
                        AddCheckPointObject(cpRange);
                    }
                }
            }

            var groupsWithNonCreatedMembers = new List<CheckPoint_NetworkGroup>();

            foreach (Juniper_AddressGroup group in _juniperParser.Filter("_AddressGroup"))
            {
                var cpNetworkGroup = new CheckPoint_NetworkGroup();
                cpNetworkGroup.Name = group.Name;
                cpNetworkGroup.Comments = group.Description;
                cpNetworkGroup.Members.AddRange(group.Members);
                cpNetworkGroup.Members.AddRange(group.MemberGroupNames);
                cpNetworkGroup.Tag = group.ZoneName;
                ApplyConversionIncidentOnCheckPointObject(cpNetworkGroup, group);
                inMultipleZones = IsNetworkObjectContainedInMultipleZones(cpNetworkGroup, group);
                CheckObjectNameValidity(cpNetworkGroup, group, inMultipleZones);

                // Check if the member groups are already created to avoid "object not found" errors during the import to DB.
                bool hasNonCreatedMembers = false;
                if (!inMultipleZones)
                {
                    foreach (var memberGroupName in group.MemberGroupNames)
                    {
                        bool found = _cpNetworkGroups.Any(cpGroup => cpGroup.Name == memberGroupName);
                        if (!found)
                        {
                            groupsWithNonCreatedMembers.Add(cpNetworkGroup);
                            hasNonCreatedMembers = true;
                        }
                    }
                }

                if (!inMultipleZones && !hasNonCreatedMembers)
                {
                    AddCheckPointObject(cpNetworkGroup);
                }
            }

            // Now, add the objects with the same name that exist in multiple zones.
            foreach (var cpNetworkObject in _cpNetworkObjectsInMultipleZones)
            {
                string originalName = cpNetworkObject.Name;
                string uniqueName = originalName + "_" + cpNetworkObject.Tag;   // original name combined with the zone name
                cpNetworkObject.Name = uniqueName;   // replace the original name with the unique one
                AddCheckPointObject(cpNetworkObject);
            }

            // Add the network objects that have name duplication with zones names.
            foreach (var cpNetworkObject in networkAndZoneNamesDuplicates)
            {
                string originalName = cpNetworkObject.Name;
                string uniqueName = originalName + "_" + cpNetworkObject.Tag;   // original name combined with the zone name
                cpNetworkObject.Name = uniqueName;   // replace the original name with the unique one
                AddCheckPointObject(cpNetworkObject);
            }

            // After all groups are created, add the groups that had non created member groups.
            foreach (var networkGroup in groupsWithNonCreatedMembers)
            {
                AddCheckPointObject(networkGroup);
            }

            // Finally, search and update references in network groups, AFTER all objects are added.
            foreach (var cpNetworkObject in _cpNetworkObjectsInMultipleZones)
            {
                foreach (var networkGroup in _cpNetworkGroups)
                {
                    if (cpNetworkObject.Tag == networkGroup.Tag)   // search in the same zone only...
                    {
                        string zoneSuffix = "_" + cpNetworkObject.Tag;
                        string originalName = cpNetworkObject.Name.Replace(zoneSuffix, "");
                        int pos = networkGroup.Members.IndexOf(originalName);
                        if (pos != -1)
                        {
                            networkGroup.Members[pos] = cpNetworkObject.Name;
                        }
                    }
                }
            }

            // Apply the same for the network objects that have name duplication with zones names.
            foreach (var cpNetworkObject in networkAndZoneNamesDuplicates)
            {
                foreach (var networkGroup in _cpNetworkGroups)
                {
                    string zoneSuffix = "_" + cpNetworkObject.Tag;
                    string originalName = cpNetworkObject.Name.Replace(zoneSuffix, "");
                    int pos = networkGroup.Members.IndexOf(originalName);
                    if (pos != -1)
                    {
                        networkGroup.Members[pos] = cpNetworkObject.Name;
                    }
                }
            }
        }

        private void Add_InterfacesAndRoutes()
        {
            foreach (Juniper_Interface ifc in JuniperInterfaces)
            {
                if (ifc.Topology.Count == 0)
                {
                    // Invalid interface configuration...
                    continue;
                }

                // Create network group object that has the network associated with the interface.
                if (!ifc.LeadsToInternet)
                {
                    var distinctNetworks = new List<string>();

                    var cpNetworkGroup = new CheckPoint_NetworkGroup();
                    cpNetworkGroup.Name = ifc.Name + "_subnets";
                    cpNetworkGroup.Comments = ifc.Description;

                    foreach (var subnet in ifc.Topology)
                    {
                        if (distinctNetworks.Contains(subnet.IpAddress))
                        {
                            continue;
                        }
                        distinctNetworks.Add(subnet.IpAddress);

                        string networkName = "network_" + subnet.IpAddress + "_" + NetworkUtils.GetMaskLength(subnet.Netmask);

                        var cpNetwork = new CheckPoint_Network();
                        cpNetwork.Name = networkName;
                        cpNetwork.Subnet = subnet.IpAddress;
                        cpNetwork.Netmask = subnet.Netmask;
                        AddCheckPointObject(cpNetwork);

                        cpNetworkGroup.Members.Add(cpNetwork.Name);
                    }

                    ApplyConversionIncidentOnCheckPointObject(cpNetworkGroup, ifc);
                    CheckObjectNameValidity(cpNetworkGroup, ifc);
                    AddCheckPointObject(cpNetworkGroup);
                }

                // Create host object for the interface's primary/preferred IP address.
                var cpHost = new CheckPoint_Host();
                cpHost.Name = ifc.Name + "_address";
                cpHost.IpAddress = ifc.MainIpAddress;
                ApplyConversionIncidentOnCheckPointObject(cpHost, ifc);
                CheckObjectNameValidity(cpHost, ifc);
                AddCheckPointObject(cpHost);
            }
        }

        // This method resolves the interfaces subnets overlaping issue by creating 
        // a new network group with excusion (CheckPoint_GroupWithExclusion).
        private void Add_or_Modify_InterfaceNetworkGroups()
        {
            var interfaceGroupObjects = new List<CheckPoint_NetworkGroup>();

            foreach (Juniper_Interface ifc in JuniperInterfaces)
            {
                string interfaceGroupName = ifc.Name + "_subnets";
                var cpObject = _cpObjects.GetObject(interfaceGroupName);
                if (cpObject != null)
                {
                    interfaceGroupObjects.Add((CheckPoint_NetworkGroup)cpObject);
                }
            }

            var modifiedNetworkGroups = Add_or_Modify_InterfaceNetworkGroups(interfaceGroupObjects);

            // Apply object name verification.
            foreach (var modifiedNetworkGroup in modifiedNetworkGroups)
            {
                if (_cpUnsafeNames.Contains(modifiedNetworkGroup))
                {
                    _cpUnsafeNames.Add(modifiedNetworkGroup + "_include");
                    _cpUnsafeNames.Add(modifiedNetworkGroup + "_exclude");
                }
            }
        }

        private void Add_Zones()
        {
            foreach (Juniper_Zone zone in JuniperZones)
            {
                var cpZone = new CheckPoint_Zone();
                cpZone.Name = zone.Name;
                cpZone.Comments = zone.Description;
                CheckObjectNameValidity(cpZone, zone);
                AddCheckPointObject(cpZone);

                // Create a network group object that contains network group objects associated with each interface.
                var members = new List<string>();
                foreach (var ifcName in zone.Interfaces)
                {
                    foreach (Juniper_Interface ifc in JuniperInterfaces)
                    {
                        if (ifcName == ifc.Name)
                        {
                            if (ifc.LeadsToInternet)
                            {
                                zone.LeadsToInternet = true;
                            }
                            else
                            {
                                var cpObject = _cpObjects.GetObject(ifcName + "_subnets");
                                if (cpObject != null)
                                {
                                    members.Add(cpObject.Name);
                                }
                            }

                            break;
                        }
                    }

                    if (zone.LeadsToInternet)
                    {
                        break;
                    }
                }

                if (!zone.LeadsToInternet && (members.Count > 0))
                {
                    var cpNetworkGroup = new CheckPoint_NetworkGroup();
                    cpNetworkGroup.Name = "zone_" + zone.Name + "_subnets";
                    cpNetworkGroup.Members.AddRange(members);
                    cpNetworkGroup.CreateAfterGroupsWithExclusion = true;
                    CheckObjectNameValidity(cpNetworkGroup, zone);
                    AddCheckPointObject(cpNetworkGroup);
                }
            }
        }

        private void Add_ServiceObjects()
        {
            foreach (Juniper_Application application in _juniperParser.Filter("_Application"))
            {
                switch (application.Protocol)
                {
                    case "any":
                        // do nothing...
                        break;

                    case "tcp":
                        if (!string.IsNullOrEmpty(application.ProgramNumber))
                        {
                            var cpRpc = new CheckPoint_RpcService();
                            cpRpc.Name = application.Name;
                            cpRpc.Comments = application.Description;
                            cpRpc.ProgramNumber = application.ProgramNumber;
                            ApplyConversionIncidentOnCheckPointObject(cpRpc, application);
                            CheckObjectNameValidity(cpRpc, application);
                            AddCheckPointObject(cpRpc);
                        }
                        else if (!string.IsNullOrEmpty(application.InterfaceUuid))
                        {
                            var cpDceRpc = new CheckPoint_DceRpcService();
                            cpDceRpc.Name = application.Name;
                            cpDceRpc.Comments = application.Description;
                            cpDceRpc.InterfaceUuid = application.InterfaceUuid;
                            ApplyConversionIncidentOnCheckPointObject(cpDceRpc, application);
                            CheckObjectNameValidity(cpDceRpc, application);
                            AddCheckPointObject(cpDceRpc);
                        }
                        else if (!string.IsNullOrEmpty(application.Port))
                        {
                            string cpServiceName = "TCP_" + application.Port;

                            if (!DoesJuniperApplicationMatchCheckpointPredefinedService(application, cpServiceName))
                            {
                                var cpTcp = new CheckPoint_TcpService();
                                cpTcp.Name = application.Name;
                                cpTcp.Comments = application.Description;
                                cpTcp.Port = application.Port;
                                cpTcp.SessionTimeout = application.InactivityTimeout.ToString();
                                ApplyConversionIncidentOnCheckPointObject(cpTcp, application);
                                CheckObjectNameValidity(cpTcp, application);
                                AddCheckPointObject(cpTcp);
                            }
                        }
                        else
                        {
                            var error = new CheckPoint_ServiceGroup();
                            error.Name = "_Err_in_service-line_" + application.LineNumber;
                            error.Comments = application.Description;
                            ApplyConversionIncidentOnCheckPointObject(error, application);
                            AddCheckPointObject(error);
                            _juniperInvalidApplicationsReferences.Add(application.Name, error.Name);
                        }
                        break;

                    case "udp":
                        if (!string.IsNullOrEmpty(application.ProgramNumber))
                        {
                            var cpRpc = new CheckPoint_RpcService();
                            cpRpc.Name = application.Name;
                            cpRpc.Comments = application.Description;
                            cpRpc.ProgramNumber = application.ProgramNumber;
                            ApplyConversionIncidentOnCheckPointObject(cpRpc, application);
                            CheckObjectNameValidity(cpRpc, application);
                            AddCheckPointObject(cpRpc);
                        }
                        else if (!string.IsNullOrEmpty(application.InterfaceUuid))
                        {
                            var cpDceRpc = new CheckPoint_DceRpcService();
                            cpDceRpc.Name = application.Name;
                            cpDceRpc.Comments = application.Description;
                            cpDceRpc.InterfaceUuid = application.InterfaceUuid;
                            ApplyConversionIncidentOnCheckPointObject(cpDceRpc, application);
                            CheckObjectNameValidity(cpDceRpc, application);
                            AddCheckPointObject(cpDceRpc);
                        }
                        else if (!string.IsNullOrEmpty(application.Port))
                        {
                            string cpServiceName = "UDP_" + application.Port;

                            if (!DoesJuniperApplicationMatchCheckpointPredefinedService(application, cpServiceName))
                            {
                                var cpUdp = new CheckPoint_UdpService();
                                cpUdp.Name = application.Name;
                                cpUdp.Comments = application.Description;
                                cpUdp.Port = application.Port;
                                cpUdp.SessionTimeout = application.InactivityTimeout.ToString();
                                ApplyConversionIncidentOnCheckPointObject(cpUdp, application);
                                CheckObjectNameValidity(cpUdp, application);
                                AddCheckPointObject(cpUdp);
                            }
                        }
                        else
                        {
                            var error = new CheckPoint_ServiceGroup();
                            error.Name = "_Err_in_service-line_" + application.LineNumber;
                            error.Comments = application.Description;
                            ApplyConversionIncidentOnCheckPointObject(error, application);
                            AddCheckPointObject(error);
                            _juniperInvalidApplicationsReferences.Add(application.Name, error.Name);
                        }
                        break;

                    case "sctp":
                        var cpSctp = new CheckPoint_SctpService();
                        cpSctp.Name = application.Name;
                        cpSctp.Comments = application.Description;
                        cpSctp.Port = application.Port;
                        cpSctp.SessionTimeout = application.InactivityTimeout.ToString();
                        ApplyConversionIncidentOnCheckPointObject(cpSctp, application);
                        CheckObjectNameValidity(cpSctp, application);
                        AddCheckPointObject(cpSctp);
                        break;

                    case "icmp":
                        if (!string.IsNullOrEmpty(application.IcmpType))
                        {
                            string cpServiceName = "ICMP_" + application.IcmpType;

                            if (!DoesJuniperApplicationMatchCheckpointPredefinedService(application, cpServiceName))
                            {
                                var cpIcmp = new CheckPoint_IcmpService();
                                cpIcmp.Name = application.Name;
                                cpIcmp.Comments = application.Description;
                                cpIcmp.Type = application.IcmpType;
                                cpIcmp.Code = application.IcmpCode;
                                ApplyConversionIncidentOnCheckPointObject(cpIcmp, application);
                                CheckObjectNameValidity(cpIcmp, application);
                                AddCheckPointObject(cpIcmp);
                            }
                        }
                        else
                        {
                            var error = new CheckPoint_ServiceGroup();
                            error.Name = "_Err_in_service-line_" + application.LineNumber;
                            error.Comments = application.Description;
                            ApplyConversionIncidentOnCheckPointObject(error, application);
                            AddCheckPointObject(error);
                            _juniperInvalidApplicationsReferences.Add(application.Name, error.Name);
                        }
                        break;

                    default:   // "other" services...
                        if (!string.IsNullOrEmpty(application.Protocol) && JuniperKnownApplications.IsKnownProtocolOrPortName(application.Protocol))
                        {
                            string cpServiceName = "OTHER_" + application.Port;

                            if (!DoesJuniperApplicationMatchCheckpointPredefinedService(application, cpServiceName))
                            {
                                var other = new CheckPoint_OtherService();
                                other.Name = application.Name;
                                other.Comments = application.Description;
                                other.IpProtocol = application.Port;
                                ApplyConversionIncidentOnCheckPointObject(other, application);
                                CheckObjectNameValidity(other, application);
                                AddCheckPointObject(other);
                            }
                        }
                        else
                        {
                            var error = new CheckPoint_ServiceGroup();
                            error.Name = "_Err_in_service-line_" + application.LineNumber;
                            error.Comments = application.Description;
                            ApplyConversionIncidentOnCheckPointObject(error, application);
                            AddCheckPointObject(error);
                            _juniperInvalidApplicationsReferences.Add(application.Name, error.Name);
                        }
                        break;
                }
            }

            var groupsWithNonCreatedMembers = new List<CheckPoint_ServiceGroup>();

            foreach (Juniper_ApplicationGroup group in _juniperParser.Filter("_ApplicationGroup"))
            {
                var cpServiceGroup = new CheckPoint_ServiceGroup();
                cpServiceGroup.Name = group.Name;
                cpServiceGroup.Comments = group.Description;
                cpServiceGroup.Members.AddRange(group.Members);
                cpServiceGroup.Members.AddRange(group.MemberGroupNames);
                ApplyConversionIncidentOnCheckPointObject(cpServiceGroup, group);
                CheckObjectNameValidity(cpServiceGroup, group);

                // Check if the member groups are already created to avoid "object not found" errors during the import to DB.
                bool hasNonCreatedMembers = false;
                foreach (var memberGroupName in group.MemberGroupNames)
                {
                    bool found = _cpServiceGroups.Any(cpGroup => cpGroup.Name == memberGroupName);
                    if (!found)
                    {
                        groupsWithNonCreatedMembers.Add(cpServiceGroup);
                        hasNonCreatedMembers = true;
                    }
                }

                if (!hasNonCreatedMembers)
                {
                    AddCheckPointObject(cpServiceGroup);
                }
            }

            // After all groups are created, add the groups that had non created member groups.
            foreach (var serviceGroup in groupsWithNonCreatedMembers)
            {
                AddCheckPointObject(serviceGroup);
            }
        }
		private void Add_Schedulers()
        {
            List<string> cpTimeRangesNamesUniq = new List<string>();
            foreach (Juniper_Scheduler scheduler in _juniperParser.Filter("_Scheduler"))
            {
                List<CheckPoint_Time> timesList = new List<CheckPoint_Time>();//will store time-objects for separate days with different hours-ranges                              
                
                int postfixIndex = 1;//postfix of time-object in case Juniper scheduler is split to several objects     

                if (scheduler.StartStopDates.Count == 0)
                {// check if time object has Start Time
                    CheckPoint_Time cpTime = new CheckPoint_Time();
                    cpTime.Comments = "Old Time Object name: " + scheduler.Name;
                    cpTime.StartNow = true;
                    cpTime.EndNever = true;
					cpTime.Name = checkTimeNameLength(scheduler.Name, cpTimeRangesNamesUniq);
					
                    Add_TimeObject(scheduler, cpTime, timesList, cpTimeRangesNamesUniq);
                    foreach (CheckPoint_Time time in timesList)
                        AddCheckPointObject(time);
                }
                else {
                    foreach (string sdate in scheduler.StartStopDates) //create separate time-object for each start-date
                    {
                        CheckPoint_Time cpTime = new CheckPoint_Time();
                        cpTime.Comments = "Old Time Object name: " + scheduler.Name;
                        //2020-09-06.01:01;2020-09-08.12:30
                        if (scheduler.StartStopDates.Count == 1)
                        {
                            cpTime.Name = checkTimeNameLength(scheduler.Name, cpTimeRangesNamesUniq);                       
                        }
                        else
                        {
                            if (scheduler.Name.Length <= 8)
                                cpTime.Name = scheduler.Name + "_" + postfixIndex++;
                            else
                            {
                                cpTime.Name = scheduler.Name.Substring(0, 8) + "_" + postfixIndex++;
                                while (cpTimeRangesNamesUniq.Contains(cpTime.Name))
                                {
                                    cpTime.Name = scheduler.Name.Substring(0, 8) + "_" + postfixIndex++;
                                }                                
                            }                                
                        }
                        cpTime.StartNow = false;
                        DateTime date = DateTime.ParseExact(sdate.Substring(0, sdate.IndexOf(";")), "yyyy-MM-dd.HH:mm", CultureInfo.InvariantCulture);
                        cpTime.StartDate = date.ToString("dd-MMM-yyyy", CultureInfo.InvariantCulture).Trim();
                        cpTime.StartTime = date.ToString("HH:mm").Trim();

                        cpTime.EndNever = false;
                        date = DateTime.ParseExact(sdate.Substring(sdate.IndexOf(";") + 1), "yyyy-MM-dd.HH:mm", CultureInfo.InvariantCulture);
                        cpTime.EndDate = date.ToString("dd-MMM-yyyy", CultureInfo.InvariantCulture).Trim();
                        cpTime.EndTime = date.ToString("HH:mm").Trim();
                        
                        Add_TimeObject(scheduler, cpTime, timesList, cpTimeRangesNamesUniq);

                        foreach (CheckPoint_Time time in timesList)
                            AddCheckPointObject(time);
                    }                    
                }  
            }
        }

        /// <summary>
        /// Check the length of time object name.
        /// CheckPoint time object name is limited to 11 chars. In case it's more than 11 it's either truncated or truncated and completed with postfix so that to be unique.
        /// </summary>         
        private string checkTimeNameLength(string timeName, List<string> cpTimeRangesNamesUniq)
        {
            int postfixIndex = 1;
            if (timeName.Length > 11)
            {
                timeName = timeName.Substring(0, 11);
                while (cpTimeRangesNamesUniq.Contains(timeName))
                {
                    timeName = timeName.Substring(0, 8) + "_" + postfixIndex++;
                }
                return timeName;
            }
            else
            {
                return timeName;
            }
        }

        private List<CheckPoint_Time> Add_TimeObject(Juniper_Scheduler scheduler, CheckPoint_Time cpTime, List<CheckPoint_Time> timesList, List<string> cpTimeRangesNamesUniq)
        {
            List<string> daysList = new List<string> { "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" };

            int postfixIndex = 1;//postfix of time-object in case Juniper scheduler is split to several objects

            bool dailyIsConfigured = false;

            bool daysAreAddedToPattern = false;//used for exclude statement. 
            //In case some day is excluded from the scheduler, RecurrencePattern is changed to weekly and all days except excluded day are added to RecurrenceWeekdays (need to be done once)

            if (scheduler.patternDictionary.Keys.Count != 0)
            {
                foreach (var day in scheduler.patternDictionary.Keys)
                {
                    if (day.Equals("daily"))
                    {
                        dailyIsConfigured = true;
                        cpTime.RecurrencePattern = CheckPoint_Time.RecurrencePatternEnum.Daily;

                        processHoursRanges(scheduler.patternDictionary[day], cpTime);
                        
                        timesList.Add(cpTime);
                        cpTimeRangesNamesUniq.Add(cpTime.Name);
                    }
                    else
                    {
                        cpTime.RecurrencePattern = CheckPoint_Time.RecurrencePatternEnum.Weekly;

                        if (scheduler.patternDictionary[day][0].Equals("all-day"))
                        {                            
                            cpTime.RecurrenceWeekdays.Add((CheckPoint_Time.Weekdays)daysList.IndexOf(day));
                            
                            timesList.Add(cpTime);
                            cpTimeRangesNamesUniq.Add(cpTime.Name);
                        }
                        else if (scheduler.patternDictionary[day][0].Equals("exclude"))
                        {
                            if (!daysAreAddedToPattern && dailyIsConfigured)
                            {                                
                                if (!cpTime.RecurrenceWeekdays.Contains(CheckPoint_Time.Weekdays.Sun))
                                    cpTime.RecurrenceWeekdays.Add(CheckPoint_Time.Weekdays.Sun);
                                if (!cpTime.RecurrenceWeekdays.Contains(CheckPoint_Time.Weekdays.Mon))
                                    cpTime.RecurrenceWeekdays.Add(CheckPoint_Time.Weekdays.Mon);
                                if (!cpTime.RecurrenceWeekdays.Contains(CheckPoint_Time.Weekdays.Tue))
                                    cpTime.RecurrenceWeekdays.Add(CheckPoint_Time.Weekdays.Tue);
                                if (!cpTime.RecurrenceWeekdays.Contains(CheckPoint_Time.Weekdays.Wed))
                                    cpTime.RecurrenceWeekdays.Add(CheckPoint_Time.Weekdays.Wed);
                                if (!cpTime.RecurrenceWeekdays.Contains(CheckPoint_Time.Weekdays.Thu))
                                    cpTime.RecurrenceWeekdays.Add(CheckPoint_Time.Weekdays.Thu);
                                if (!cpTime.RecurrenceWeekdays.Contains(CheckPoint_Time.Weekdays.Fri))
                                    cpTime.RecurrenceWeekdays.Add(CheckPoint_Time.Weekdays.Fri);
                                if (!cpTime.RecurrenceWeekdays.Contains(CheckPoint_Time.Weekdays.Sat))
                                    cpTime.RecurrenceWeekdays.Add(CheckPoint_Time.Weekdays.Sat);
                                daysAreAddedToPattern = true;
                            }
                            cpTime.RecurrenceWeekdays.Remove((CheckPoint_Time.Weekdays)daysList.IndexOf(day));
                        }
                        else
                        {
                            CheckPoint_Time cpTimeAdd = new CheckPoint_Time();//create separate time-object for each day in case hours ranges for day are set                                              

                            cpTimeAdd = cpTime.Clone();

                            cpTime.RecurrenceWeekdays.Remove((CheckPoint_Time.Weekdays)daysList.IndexOf(day));//remove day from the common TO because for this day separate TO is created
                            cpTimeAdd.RecurrenceWeekdays.Add((CheckPoint_Time.Weekdays)daysList.IndexOf(day));

                            if (cpTimeAdd.Name.Length <= 8)
                                cpTimeAdd.Name = cpTimeAdd.Name + "_" + postfixIndex++;
                            else
                            {
                                cpTimeAdd.Name = cpTimeAdd.Name.Substring(0, 8) + "_" + postfixIndex++;
                                while (cpTimeRangesNamesUniq.Contains(cpTimeAdd.Name))
                                {
                                    cpTimeAdd.Name = cpTimeAdd.Name.Substring(0, 8) + "_" + postfixIndex++;
                                }
                            }

                            foreach (string timeRange in scheduler.patternDictionary[day])
                            {
                                processHoursRanges(scheduler.patternDictionary[day], cpTimeAdd);
                            }
                            
                            timesList.Add(cpTimeAdd);
                            cpTimeRangesNamesUniq.Add(cpTimeAdd.Name);
                        }
                    }
                }
            }
            else
            {
                cpTime.RecurrencePattern = CheckPoint_Time.RecurrencePatternEnum.None;
                timesList.Add(cpTime);
                cpTimeRangesNamesUniq.Add(cpTime.Name);
            }

            return timesList;                   
        }

        /// <summary>
        /// Convert Juniper scheduler start- and stop-time (in format HH:MM:SS) into CheckPoint hours-ranges parameter in required format (HH:MM)
        /// </summary>
        private void processHoursRanges(List<string> timeRanges, CheckPoint_Time cpTime)
        {
            foreach (string timeRange in timeRanges)
            {
                if (timeRange.IndexOf(";") != -1)
                {
                    string startTime = timeRange.Substring(0, timeRange.IndexOf(";"));                    
                    string stopTime = timeRange.Substring(timeRange.IndexOf(";") + 1);
                    
                    TimeSpan timeCheck0 = TimeSpan.ParseExact(startTime, "hh\\:mm\\:ss", CultureInfo.InvariantCulture);
                    TimeSpan timeCheck1 = TimeSpan.ParseExact(stopTime, "hh\\:mm\\:ss", CultureInfo.InvariantCulture);

                    if (TimeSpan.Compare(timeCheck0, timeCheck1) == -1)
                    {
                        if (timeRanges.IndexOf(timeRange) == 0)
                        {
                            cpTime.HoursRangesEnabled_1 = true;                                                        
                            cpTime.HoursRangesFrom_1 = timeCheck0.ToString(@"hh\:mm").Trim();                            
                            cpTime.HoursRangesTo_1 = timeCheck1.ToString(@"hh\:mm").Trim();
                        } else
                        {
                            cpTime.HoursRangesEnabled_2 = true;                            
                            cpTime.HoursRangesFrom_2 = timeCheck0.ToString(@"hh\:mm").Trim();                            
                            cpTime.HoursRangesTo_2 = timeCheck1.ToString(@"hh\:mm").Trim();
                        }                        
                    }                  
                }
            }            
        }

        private void Add_Package()
        {
            var cpPackage = new CheckPoint_Package();
            cpPackage.Name = _policyPackageName;

            Add_ParentLayer(cpPackage);
            Add_Layers_And_Rules(cpPackage);
            Add_Global_Rules(cpPackage);

            AddCheckPointObject(cpPackage);
        }

        private void Add_ParentLayer(CheckPoint_Package package)
        {
            package.ParentLayer.Name = package.NameOfAccessLayer;

            var cpManagementHost = GetJuniperManagementHost();
            var managementRules = new List<CheckPoint_Rule>();

            foreach (Juniper_ZonePolicy zonePolicy in JuniperZonePolicies)
            {
                // Should we add a special management-access parent rule?
                if (zonePolicy.IsManagementAccessPolicy)
                {
                    if (cpManagementHost == null)
                    {
                        zonePolicy.ConversionIncidentType = ConversionIncidentType.Informative;

                        _conversionIncidents.Add(new ConversionIncident(zonePolicy.LineNumber,
                                                                        "Error creating an access management policy, missing topology information for Juniper FXP0 interface",
                                                                        "All related rules are skipped.",
                                                                        zonePolicy.ConversionIncidentType));
                    }
                    else
                    {
                        foreach (var juniperRule in zonePolicy.Rules)
                        {
                            var cpManagementRule = Juniper_To_ManagementCPRule(juniperRule, package.NameOfAccessLayer, zonePolicy.SourceZone, cpManagementHost);
                            managementRules.Add(cpManagementRule);
                        }
                    }

                    continue;
                }

                var cpSourceZone = GetCheckPointObjectOrCreateDummy(zonePolicy.SourceZone,
                                                                    "NetworkGroup",
                                                                    zonePolicy,
                                                                    "Error creating a parent layer rule, missing information for Juniper source zone",
                                                                    "Source zone details: " + zonePolicy.SourceZone + ".");
                var cpDestZone = GetCheckPointObjectOrCreateDummy(zonePolicy.DestinationZone,
                                                                  "NetworkGroup",
                                                                  zonePolicy,
                                                                  "Error creating a parent layer rule, missing information for Juniper destination zone",
                                                                  "Destination zone details: " + zonePolicy.DestinationZone + ".");

                var cpRule = new CheckPoint_Rule();
                cpRule.Source.Add(cpSourceZone);
                cpRule.Destination.Add(cpDestZone);
                cpRule.Action = CheckPoint_Rule.ActionType.SubPolicy;
                cpRule.SubPolicyName = zonePolicy.SourceZone + "_to_" + zonePolicy.DestinationZone + "_sub_policy";
                cpRule.Layer = package.NameOfAccessLayer;
                ApplyConversionIncidentOnCheckPointObject(cpRule, zonePolicy);

                package.ParentLayer.Rules.Add(cpRule);

                string policyZone = zonePolicy.SourceZone + "-" + zonePolicy.DestinationZone;
                _policyZonesLookup.Add(policyZone);
            }

            if (managementRules.Count > 0)
            {
                int ruleNumber = 0;

                // Insert on top!!!
                foreach (var cpRule in managementRules)
                {
                    package.ParentLayer.Rules.Insert(ruleNumber, cpRule);
                    ++ruleNumber;
                }
            }
        }

        private void Add_Layers_And_Rules(CheckPoint_Package package)
        {
            foreach (Juniper_ZonePolicy zonePolicy in JuniperZonePolicies)
            {
                if (zonePolicy.IsManagementAccessPolicy)
                {
                    continue;
                }

                var cpLayer = new CheckPoint_Layer();
                cpLayer.Name = zonePolicy.SourceZone + "_to_" + zonePolicy.DestinationZone + "_sub_policy";
                cpLayer.Comments = zonePolicy.Description;
                cpLayer.Tag = zonePolicy.SourceZone + "," + zonePolicy.DestinationZone;   // this info is needed later for global policy rules

                foreach (var juniperRule in zonePolicy.Rules)
                {
                    var cpRule = Juniper_To_CPRule(juniperRule, cpLayer.Name, zonePolicy.SourceZone, zonePolicy.DestinationZone);
                    cpLayer.Rules.Add(cpRule);

                    if (cpRule.ConversionIncidentType != ConversionIncidentType.None || juniperRule.ConversionIncidentType != ConversionIncidentType.None)
                    {
                        package.ConversionIncidentType = ConversionIncidentType.Informative;
                    }
                }

                package.SubPolicies.Add(cpLayer);
                validatePackage(package);
            }
        }

        private void Add_Global_Rules(CheckPoint_Package package)
        {
            bool isZonelessAllGlobalRules = true;
            foreach (var globalPolicyRule in _juniperParser.GetGlobalPolicyRules())
            {
                bool isZonelessGlobalRule = globalPolicyRule.SourceZones.Count == 1 && globalPolicyRule.SourceZones[0] == JuniperObject.Any &&
                                            globalPolicyRule.DestinationZones.Count == 1 && globalPolicyRule.DestinationZones[0] == JuniperObject.Any;
                if (isZonelessAllGlobalRules && !isZonelessGlobalRule)
                {
                    isZonelessAllGlobalRules = false;
                }
            }

            if (isZonelessAllGlobalRules && _juniperParser.GetGlobalPolicyRules().Count > 1)
            {
                CheckPoint_Rule cpRule4GlobalLayer = new CheckPoint_Rule();
                cpRule4GlobalLayer.Name = "";
                cpRule4GlobalLayer.Layer = package.NameOfAccessLayer;
                cpRule4GlobalLayer.Source.Add(_cpObjects.GetObject(CheckPointObject.Any));
                cpRule4GlobalLayer.Destination.Add(_cpObjects.GetObject(CheckPointObject.Any));
                cpRule4GlobalLayer.Action = CheckPoint_Rule.ActionType.SubPolicy;
                cpRule4GlobalLayer.Track = CheckPoint_Rule.TrackTypes.None;
                cpRule4GlobalLayer.Time.Add(_cpObjects.GetObject(CheckPointObject.Any));
                cpRule4GlobalLayer.Service.Add(_cpObjects.GetObject(CheckPointObject.Any));
                cpRule4GlobalLayer.SubPolicyName = "Global Rules";

                package.ParentLayer.Rules.Add(cpRule4GlobalLayer);

                CheckPoint_Layer cpSubLayer4GlobalRules = new CheckPoint_Layer();
                cpSubLayer4GlobalRules.ApplicationsAndUrlFiltering = true;
                cpSubLayer4GlobalRules.Shared = true;
                cpSubLayer4GlobalRules.Name = cpRule4GlobalLayer.SubPolicyName;

                package.SubPolicies.Insert(0, cpSubLayer4GlobalRules); // insert at the begging becuase Global Rules should be created before all policy
                validatePackage(package);

                foreach (var globalPolicyRule in _juniperParser.GetGlobalPolicyRules())
                {
                    // Append the global policy rules BELOW the existing sub-policies.
                    CheckPoint_Rule cpRule = Juniper_To_CPRule(globalPolicyRule, cpSubLayer4GlobalRules.Name, null, null);
                    cpSubLayer4GlobalRules.Rules.Add(cpRule);
                }

                // Fill in the shared layer with global policy rules INSIDE the existing sub-policies.
                foreach (CheckPoint_Layer subPolicy in package.SubPolicies)
                {
                    if (subPolicy.Name.Equals(cpSubLayer4GlobalRules.Name))
                    {
                        continue;
                    }

                    CheckPoint_Rule cpSubRule4GlobalLayer = cpRule4GlobalLayer.Clone();
                    cpSubRule4GlobalLayer.Name = "Global Layer";
                    cpSubRule4GlobalLayer.Layer = subPolicy.Name;

                    subPolicy.Rules.Add(cpSubRule4GlobalLayer);
                }


                //the last rule which is created by default by CheckPoint script importer. It is for report only.
                var cpRuleCleanUp = new CheckPoint_Rule();
                cpRuleCleanUp.Name = Juniper_GlobalPolicyRule.DefaultActionRuleName;
                package.ParentLayer.Rules.Add(cpRuleCleanUp);
            }
            else
            {
                foreach (var globalPolicyRule in _juniperParser.GetGlobalPolicyRules())
                {
                    // Fill in the global policy rules INSIDE the existing sub-policies.
                    foreach (CheckPoint_Rule cpParentRule in package.ParentLayer.Rules)
                    {
                        if (cpParentRule.Action != CheckPoint_Rule.ActionType.SubPolicy)
                        {
                            continue;
                        }

                        // Get into the relevant sub-policy
                        foreach (CheckPoint_Layer subPolicy in package.SubPolicies)
                        {
                            if (subPolicy.Name != cpParentRule.SubPolicyName)
                            {
                                continue;
                            }

                            bool sourceZoneMatches = (globalPolicyRule.SourceZones.Count == 1 && globalPolicyRule.SourceZones[0] == JuniperObject.Any);
                            bool destZoneMatches = (globalPolicyRule.DestinationZones.Count == 1 && globalPolicyRule.DestinationZones[0] == JuniperObject.Any);
                            string[] subPolicyZones = subPolicy.Tag.Split(',');   // [source-zone,dest-zone]

                            if (!sourceZoneMatches)
                            {
                                if (globalPolicyRule.SourceZones.Any(sourceZone => sourceZone == subPolicyZones[0]))
                                {
                                    sourceZoneMatches = true;
                                }
                            }
                            if (!destZoneMatches)
                            {
                                if (globalPolicyRule.DestinationZones.Any(destZone => destZone == subPolicyZones[1]))
                                {
                                    destZoneMatches = true;
                                }
                            }

                            if (!(sourceZoneMatches && destZoneMatches))
                            {
                                continue;
                            }

                            // This is done to avoid duplication of incident reporting over all matched sub-policy rules.
                            ConversionIncidentType aclConversionIncident = globalPolicyRule.ConversionIncidentType;
                            globalPolicyRule.ConversionIncidentType = ConversionIncidentType.None;

                            CheckPoint_Rule cpRule = Juniper_To_CPRule(globalPolicyRule, subPolicy.Name, null, null);
                            subPolicy.Rules.Add(cpRule);

                            // If the global rule didn't have an incident previously, 
                            // and the incident was just encountered during this convertion, retain the incident!!!
                            if (globalPolicyRule.ConversionIncidentType == ConversionIncidentType.None)
                            {
                                globalPolicyRule.ConversionIncidentType = aclConversionIncident;
                            }

                            if (cpRule.ConversionIncidentType != ConversionIncidentType.None || globalPolicyRule.ConversionIncidentType != ConversionIncidentType.None)
                            {
                                package.ConversionIncidentType = ConversionIncidentType.Informative;
                            }
                        }
                    }

                    // Append the global policy rules BELOW the existing sub-policies.
                    bool isZonelessGlobalRule = globalPolicyRule.SourceZones.Count == 1 && globalPolicyRule.SourceZones[0] == JuniperObject.Any &&
                                                globalPolicyRule.DestinationZones.Count == 1 && globalPolicyRule.DestinationZones[0] == JuniperObject.Any;

                    if (isZonelessGlobalRule)
                    {
                        CheckPoint_Rule cpRule = Juniper_To_CPRule(globalPolicyRule, package.NameOfAccessLayer, null, null);
                        package.ParentLayer.Rules.Add(cpRule);
                    }
                    else
                    {
                        // In this case we should create a new parent rule and associated sub-policy for each couple of sourceZone and destZone.
                        foreach (var sourceZone in globalPolicyRule.SourceZones)
                        {
                            var cpSourceZone = GetCheckPointObjectOrCreateDummy(sourceZone,
                                                                                "NetworkGroup",
                                                                                globalPolicyRule,
                                                                                "Error creating a parent layer rule for global policy, missing information for Juniper source zone",
                                                                                "Source zone details: " + sourceZone + ".");

                            foreach (var destZone in globalPolicyRule.DestinationZones)
                            {
                                var cpDestZone = GetCheckPointObjectOrCreateDummy(destZone,
                                                                                  "NetworkGroup",
                                                                                  globalPolicyRule,
                                                                                  "Error creating a parent layer rule for global policy, missing information for Juniper destination zone",
                                                                                  "Destination zone details: " + destZone + ".");

                                // Avoid zone duplications!!!
                                string policyZone = sourceZone + "-" + destZone;
                                if (_policyZonesLookup.Contains(policyZone))
                                {
                                    continue;
                                }
                                _policyZonesLookup.Add(policyZone);

                                // 1. Create a new parent rule
                                var cpParentRule = new CheckPoint_Rule();
                                cpParentRule.Source.Add(cpSourceZone);
                                cpParentRule.Destination.Add(cpDestZone);
                                cpParentRule.Action = CheckPoint_Rule.ActionType.SubPolicy;
                                cpParentRule.SubPolicyName = sourceZone + "_to_" + destZone + "_sub_policy";
                                cpParentRule.Layer = package.NameOfAccessLayer;
                                cpParentRule.Comments = "Automatically created for global policy rule zones";
                                ApplyConversionIncidentOnCheckPointObject(cpParentRule, globalPolicyRule);

                                package.ParentLayer.Rules.Add(cpParentRule);

                                // 2. Create associated sub-policy
                                var cpLayer = new CheckPoint_Layer();
                                cpLayer.Name = cpParentRule.SubPolicyName;
                                cpLayer.Tag = ",";   // this info is needed later for global policy rules - in this case this sub-policy will be skipped!!!

                                package.SubPolicies.Add(cpLayer);
                                validatePackage(package);

                                // 3. Create a new rule and add to this sub-policy
                                var cpRule = Juniper_To_CPRule(globalPolicyRule, cpLayer.Name, sourceZone, destZone);
                                cpLayer.Rules.Add(cpRule);

                                if (cpRule.ConversionIncidentType != ConversionIncidentType.None || globalPolicyRule.ConversionIncidentType != ConversionIncidentType.None)
                                {
                                    package.ConversionIncidentType = ConversionIncidentType.Informative;
                                }
                            }
                        }
                    }
                }
            }
        }

        private CheckPoint_Rule Juniper_To_CPRule(Juniper_PolicyRule juniperRule, string cpLayerName, string sourceZone, string destZone)
        {
            bool isGlobalRule = (juniperRule is Juniper_GlobalPolicyRule);

            var cpRule = new CheckPoint_Rule();
            cpRule.Name = juniperRule.Name;
            cpRule.Comments = juniperRule.Description;
            cpRule.Layer = cpLayerName;
            cpRule.Enabled = !juniperRule.Inactive;

            ApplyConversionIncidentOnCheckPointObject(cpRule, juniperRule);

            CheckPointObject cpObject;

            foreach (var source in juniperRule.Sources)
            {
                string sourceName = source;

                if (!isGlobalRule && _juniperParser.IsNetworkObjectContainedInMultipleZones(source))
                {
                    sourceName = source + "_" + sourceZone;   // original name combined with the zone name
                }

                cpObject = GetCheckPointObjectOrCreateDummy(sourceName,
                                                            "NetworkGroup",
                                                            juniperRule,
                                                            "Error creating a rule, missing information for source Juniper object",
                                                            "Source object details: " + sourceName + ".",
                                                            isGlobalRule);

                if (!isGlobalRule && cpObject == null)
                {
                    // If the source object was not found in the address-book of source-zone, 
                    // try in global address-book without zone suffix.
                    cpObject = GetCheckPointObjectOrCreateDummy(source,
                                                                "NetworkGroup",
                                                                juniperRule,
                                                                "Error creating a rule, missing information for source Juniper object",
                                                                "Source object details: " + source + ".");
                }

                cpRule.Source.Add(cpObject);
            }

            foreach (var dest in juniperRule.Destinations)
            {
                string destName = dest;

                if (!isGlobalRule && _juniperParser.IsNetworkObjectContainedInMultipleZones(dest))
                {
                    destName = dest + "_" + destZone;   // original name combined with the zone name
                }

                cpObject = GetCheckPointObjectOrCreateDummy(destName,
                                                            "NetworkGroup",
                                                            juniperRule,
                                                            "Error creating a rule, missing information for destination Juniper object",
                                                            "Destination object details: " + destName + ".",
                                                            isGlobalRule);

                if (!isGlobalRule && cpObject == null)
                {
                    // If the dest object was not found in the address-book of dest-zone, 
                    // try in global address-book without zone suffix.
                    cpObject = GetCheckPointObjectOrCreateDummy(dest,
                                                                "NetworkGroup",
                                                                juniperRule,
                                                                "Error creating a rule, missing information for destination Juniper object",
                                                                "Destination object details: " + dest + ".");
                }

                cpRule.Destination.Add(cpObject);
            }
			
            //add scheduler
            foreach (var scheduler in juniperRule.Scheduler)
            {   
                cpObject = GetCheckPointObjectOrCreateDummy(scheduler,
                                                        "Time",
                                                        juniperRule,
                                                        "Not applying time-range objects.",
                                                        "Appropriate time object should be added manually.");
                cpRule.Time.Add(cpObject);                
              
            }

            // Avoid general "icmp-proto" service duplicates
            bool hasGeneralIcmpService = false;

            foreach (var application in juniperRule.Applications)
            {
                cpObject = GetCheckPointObjectOrCreateDummy(application,
                                                            "ServiceGroup",
                                                            juniperRule,
                                                            "Error creating a rule, missing information for application Juniper object",
                                                            "Application object details: " + application + ".");
                
                if (cpObject.Name == "icmp-proto")
                {
                    if (hasGeneralIcmpService)
                    {
                        continue;
                    }
                    hasGeneralIcmpService = true;
                }

                cpRule.Service.Add(cpObject);
            }

            switch (juniperRule.Action)
            {
                case Juniper_PolicyRule.ActionType.Permit:
                    cpRule.Action = CheckPoint_Rule.ActionType.Accept;
                    break;
                case Juniper_PolicyRule.ActionType.Deny:
                    cpRule.Action = CheckPoint_Rule.ActionType.Drop;
                    break;
                case Juniper_PolicyRule.ActionType.Reject:
                    cpRule.Action = CheckPoint_Rule.ActionType.Reject;
                    break;
                default:
                    cpRule.Action = CheckPoint_Rule.ActionType.Drop;
                    break;
            }

            cpRule.SourceNegated = juniperRule.SourceNegate;
            cpRule.DestinationNegated = juniperRule.DestinationNegate;
            cpRule.Track = juniperRule.Log ? CheckPoint_Rule.TrackTypes.Log : CheckPoint_Rule.TrackTypes.None;

            return cpRule;
        }

        private CheckPoint_Rule Juniper_To_ManagementCPRule(Juniper_PolicyRule juniperRule, string cpLayerName, string sourceZone, CheckPointObject destination)
        {
            var cpRule = new CheckPoint_Rule();
            cpRule.Name = juniperRule.Name;
            cpRule.Layer = cpLayerName;
            cpRule.Enabled = !juniperRule.Inactive;
            cpRule.Destination.Add(destination);
            cpRule.SourceNegated = juniperRule.SourceNegate;
            cpRule.Track = juniperRule.Log ? CheckPoint_Rule.TrackTypes.Log : CheckPoint_Rule.TrackTypes.None;
            cpRule.ConversionComments = "Management Access";

            ApplyConversionIncidentOnCheckPointObject(cpRule, juniperRule);

            CheckPointObject cpObject;

            foreach (var source in juniperRule.Sources)
            {
                string sourceName = source;

                if (_juniperParser.IsNetworkObjectContainedInMultipleZones(source))
                {
                    sourceName = source + "_" + sourceZone;   // original name combined with the zone name
                }

                cpObject = GetCheckPointObjectOrCreateDummy(sourceName,
                                                            "NetworkGroup",
                                                            juniperRule,
                                                            "Error creating a rule, missing information for source Juniper object",
                                                            "Source object details: " + sourceName + ".",
                                                            false);

                if (cpObject == null)
                {
                    // If the source object was not found in the address-book of source-zone, 
                    // try in global address-book without zone suffix.
                    cpObject = GetCheckPointObjectOrCreateDummy(source,
                                                                "NetworkGroup",
                                                                juniperRule,
                                                                "Error creating a rule, missing information for source Juniper object",
                                                                "Source object details: " + source + ".");
                }

                cpRule.Source.Add(cpObject);
            }

            foreach (var application in juniperRule.Applications)
            {
                cpObject = GetCheckPointObjectOrCreateDummy(application,
                                                            "ServiceGroup",
                                                            juniperRule,
                                                            "Error creating a rule, missing information for application Juniper object",
                                                            "Application object details: " + application + ".");
                cpRule.Service.Add(cpObject);
            }

            switch (juniperRule.Action)
            {
                case Juniper_PolicyRule.ActionType.Permit:
                    cpRule.Action = CheckPoint_Rule.ActionType.Accept;
                    break;
                case Juniper_PolicyRule.ActionType.Deny:
                    cpRule.Action = CheckPoint_Rule.ActionType.Drop;
                    break;
                case Juniper_PolicyRule.ActionType.Reject:
                    cpRule.Action = CheckPoint_Rule.ActionType.Reject;
                    break;
                default:
                    cpRule.Action = CheckPoint_Rule.ActionType.Drop;
                    break;
            }

            return cpRule;
        }

        private void Add_Static_NAT()
        {
            foreach (Juniper_StaticNatPolicy natPolicy in _juniperParser.Filter("_StaticNatPolicy"))
            {
                if (natPolicy.IsRoutingInstanceDefined)
                {
                    natPolicy.ConversionIncidentType = ConversionIncidentType.Informative;

                    _conversionIncidents.Add(new ConversionIncident(natPolicy.LineNumber,
                                                                    "Not converting static NAT policy object which specifies a routing instance as a source of the traffic",
                                                                    "All related static NAT rules are skipped.",
                                                                    natPolicy.ConversionIncidentType));

                    continue;
                }

                if (natPolicy.SourceZones.Count == 0 && natPolicy.SourceInterfaces.Count == 0)
                {
                    natPolicy.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                    _conversionIncidents.Add(new ConversionIncident(natPolicy.LineNumber,
                                                                    "Missing a source of the traffic for static NAT policy object",
                                                                    "All related static NAT rules are skipped.",
                                                                    natPolicy.ConversionIncidentType));

                    continue;
                }

                var rulePriority = (natPolicy.SourceInterfaces.Count != 0)
                                       ? JuniperNatCustomData.RulePriority.StaticInterface
                                       : JuniperNatCustomData.RulePriority.StaticZone;

                foreach (var natRule in natPolicy.Rules)
                {
                    if (natRule.NoMatchInfo || natRule.NoActionInfo)
                    {
                        natRule.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                        _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                        natRule.NoMatchInfo ? "Missing match information for static NAT rule object" : "Missing action information for static NAT rule object",
                                                                        "Conversion of static NAT rule is skipped.",
                                                                        natRule.ConversionIncidentType));

                        continue;
                    }

                    var cpNatRule = new CheckPoint_NAT_Rule();
                    cpNatRule.Method = CheckPoint_NAT_Rule.NatMethod.Static;
                    cpNatRule.Enabled = !natRule.Inactive && !natPolicy.Inactive;
                    cpNatRule.Comments = string.Format("Converted from static NAT rule (line {0})", natRule.LineNumber);
                    if (!string.IsNullOrEmpty(natRule.Description))
                    {
                        cpNatRule.Comments = string.Format("{0},  {1}", natRule.Description, cpNatRule.Comments);
                    }

                    cpNatRule.VendorCustomData = new JuniperNatCustomData();
                    ((JuniperNatCustomData)cpNatRule.VendorCustomData).Priority = rulePriority;
                    ((JuniperNatCustomData)cpNatRule.VendorCustomData).SourceZonesOrInterfaces.AddRange(
                        rulePriority == JuniperNatCustomData.RulePriority.StaticZone
                        ? natPolicy.SourceZones
                        : natPolicy.SourceInterfaces);

                    ApplyConversionIncidentOnCheckPointObject(cpNatRule, natRule);

                    // Source
                    cpNatRule.Source = GetNatSourceFromJuniperNatRule(natPolicy, natRule);

                    // Ignore source port and notify user.
                    if (natRule.SourcePorts.Count > 0)
                    {
                        natRule.ConversionIncidentType = ConversionIncidentType.Informative;

                        _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                        "NAT rule points to a source port",
                                                                        "Ignoring source port: " + natRule.SourcePorts[0] + ".",
                                                                        natRule.ConversionIncidentType));
                    }

                    // Destination
                    cpNatRule.Destination = GetNatDestinationFromJuniperNatRule(natPolicy, natRule);

                    // Services
                    // We should create a NAT rule duplicated per service!!!
                    var originalServices = new List<CheckPointObject>();
                    foreach (var destinationPort in natRule.DestinationPorts)
                    {
                        originalServices.AddRange(GetCheckPointServicesFromJuniperNatRulePort(destinationPort));
                    }

                    // Translated destination
                    CheckPointObject translatedDestination = null;

                    if (natRule.TranslatedDestination != null)
                    {
                        translatedDestination = GetCheckPointObjectFromJuniperNatAddress(natRule.TranslatedDestination);
                    }
                    else if (!string.IsNullOrEmpty(natRule.TranslatedDestinationName))
                    {
                        // Lookup for the name in a global address book.
                        translatedDestination = GetCheckPointObjectFromJuniperNatAddressName(natRule.TranslatedDestinationName, natRule);
                    }
                    else
                    {
                        translatedDestination = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                                                 "Host",
                                                                                 natRule,
                                                                                 "Error creating a NAT rule, missing information for Juniper prefix object",
                                                                                 "No prefix was specified.");
                    }

                    cpNatRule.TranslatedDestination = translatedDestination;

                    // Translated services
                    // We should create a NAT rule duplicated per translated service!!!
                    var translatedServices = new List<CheckPointObject>();
                    if (!string.IsNullOrEmpty(natRule.TranslatedPort))
                    {
                        translatedServices.AddRange(GetCheckPointServicesFromJuniperNatRulePort(natRule.TranslatedPort));
                    }

                    //////////////////////////////////////////////////////////////////////////////////////////////
                    // !!! IMPORTANT !!! each NAT rule should be duplicated per original and translated service!!!
                    int originalServicesCounter = 0, originalServicesCount = originalServices.Count;

                    do
                    {
                        int translatedServicesCounter = 0, translatedServicesCount = translatedServices.Count;

                        do
                        {
                            var cpNatRuleDup = cpNatRule.Clone();

                            if (originalServicesCount > 0)
                            {
                                cpNatRuleDup.Service = originalServices[originalServicesCounter];
                            }
                            if (translatedServicesCount > 0)
                            {
                                cpNatRuleDup.TranslatedService = translatedServices[translatedServicesCounter++];
                            }

                            if (cpNatRuleDup.Service != null && cpNatRuleDup.TranslatedService != null)
                            {
                                // Verify that service to translated service flow is for the same protocol - TCP->TCP or UDP->UDP.
                                // Recall that for a given port we've created both TCP and UDP services.
                                if (cpNatRuleDup.Service.Tag == "tcp" && cpNatRuleDup.TranslatedService.Tag != "tcp")
                                {
                                    continue;   // skip this NAT rule!!!
                                }
                                if (cpNatRuleDup.Service.Tag == "udp" && cpNatRuleDup.TranslatedService.Tag != "udp")
                                {
                                    continue;   // skip this NAT rule!!!
                                }
                            }

                            cpNatRuleDup.VendorCustomData = new JuniperNatCustomData();
                            ((JuniperNatCustomData)cpNatRuleDup.VendorCustomData).Priority = ((JuniperNatCustomData)cpNatRule.VendorCustomData).Priority;
                            ((JuniperNatCustomData)cpNatRuleDup.VendorCustomData).SourceZonesOrInterfaces.AddRange(((JuniperNatCustomData)cpNatRule.VendorCustomData).SourceZonesOrInterfaces);

                            // Add a new NAT rule to the collection.
                            _cpPreorderedNatRules.Add(cpNatRuleDup);

                            // Check for conversion incidents.
                            bool natRuleObjectHasConversionIncident = (cpNatRuleDup.Source != null && cpNatRuleDup.Source.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                      (cpNatRuleDup.TranslatedSource != null && cpNatRuleDup.TranslatedSource.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                      (cpNatRuleDup.Destination != null && cpNatRuleDup.Destination.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                      (cpNatRuleDup.TranslatedDestination != null && cpNatRuleDup.TranslatedDestination.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                      (cpNatRuleDup.Service != null && cpNatRuleDup.Service.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                      (cpNatRuleDup.TranslatedService != null && cpNatRuleDup.TranslatedService.ConversionIncidentType != ConversionIncidentType.None);

                            if (cpNatRuleDup.ConversionIncidentType != ConversionIncidentType.None ||
                                natRule.ConversionIncidentType != ConversionIncidentType.None ||
                                natRuleObjectHasConversionIncident)
                            {
                                _hasNATConversionIncident = true;
                            }

                            // Mirrored NAT rule
                            var cpNatMirrorRule = new CheckPoint_NAT_Rule();
                            cpNatMirrorRule.Method = CheckPoint_NAT_Rule.NatMethod.Static;
                            cpNatMirrorRule.Source = cpNatRuleDup.TranslatedDestination;
                            cpNatMirrorRule.Destination = cpNatRuleDup.Source;
                            cpNatMirrorRule.Service = cpNatRuleDup.TranslatedService ?? cpNatRuleDup.Service;
                            cpNatMirrorRule.TranslatedSource = cpNatRuleDup.Destination;
                            cpNatMirrorRule.TranslatedService = (cpNatRuleDup.TranslatedService != null) ? cpNatRuleDup.Service : cpNatRuleDup.TranslatedService;
                            cpNatMirrorRule.Comments = "Mirror rule for static NAT rule";

                            cpNatMirrorRule.VendorCustomData = new JuniperNatCustomData();
                            ((JuniperNatCustomData)cpNatMirrorRule.VendorCustomData).Priority = ((JuniperNatCustomData)cpNatRuleDup.VendorCustomData).Priority;
                            ((JuniperNatCustomData)cpNatMirrorRule.VendorCustomData).IsStaticMirrorRule = true;
                            ((JuniperNatCustomData)cpNatMirrorRule.VendorCustomData).SourceZonesOrInterfaces.AddRange(((JuniperNatCustomData)cpNatRuleDup.VendorCustomData).SourceZonesOrInterfaces);

                            // Add a new mirrored NAT rule to the collection.
                            _cpPreorderedNatRules.Add(cpNatMirrorRule);
                        } while (translatedServicesCounter < translatedServicesCount);

                        ++originalServicesCounter;
                    } while (originalServicesCounter < originalServicesCount);
                    // !!! IMPORTANT !!!
                    //////////////////////////////////////////////////////////////////////////////////////////////
                }
            }
        }

        private void Add_Destination_NAT()
        {
            var natPool = _juniperParser.Filter("_DestinationNatPool");

            foreach (Juniper_DestinationNatPolicy natPolicy in _juniperParser.Filter("_DestinationNatPolicy"))
            {
                if (natPolicy.IsRoutingInstanceDefined)
                {
                    natPolicy.ConversionIncidentType = ConversionIncidentType.Informative;

                    _conversionIncidents.Add(new ConversionIncident(natPolicy.LineNumber,
                                                                    "Not converting destination NAT policy object which specifies a routing instance as a source of the traffic",
                                                                    "All related destination NAT rules are skipped.",
                                                                    natPolicy.ConversionIncidentType));

                    continue;
                }

                if (natPolicy.SourceZones.Count == 0 && natPolicy.SourceInterfaces.Count == 0)
                {
                    natPolicy.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                    _conversionIncidents.Add(new ConversionIncident(natPolicy.LineNumber,
                                                                    "Missing a source of the traffic for destination NAT policy object",
                                                                    "All related destination NAT rules are skipped.",
                                                                    natPolicy.ConversionIncidentType));

                    continue;
                }

                var rulePriority = (natPolicy.SourceInterfaces.Count != 0)
                                       ? JuniperNatCustomData.RulePriority.DestinationInterface
                                       : JuniperNatCustomData.RulePriority.DestinationZone;

                foreach (var natRule in natPolicy.Rules)
                {
                    if (natRule.NoMatchInfo || natRule.NoActionInfo)
                    {
                        natRule.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                        _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                        natRule.NoMatchInfo ? "Missing match information for destination NAT rule object" : "Missing action information for destination NAT rule object",
                                                                        "Conversion of destination NAT rule is skipped.",
                                                                        natRule.ConversionIncidentType));

                        continue;
                    }

                    var cpNatRule = new CheckPoint_NAT_Rule();
                    cpNatRule.Method = CheckPoint_NAT_Rule.NatMethod.Static;
                    cpNatRule.Enabled = !natRule.Inactive && !natPolicy.Inactive;
                    cpNatRule.Comments = cpNatRule.Comments = string.Format("Converted from destination NAT rule (line {0})", natRule.LineNumber);
                    if (!string.IsNullOrEmpty(natRule.Description))
                    {
                        cpNatRule.Comments = string.Format("{0},  {1}", natRule.Description, cpNatRule.Comments);
                    }

                    cpNatRule.VendorCustomData = new JuniperNatCustomData();
                    ((JuniperNatCustomData)cpNatRule.VendorCustomData).Priority = rulePriority;
                    ((JuniperNatCustomData)cpNatRule.VendorCustomData).SourceZonesOrInterfaces.AddRange(
                        rulePriority == JuniperNatCustomData.RulePriority.DestinationZone
                        ? natPolicy.SourceZones
                        : natPolicy.SourceInterfaces);

                    ApplyConversionIncidentOnCheckPointObject(cpNatRule, natRule);

                    // Source
                    cpNatRule.Source = GetNatSourceFromJuniperNatRule(natPolicy, natRule);

                    // Ignore source port and notify user.
                    if (natRule.SourcePorts.Count > 0)
                    {
                        natRule.ConversionIncidentType = ConversionIncidentType.Informative;

                        _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                        "NAT rule points to a source port",
                                                                        "Ignoring source port: " + natRule.SourcePorts[0] + ".",
                                                                        natRule.ConversionIncidentType));
                    }

                    // Destination
                    cpNatRule.Destination = GetNatDestinationFromJuniperNatRule(natPolicy, natRule);

                    // Services
                    // We should create a NAT rule duplicated per service!!!
                    var originalServices = new List<CheckPointObject>();
                    if (natRule.DestinationPorts.Count > 0 || natRule.Protocols.Count > 0 || natRule.Applications.Count > 0)
                    {
                        if (natRule.Protocols.Count > 0)
                        {
                            originalServices.AddRange(GetCheckPointServicesFromJuniperNatRule(natRule.Protocols, natRule.DestinationPorts));
                        }
                        else
                        {
                            foreach (var destinationPort in natRule.DestinationPorts)
                            {
                                originalServices.AddRange(GetCheckPointServicesFromJuniperNatRulePort(destinationPort));
                            }
                        }

                        foreach (var application in natRule.Applications)
                        {
                            var cpServive = GetCheckPointServiceFromJuniperNatRuleApplication(application);
                            if (cpServive == null)
                            {
                                cpServive = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                                             "ServiceGroup",
                                                                             natRule,
                                                                             "Error creating a NAT rule, missing information for Juniper NAT application",
                                                                             "Application details: " + application + ".");
                            }

                            originalServices.Add(cpServive);
                        }
                    }

                    string destinationPoolPort = "";

                    // Translated destination
                    if (natRule.TranslateDestination)
                    {
                        CheckPointObject translatedDestination = null;

                        if (!string.IsNullOrEmpty(natRule.TranslatedDestination))
                        {
                            foreach (Juniper_DestinationNatPool pool in natPool)
                            {
                                if (pool.Name == natRule.TranslatedDestination)
                                {
                                    if (pool.Address != null)
                                    {
                                        translatedDestination = GetCheckPointObjectFromJuniperNatPoolAddress(pool.Address);
                                        if (translatedDestination != null)
                                        {
                                            translatedDestination.Name = pool.Name;
                                            CheckObjectNameValidity(translatedDestination, pool, false, true);
                                            AddCheckPointObject(translatedDestination);
                                        }
                                    }

                                    if (!string.IsNullOrEmpty(pool.Port))
                                    {
                                        destinationPoolPort = pool.Port;
                                    }

                                    break;
                                }
                            }
                        }

                        if (translatedDestination == null)
                        {
                            translatedDestination = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                                                     "Host",
                                                                                     natRule,
                                                                                     "Error creating a NAT rule, missing information for Juniper NAT pool object",
                                                                                     "Pool details: " + natRule.TranslatedDestination + ".");
                        }

                        cpNatRule.TranslatedDestination = translatedDestination;
                    }

                    // Translated services
                    // We should create a NAT rule duplicated per translated service!!!
                    var translatedServices = new List<CheckPointObject>();
                    if (!string.IsNullOrEmpty(destinationPoolPort))
                    {
                        translatedServices.AddRange(GetCheckPointServicesFromJuniperNatRulePort(destinationPoolPort));
                    }

                    //////////////////////////////////////////////////////////////////////////////////////////////
                    // !!! IMPORTANT !!! each NAT rule should be duplicated per original and translated service!!!
                    int originalServicesCounter = 0, originalServicesCount = originalServices.Count;

                    do
                    {
                        int translatedServicesCounter = 0, translatedServicesCount = translatedServices.Count;

                        do
                        {
                            var cpNatRuleDup = cpNatRule.Clone();

                            if (originalServicesCount > 0)
                            {
                                cpNatRuleDup.Service = originalServices[originalServicesCounter];
                            }
                            if (translatedServicesCount > 0)
                            {
                                cpNatRuleDup.TranslatedService = translatedServices[translatedServicesCounter++];
                            }

                            if (cpNatRuleDup.Service != null && cpNatRuleDup.TranslatedService != null)
                            {
                                // Verify that service to translated service flow is for the same protocol - TCP->TCP or UDP->UDP.
                                // Recall that for a given port we've created both TCP and UDP services.
                                if (cpNatRuleDup.Service.Tag == "tcp" && cpNatRuleDup.TranslatedService.Tag != "tcp")
                                {
                                    continue;   // skip this NAT rule!!!
                                }
                                if (cpNatRuleDup.Service.Tag == "udp" && cpNatRuleDup.TranslatedService.Tag != "udp")
                                {
                                    continue;   // skip this NAT rule!!!
                                }
                            }

                            cpNatRuleDup.VendorCustomData = new JuniperNatCustomData();
                            ((JuniperNatCustomData)cpNatRuleDup.VendorCustomData).Priority = ((JuniperNatCustomData)cpNatRule.VendorCustomData).Priority;
                            ((JuniperNatCustomData)cpNatRuleDup.VendorCustomData).SourceZonesOrInterfaces.AddRange(((JuniperNatCustomData)cpNatRule.VendorCustomData).SourceZonesOrInterfaces);

                            // Add a new NAT rule to the collection.
                            _cpPreorderedNatRules.Add(cpNatRuleDup);

                            // Check for conversion incidents.
                            bool natRuleObjectHasConversionIncident = (cpNatRuleDup.Source != null && cpNatRuleDup.Source.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                      (cpNatRuleDup.TranslatedSource != null && cpNatRuleDup.TranslatedSource.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                      (cpNatRuleDup.Destination != null && cpNatRuleDup.Destination.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                      (cpNatRuleDup.TranslatedDestination != null && cpNatRuleDup.TranslatedDestination.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                      (cpNatRuleDup.Service != null && cpNatRuleDup.Service.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                      (cpNatRuleDup.TranslatedService != null && cpNatRuleDup.TranslatedService.ConversionIncidentType != ConversionIncidentType.None);

                            if (cpNatRuleDup.ConversionIncidentType != ConversionIncidentType.None ||
                                natRule.ConversionIncidentType != ConversionIncidentType.None ||
                                natRuleObjectHasConversionIncident)
                            {
                                _hasNATConversionIncident = true;
                            }
                        } while (translatedServicesCounter < translatedServicesCount);

                        ++originalServicesCounter;
                    } while (originalServicesCounter < originalServicesCount);
                    // !!! IMPORTANT !!!
                    //////////////////////////////////////////////////////////////////////////////////////////////
                }
            }
        }

        private void Add_Source_NAT()
        {
            var natPool = _juniperParser.Filter("_SourceNatPool");

            foreach (Juniper_SourceNatPolicy natPolicy in _juniperParser.Filter("_SourceNatPolicy"))
            {
                if (natPolicy.IsRoutingInstanceDefined)
                {
                    natPolicy.ConversionIncidentType = ConversionIncidentType.Informative;

                    _conversionIncidents.Add(new ConversionIncident(natPolicy.LineNumber,
                                                                    "Not converting source NAT policy object which specifies a routing instance as a source of the traffic",
                                                                    "All related source NAT rules are skipped.",
                                                                    natPolicy.ConversionIncidentType));

                    continue;
                }

                if (natPolicy.SourceZones.Count == 0 && natPolicy.SourceInterfaces.Count == 0)
                {
                    natPolicy.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                    _conversionIncidents.Add(new ConversionIncident(natPolicy.LineNumber,
                                                                    "Missing a source of the traffic for source NAT policy object",
                                                                    "All related source NAT rules are skipped.",
                                                                    natPolicy.ConversionIncidentType));

                    continue;
                }

                if (natPolicy.DestinationZones.Count == 0 && natPolicy.DestinationInterfaces.Count == 0)
                {
                    natPolicy.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                    _conversionIncidents.Add(new ConversionIncident(natPolicy.LineNumber,
                                                                    "Missing a destination of the traffic for source NAT policy object",
                                                                    "All related source NAT rules are skipped.",
                                                                    natPolicy.ConversionIncidentType));

                    continue;
                }

                JuniperNatCustomData.RulePriority rulePriority;

                if (natPolicy.SourceInterfaces.Count != 0 && natPolicy.DestinationInterfaces.Count != 0)
                {
                    rulePriority = JuniperNatCustomData.RulePriority.SourceInterface2Interface;
                }
                else if (natPolicy.SourceZones.Count != 0 && natPolicy.DestinationZones.Count != 0)
                {
                    rulePriority = JuniperNatCustomData.RulePriority.SourceZone2Zone;
                }
                else
                {
                    rulePriority = JuniperNatCustomData.RulePriority.SourceMixed;
                }

                foreach (var natRule in natPolicy.Rules)
                {
                    if (natRule.NoMatchInfo || natRule.NoActionInfo)
                    {
                        natRule.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                        _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                        natRule.NoMatchInfo ? "Missing match information for source NAT rule object" : "Missing action information for source NAT rule object",
                                                                        "Conversion of source NAT rule is skipped.",
                                                                        natRule.ConversionIncidentType));

                        continue;
                    }

                    var cpNatRule = new CheckPoint_NAT_Rule();
                    cpNatRule.Method = CheckPoint_NAT_Rule.NatMethod.Hide;
                    cpNatRule.Enabled = !natRule.Inactive && !natPolicy.Inactive;
                    cpNatRule.Comments = cpNatRule.Comments = string.Format("Converted from source NAT rule (line {0})", natRule.LineNumber);
                    if (!string.IsNullOrEmpty(natRule.Description))
                    {
                        cpNatRule.Comments = string.Format("{0},  {1}", natRule.Description, cpNatRule.Comments);
                    }

                    cpNatRule.VendorCustomData = new JuniperNatCustomData();
                    ((JuniperNatCustomData)cpNatRule.VendorCustomData).Priority = rulePriority;

                    ApplyConversionIncidentOnCheckPointObject(cpNatRule, natRule);

                    // Source
                    cpNatRule.Source = GetNatSourceFromJuniperNatRule(natPolicy, natRule);

                    // Ignore source port and notify user.
                    if (natRule.SourcePorts.Count > 0)
                    {
                        natRule.ConversionIncidentType = ConversionIncidentType.Informative;

                        _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                        "NAT rule points to a source port",
                                                                        "Ignoring source port: " + natRule.SourcePorts[0] + ".",
                                                                        natRule.ConversionIncidentType));
                    }

                    // Destination
                    cpNatRule.Destination = GetNatDestinationFromJuniperNatRule(natPolicy, natRule);

                    // Services
                    // We should create a NAT rule duplicated per service!!!
                    var originalServices = new List<CheckPointObject>();
                    if (natRule.DestinationPorts.Count > 0 || natRule.Protocols.Count > 0 || natRule.Applications.Count > 0)
                    {
                        if (natRule.Protocols.Count > 0)
                        {
                            originalServices.AddRange(GetCheckPointServicesFromJuniperNatRule(natRule.Protocols, natRule.DestinationPorts));
                        }
                        else
                        {
                            foreach (var destinationPort in natRule.DestinationPorts)
                            {
                                originalServices.AddRange(GetCheckPointServicesFromJuniperNatRulePort(destinationPort));
                            }
                        }

                        foreach (var application in natRule.Applications)
                        {
                            var cpServive = GetCheckPointServiceFromJuniperNatRuleApplication(application);
                            if (cpServive == null)
                            {
                                cpServive = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                                             "ServiceGroup",
                                                                             natRule,
                                                                             "Error creating a NAT rule, missing information for Juniper NAT application",
                                                                             "Application details: " + application + ".");
                            }

                            originalServices.Add(cpServive);
                        }
                    }

                    // Translated source
                    switch (natRule.TranslationMode)
                    {
                        case Juniper_SourceNatRule.SourceTranslationMode.Pool:
                            cpNatRule.TranslatedSource = GetNatTranslatedSourceFromJuniperSourceNatPool(natPool, natRule, cpNatRule);
                            break;

                        case Juniper_SourceNatRule.SourceTranslationMode.Interface:
                            cpNatRule.TranslatedSource = GetNatTranslatedSourceFromJuniperSourceNatInterface(natPolicy, natRule, cpNatRule);
                            break;
                    }

                    ///////////////////////////////////////////////////////////////////////////////
                    // !!! IMPORTANT !!! each NAT rule should be duplicated per original service!!!
                    int originalServicesCounter = 0, originalServicesCount = originalServices.Count;

                    do
                    {
                        var cpNatRuleDup = cpNatRule.Clone();

                        cpNatRuleDup.VendorCustomData = new JuniperNatCustomData();
                        ((JuniperNatCustomData)cpNatRuleDup.VendorCustomData).Priority = ((JuniperNatCustomData)cpNatRule.VendorCustomData).Priority;

                        if (originalServicesCount > 0)
                        {
                            cpNatRuleDup.Service = originalServices[originalServicesCounter];
                        }

                        // Add a new NAT rule to the collection.
                        _cpPreorderedNatRules.Add(cpNatRuleDup);

                        // Check for conversion incidents.
                        bool natRuleObjectHasConversionIncident = (cpNatRuleDup.Source != null && cpNatRuleDup.Source.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                  (cpNatRuleDup.TranslatedSource != null && cpNatRuleDup.TranslatedSource.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                  (cpNatRuleDup.Destination != null && cpNatRuleDup.Destination.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                  (cpNatRuleDup.TranslatedDestination != null && cpNatRuleDup.TranslatedDestination.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                  (cpNatRuleDup.Service != null && cpNatRuleDup.Service.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                  (cpNatRuleDup.TranslatedService != null && cpNatRuleDup.TranslatedService.ConversionIncidentType != ConversionIncidentType.None);

                        if (cpNatRuleDup.ConversionIncidentType != ConversionIncidentType.None ||
                            natRule.ConversionIncidentType != ConversionIncidentType.None ||
                            natRuleObjectHasConversionIncident)
                        {
                            _hasNATConversionIncident = true;
                        }

                        ++originalServicesCounter;
                    } while (originalServicesCounter < originalServicesCount);
                    // !!! IMPORTANT !!!
                    ///////////////////////////////////////////////////////////////////////////////
                }
            }
        }

        private CheckPointObject GetJuniperManagementHost()
        {
            foreach (Juniper_Interface ifc in JuniperInterfaces)
            {
                if (ifc.Name.StartsWith(JuniperObject.AccessManagementInterfaceName))
                {
                    return _cpObjects.GetObject(ifc.Name + "_address");
                }
            }

            return null;
        }

        private CheckPointObject GetNatSourceFromJuniperNatRule(Juniper_NatPolicy natPolicy, Juniper_NatRule natRule)
        {
            CheckPointObject natSource = null;

            if (natRule.SourceAddressNames.Count > 0 || natRule.SourceAddresses.Count > 0)
            {
                if (natRule.SourceAddressNames.Count + natRule.SourceAddresses.Count > 1)
                {
                    // Create a network group object to hold the source subnets list.
                    var cpNetworkGroup = new CheckPoint_NetworkGroup();
                    cpNetworkGroup.Name = NetworkObjectNameGenerator.AutoGeneratedNetworkGroupName();

                    foreach (var sourceAddressName in natRule.SourceAddressNames)
                    {
                        var cpObject = GetCheckPointObjectFromJuniperNatAddressName(sourceAddressName, natRule);
                        cpNetworkGroup.Members.Add(cpObject.Name);

                        if (cpObject.Name.Contains(AutoGeneratedNameWithError))
                        {
                            cpNetworkGroup.ConvertedCommandId = natRule.LineNumber;
                            cpNetworkGroup.ConversionIncidentType = cpObject.ConversionIncidentType;

                            _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                            "Error creating a NAT rule, network group object used as an original source has a member object with an error due to source address name.",
                                                                            "Network group object details: " + cpNetworkGroup.Name + ", Source address name: " + sourceAddressName + ".",
                                                                            cpNetworkGroup.ConversionIncidentType));
                        }
                    }

                    foreach (var sourceAddress in natRule.SourceAddresses)
                    {
                        var cpObject = GetCheckPointObjectFromJuniperNatAddress(sourceAddress);
                        cpNetworkGroup.Members.Add(cpObject.Name);
                    }

                    AddCheckPointObject(cpNetworkGroup);
                    natSource = cpNetworkGroup;
                }
                else if (natRule.SourceAddressNames.Count > 0)
                {
                    // Lookup for the name in a global address book.
                    natSource = GetCheckPointObjectFromJuniperNatAddressName(natRule.SourceAddressNames[0], natRule);
                }
                else   // SourceAddress
                {
                    // Create a host/network object as a source object for NAT rule.
                    natSource = GetCheckPointObjectFromJuniperNatAddress(natRule.SourceAddresses[0]);
                }
            }
            else   // no source addresses...
            {
                // Use a network group associated with a source zone/interface.
                if (natPolicy.SourceZones.Count > 0)
                {
                    bool sourceZoneLeadsToInternet = false;

                    // Create a network group object to wrap the network groups associated with source zones.
                    var cpNetworkGroup = new CheckPoint_NetworkGroup();
                    cpNetworkGroup.Name = NetworkObjectNameGenerator.AutoGeneratedNetworkGroupName();
                    cpNetworkGroup.CreateAfterGroupsWithExclusion = true;

                    foreach (var zoneName in natPolicy.SourceZones)
                    {
                        foreach (Juniper_Zone zone in JuniperZones)
                        {
                            if (zoneName == zone.Name)
                            {
                                if (zone.LeadsToInternet)
                                {
                                    sourceZoneLeadsToInternet = true;
                                }
                                else
                                {
                                    string zoneGroupName = "zone_" + zoneName + "_subnets";
                                    var cpObject = GetCheckPointObjectOrCreateDummy(zoneGroupName,
                                                                                    "NetworkGroup",
                                                                                    natRule,
                                                                                    "Error creating a NAT rule, missing interfaces information for Juniper source zone",
                                                                                    "Source zone details: " + zoneName + ".");
                                    cpNetworkGroup.Members.Add(cpObject.Name);

                                    if (cpObject.Name.Contains(AutoGeneratedNameWithError))
                                    {
                                        cpNetworkGroup.ConvertedCommandId = natRule.LineNumber;
                                        cpNetworkGroup.ConversionIncidentType = cpObject.ConversionIncidentType;

                                        _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                                        "Error creating a NAT rule, network group object used as an original source has a member object with an error due to source zone.",
                                                                                        "Network group object details: " + cpNetworkGroup.Name + ", Source zone name: " + zoneName + ".",
                                                                                        cpNetworkGroup.ConversionIncidentType));
                                    }
                                }

                                break;
                            }
                        }

                        if (sourceZoneLeadsToInternet)
                        {
                            break;
                        }
                    }

                    if (sourceZoneLeadsToInternet)
                    {
                        natSource = _cpObjects.GetObject(CheckPointObject.Any);
                    }
                    else
                    {
                        if (cpNetworkGroup.Members.Count > 1)
                        {
                            AddCheckPointObject(cpNetworkGroup);
                            natSource = cpNetworkGroup;
                        }
                        else
                        {
                            // No need to create a wrapper network group for a single source zone...
                            // Just use the network group associated with a source zone directly.
                            natSource = GetCheckPointObjectOrCreateDummy("zone_" + natPolicy.SourceZones[0] + "_subnets",
                                                                         "NetworkGroup",
                                                                         natPolicy,
                                                                         "Error creating a NAT rule, missing interfaces information for Juniper source zone",
                                                                         "Source zone details: " + natPolicy.SourceZones[0] + ".");
                        }
                    }
                }
                else   // SourceInterfaces
                {
                    bool sourceInterfaceLeadsToInternet = false;

                    // Create a network group object to wrap the network groups associated with source interfaces.
                    var cpNetworkGroup = new CheckPoint_NetworkGroup();
                    cpNetworkGroup.Name = NetworkObjectNameGenerator.AutoGeneratedNetworkGroupName();

                    foreach (var ifcName in natPolicy.SourceInterfaces)
                    {
                        foreach (Juniper_Interface ifc in JuniperInterfaces)
                        {
                            if (ifcName == ifc.Name)
                            {
                                if (ifc.LeadsToInternet)
                                {
                                    sourceInterfaceLeadsToInternet = true;
                                }
                                else
                                {
                                    string interfaceGroupName = ifcName + "_subnets";
                                    var cpObject = GetCheckPointObjectOrCreateDummy(interfaceGroupName,
                                                                                    "NetworkGroup",
                                                                                    natRule,
                                                                                    "Error creating a NAT rule, missing topology information for Juniper source interface",
                                                                                    "Source interface details: " + ifcName + ".");
                                    cpNetworkGroup.Members.Add(cpObject.Name);

                                    if (cpObject.Name.Contains(AutoGeneratedNameWithError))
                                    {
                                        cpNetworkGroup.ConvertedCommandId = natRule.LineNumber;
                                        cpNetworkGroup.ConversionIncidentType = cpObject.ConversionIncidentType;

                                        _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                                        "Error creating a NAT rule, network group object used as an original source has a member object with an error due to source interface.",
                                                                                        "Network group object details: " + cpNetworkGroup.Name + ", Source interface name: " + ifcName + ".",
                                                                                        cpNetworkGroup.ConversionIncidentType));
                                    }
                                }

                                break;
                            }
                        }

                        if (sourceInterfaceLeadsToInternet)
                        {
                            break;
                        }
                    }

                    if (sourceInterfaceLeadsToInternet)
                    {
                        natSource = _cpObjects.GetObject(CheckPointObject.Any);
                    }
                    else
                    {
                        if (cpNetworkGroup.Members.Count > 1)
                        {
                            AddCheckPointObject(cpNetworkGroup);
                            natSource = cpNetworkGroup;
                        }
                        else
                        {
                            // No need to create a wrapper network group for a single source interface...
                            // Just use the network group associated with a source interface directly.
                            natSource = GetCheckPointObjectOrCreateDummy(natPolicy.SourceInterfaces[0] + "_subnets",
                                                                         "NetworkGroup",
                                                                         natRule,
                                                                         "Error creating a NAT rule, missing topology information for Juniper source interface",
                                                                         "Source interface details: " + natPolicy.SourceInterfaces[0] + ".");
                        }
                    }
                }
            }

            return natSource;
        }

        private CheckPointObject GetNatDestinationFromJuniperNatRule(Juniper_NatPolicy natPolicy, Juniper_NatRule natRule)
        {
            CheckPointObject natDestination = null;

            if (natRule.DestinationAddressNames.Count > 0 || natRule.DestinationAddresses.Count > 0)
            {
                if (natRule.DestinationAddressNames.Count + natRule.DestinationAddresses.Count > 1)
                {
                    // Create a network group object to hold the destination subnets list.
                    var cpNetworkGroup = new CheckPoint_NetworkGroup();
                    cpNetworkGroup.Name = NetworkObjectNameGenerator.AutoGeneratedNetworkGroupName();

                    foreach (var destinationAddressName in natRule.DestinationAddressNames)
                    {
                        var cpObject = GetCheckPointObjectFromJuniperNatAddressName(destinationAddressName, natRule);
                        cpNetworkGroup.Members.Add(cpObject.Name);

                        if (cpObject.Name.Contains(AutoGeneratedNameWithError))
                        {
                            cpNetworkGroup.ConvertedCommandId = natRule.LineNumber;
                            cpNetworkGroup.ConversionIncidentType = cpObject.ConversionIncidentType;

                            _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                            "Error creating a NAT rule, network group object used as an original destination has a member object with an error due to destination address name.",
                                                                            "Network group object details: " + cpNetworkGroup.Name + ", Destination address name: " + destinationAddressName + ".",
                                                                            cpNetworkGroup.ConversionIncidentType));
                        }
                    }

                    foreach (var destinationAddress in natRule.DestinationAddresses)
                    {
                        var cpObject = GetCheckPointObjectFromJuniperNatAddress(destinationAddress);
                        cpNetworkGroup.Members.Add(cpObject.Name);
                    }

                    AddCheckPointObject(cpNetworkGroup);
                    natDestination = cpNetworkGroup;
                }
                else if (natRule.DestinationAddressNames.Count > 0)
                {
                    // Lookup for the name in a global address book.
                    natDestination = GetCheckPointObjectFromJuniperNatAddressName(natRule.DestinationAddressNames[0], natRule);
                }
                else   // DestinationAddress
                {
                    // Create a host/network object as a destination object for NAT rule.
                    natDestination = GetCheckPointObjectFromJuniperNatAddress(natRule.DestinationAddresses[0]);
                }
            }
            else   // no destination addresses...
            {
                if (natPolicy is Juniper_SourceNatPolicy)
                {
                    var sourceNatPolicy = natPolicy as Juniper_SourceNatPolicy;

                    // Use a network group associated with a destination zone/interface.
                    if (sourceNatPolicy.DestinationZones.Count > 0)
                    {
                        bool destinationZoneLeadsToInternet = false;

                        // Create a network group object to hold the network groups associated with a destination zone.
                        var cpNetworkGroup = new CheckPoint_NetworkGroup();
                        cpNetworkGroup.Name = NetworkObjectNameGenerator.AutoGeneratedNetworkGroupName();
                        cpNetworkGroup.CreateAfterGroupsWithExclusion = true;

                        foreach (var zoneName in sourceNatPolicy.DestinationZones)
                        {
                            foreach (Juniper_Zone zone in JuniperZones)
                            {
                                if (zoneName == zone.Name)
                                {
                                    if (zone.LeadsToInternet)
                                    {
                                        destinationZoneLeadsToInternet = true;
                                    }
                                    else
                                    {
                                        string zoneGroupName = "zone_" + zoneName + "_subnets";
                                        var cpObject = GetCheckPointObjectOrCreateDummy(zoneGroupName,
                                                                                        "NetworkGroup",
                                                                                        natRule,
                                                                                        "Error creating a NAT rule, missing interfaces information for Juniper destination zone",
                                                                                        "Destination zone details: " + zoneName + ".");
                                        cpNetworkGroup.Members.Add(cpObject.Name);

                                        if (cpObject.Name.Contains(AutoGeneratedNameWithError))
                                        {
                                            cpNetworkGroup.ConvertedCommandId = natRule.LineNumber;
                                            cpNetworkGroup.ConversionIncidentType = cpObject.ConversionIncidentType;

                                            _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                                            "Error creating a NAT rule, network group object used as an original destination has a member object with an error due to destination zone.",
                                                                                            "Network group object details: " + cpNetworkGroup.Name + ", Destination zone name: " + zoneName + ".",
                                                                                            cpNetworkGroup.ConversionIncidentType));
                                        }
                                    }

                                    break;
                                }
                            }

                            if (destinationZoneLeadsToInternet)
                            {
                                break;
                            }
                        }

                        if (destinationZoneLeadsToInternet)
                        {
                            natDestination = _cpObjects.GetObject(CheckPointObject.Any);
                        }
                        else
                        {
                            if (cpNetworkGroup.Members.Count > 1)
                            {
                                AddCheckPointObject(cpNetworkGroup);
                                natDestination = cpNetworkGroup;
                            }
                            else
                            {
                                // No need to create a wrapper network group for a single destination zone...
                                // Just use the network group associated with a destination zone directly.
                                natDestination = GetCheckPointObjectOrCreateDummy("zone_" + sourceNatPolicy.DestinationZones[0] + "_subnets",
                                                                                  "NetworkGroup",
                                                                                  natRule,
                                                                                  "Error creating a NAT rule, missing interfaces information for Juniper destination zone",
                                                                                  "Destination zone details: " + sourceNatPolicy.DestinationZones[0] + ".");
                            }
                        }
                    }
                    else   // DestinationInterfaces
                    {
                        bool destinationInterfaceLeadsToInternet = false;

                        // Create a network group object to wrap the network groups associated with a destination interfaces.
                        var cpNetworkGroup = new CheckPoint_NetworkGroup();
                        cpNetworkGroup.Name = NetworkObjectNameGenerator.AutoGeneratedNetworkGroupName();

                        foreach (var ifcName in sourceNatPolicy.DestinationInterfaces)
                        {
                            foreach (Juniper_Interface ifc in JuniperInterfaces)
                            {
                                if (ifcName == ifc.Name)
                                {
                                    if (ifc.LeadsToInternet)
                                    {
                                        destinationInterfaceLeadsToInternet = true;
                                    }
                                    else
                                    {
                                        string interfaceGroupName = ifcName + "_subnets";
                                        var cpObject = GetCheckPointObjectOrCreateDummy(interfaceGroupName,
                                                                                        "NetworkGroup",
                                                                                        natRule,
                                                                                        "Error creating a NAT rule, missing topology information for Juniper destination interface",
                                                                                        "Destination interface details: " + ifcName + ".");
                                        cpNetworkGroup.Members.Add(cpObject.Name);

                                        if (cpObject.Name.Contains(AutoGeneratedNameWithError))
                                        {
                                            cpNetworkGroup.ConvertedCommandId = natRule.LineNumber;
                                            cpNetworkGroup.ConversionIncidentType = cpObject.ConversionIncidentType;

                                            _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                                            "Error creating a NAT rule, network group object used as an original destination has a member object with an error due to destination interface.",
                                                                                            "Network group object details: " + cpNetworkGroup.Name + ", Destination interface name: " + ifcName + ".",
                                                                                            cpNetworkGroup.ConversionIncidentType));
                                        }
                                    }

                                    break;
                                }
                            }

                            if (destinationInterfaceLeadsToInternet)
                            {
                                break;
                            }
                        }

                        if (destinationInterfaceLeadsToInternet)
                        {
                            natDestination = _cpObjects.GetObject(CheckPointObject.Any);
                        }
                        else
                        {
                            if (cpNetworkGroup.Members.Count > 1)
                            {
                                AddCheckPointObject(cpNetworkGroup);
                                natDestination = cpNetworkGroup;
                            }
                            else
                            {
                                // No need to create a wrapper network group for a single destination interface...
                                // Just use the network group associated with a destination interface directly.
                                natDestination = GetCheckPointObjectOrCreateDummy(sourceNatPolicy.DestinationInterfaces[0] + "_subnets",
                                                                                  "NetworkGroup",
                                                                                  natRule,
                                                                                  "Error creating a NAT rule, missing topology information for Juniper destination interface",
                                                                                  "Destination interface details: " + sourceNatPolicy.DestinationInterfaces[0] + ".");
                            }
                        }
                    }
                }
                else
                {
                    natRule.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                    _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                    "Error creating a NAT rule, missing information for Juniper destination address",
                                                                    "No destination address was specified.",
                                                                    natRule.ConversionIncidentType));
                }
            }

            return natDestination;
        }

        private CheckPointObject GetNatTranslatedSourceFromJuniperSourceNatPool(IEnumerable<JuniperObject> natPool, Juniper_SourceNatRule natRule, CheckPoint_NAT_Rule cpNatRule)
        {
            if (string.IsNullOrEmpty(natRule.TranslatedSource))
            {
                return GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                        "Host",
                                                        natRule,
                                                        "Error creating a NAT rule, missing information for Juniper NAT pool object",
                                                        "No pool object was specified.");
            }

            CheckPointObject translatedSource = null;

            foreach (Juniper_SourceNatPool pool in natPool)
            {
                if (pool.Name == natRule.TranslatedSource)
                {
                    if (pool.Addresses.Count > 0)
                    {
                        translatedSource = GetCheckPointObjectFromJuniperNatPoolAddress(pool.Addresses[0]);
                        if (translatedSource != null)
                        {
                            translatedSource.Name = pool.Name;
                            CheckObjectNameValidity(translatedSource, pool, false, true);
                            AddCheckPointObject(translatedSource);

                            if (!string.IsNullOrEmpty(pool.HostAddressBase))
                            {
                                // We need to create a new original source object with the same network size
                                // as the translated source object!!!
                                // In addition, the converted NAT rule should be static.
                                CheckPointObject originalSource = null;

                                switch (pool.Addresses[0].AddressType)
                                {
                                    case Juniper_NatPool.PoolAddress.NetworkType.Host:
                                        originalSource = new CheckPoint_Host();
                                        ((CheckPoint_Host)originalSource).IpAddress = pool.HostAddressBase;
                                        originalSource.Name = "host_" + ((CheckPoint_Host)originalSource).IpAddress;
                                        break;

                                    case Juniper_NatPool.PoolAddress.NetworkType.Subnet:
                                        originalSource = new CheckPoint_Range();
                                        ((CheckPoint_Range)originalSource).RangeFrom = pool.HostAddressBase;
                                        ((CheckPoint_Range)originalSource).RangeTo = IPNetwork.Parse(pool.HostAddressBase, pool.Addresses[0].Netmask).Broadcast.ToString();
                                        originalSource.Name = "r_" + ((CheckPoint_Range)originalSource).RangeFrom + "-" + ((CheckPoint_Range)originalSource).RangeTo;
                                        break;

                                    case Juniper_NatPool.PoolAddress.NetworkType.Range:
                                        originalSource = new CheckPoint_Range();
                                        ((CheckPoint_Range)originalSource).RangeFrom = pool.HostAddressBase;
                                        ((CheckPoint_Range)originalSource).RangeTo = IPNetwork.Parse(pool.HostAddressBase, NetworkUtils.NetworkRange2Netmask(pool.Addresses[0].IpAddress, pool.Addresses[0].RangeTo)).Broadcast.ToString();
                                        originalSource.Name = "r_" + ((CheckPoint_Range)originalSource).RangeFrom + "-" + ((CheckPoint_Range)originalSource).RangeTo;
                                        break;
                                }

                                AddCheckPointObject(originalSource);

                                cpNatRule.Source = originalSource;
                                cpNatRule.Method = CheckPoint_NAT_Rule.NatMethod.Static;
                            }
                        }

                        if (pool.Addresses.Count > 1)
                        {
                            natRule.ConversionIncidentType = ConversionIncidentType.Informative;

                            _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                            "Source NAT rule points to a pool with multiple addresses",
                                                                            "Using first address for translated source.",
                                                                            natRule.ConversionIncidentType));
                        }
                    }

                    if (!pool.TranslatePort)
                    {
                        cpNatRule.Method = CheckPoint_NAT_Rule.NatMethod.Static;
                    }

                    break;
                }
            }

            if (translatedSource == null)
            {
                translatedSource = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                                    "Host",
                                                                    natRule,
                                                                    "Error creating a NAT rule, missing information for Juniper NAT pool object",
                                                                    "Pool details: " + natRule.TranslatedSource + ".");
            }
            else
            {
                // The following configuration is NOT supported by Check Point NAT.
                // Instead of a range object, we should use a host object with a first address of a range.
                if (cpNatRule.Method == CheckPoint_NAT_Rule.NatMethod.Hide && translatedSource.GetType().ToString().EndsWith("_Range"))
                {
                    string sIpAddress = ((CheckPoint_Range)translatedSource).RangeFrom;

                    translatedSource = new CheckPoint_Host();
                    ((CheckPoint_Host)translatedSource).IpAddress = sIpAddress;
                    translatedSource.Name = "host_" + sIpAddress;

                    natRule.ConversionIncidentType = ConversionIncidentType.Informative;

                    _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                    "Source NAT rule points to a range object as a translated source for hide-NAT",
                                                                    "Using first address of a range for translated source.",
                                                                    natRule.ConversionIncidentType));
                }
            }

            return translatedSource;
        }

        private CheckPointObject GetNatTranslatedSourceFromJuniperSourceNatInterface(Juniper_SourceNatPolicy natPolicy, Juniper_SourceNatRule natRule, CheckPoint_NAT_Rule cpNatRule)
        {
            CheckPointObject translatedSource = null;
            string destinationInterfaceName = "";

            if (natPolicy.DestinationInterfaces.Count != 0)
            {
                bool ifcFound = false;

                foreach (var ifcName in natPolicy.DestinationInterfaces)
                {
                    foreach (Juniper_Interface ifc in JuniperInterfaces)
                    {
                        if (ifcName == ifc.Name)
                        {
                            if (IsNetworkObjectReachableFromInterface(cpNatRule.Destination, ifc))
                            {
                                translatedSource = GetCheckPointObjectOrCreateDummy(ifcName + "_address",
                                                                                    "Host",
                                                                                    natRule,
                                                                                    "Error creating a NAT rule, missing topology information for Juniper destination interface",
                                                                                    "Destination interface details: " + ifcName + ".");
                            }

                            destinationInterfaceName = ifcName;
                            ifcFound = true;
                            break;
                        }
                    }

                    if (ifcFound)
                    {
                        break;
                    }
                }
            }
            else   // natPolicy.DestinationZones
            {
                bool zoneFound = false;

                foreach (var zoneName in natPolicy.DestinationZones)
                {
                    foreach (Juniper_Zone zone in JuniperZones)
                    {
                        if (zoneName == zone.Name)
                        {
                            bool ifcFound = false;

                            foreach (var ifcName in zone.Interfaces)
                            {
                                foreach (Juniper_Interface ifc in JuniperInterfaces)
                                {
                                    if (ifcName == ifc.Name)
                                    {
                                        if (IsNetworkObjectReachableFromInterface(cpNatRule.Destination, ifc))
                                        {
                                            translatedSource = GetCheckPointObjectOrCreateDummy(ifcName + "_address",
                                                                                                "Host",
                                                                                                natRule,
                                                                                                "Error creating a NAT rule, missing topology information for Juniper destination interface",
                                                                                                "Destination interface details: " + ifcName + ".");
                                        }

                                        destinationInterfaceName = ifcName;
                                        ifcFound = true;
                                        break;
                                    }
                                }

                                if (ifcFound)
                                {
                                    break;
                                }
                            }

                            zoneFound = true;
                            break;
                        }
                    }

                    if (zoneFound)
                    {
                        break;
                    }
                }
            }

            if (translatedSource == null)
            {
                translatedSource = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                                    "Host",
                                                                    natRule,
                                                                    "Error creating a NAT rule, missing topology information for Juniper destination interface",
                                                                    "Destination interface " + destinationInterfaceName + " does not contain appropriate static route to reach " + cpNatRule.Destination.Name + ".");
            }

            return translatedSource;
        }

        private CheckPointObject GetCheckPointObjectFromJuniperNatAddress(Subnet address)
        {
            string addressAutoName = NetworkObjectNameGenerator.AutoGeneratedNetworkName(address);
            CheckPointObject cpObject;

            if (address.IsHost())
            {
                cpObject = new CheckPoint_Host();
                ((CheckPoint_Host)cpObject).IpAddress = address.IpAddress;
            }
            else
            {
                // This is very important, as SRX seems to have such Subnet usages...
                if (address.Netmask == "0.0.0.0")
                {
                    cpObject = new CheckPoint_Range();
                    cpObject.Tag = "ANY_NETWORK";   // !!!
                    ((CheckPoint_Range)cpObject).RangeFrom = "0.0.0.0";
                    ((CheckPoint_Range)cpObject).RangeTo = "255.255.255.255";
                }
                else
                {
                    cpObject = new CheckPoint_Network();
                    ((CheckPoint_Network)cpObject).Subnet = address.IpAddress;
                    ((CheckPoint_Network)cpObject).Netmask = address.Netmask;
                }
            }

            cpObject.Name = addressAutoName;
            AddCheckPointObject(cpObject);

            return cpObject;
        }

        private CheckPointObject GetCheckPointObjectFromJuniperNatPoolAddress(Juniper_NatPool.PoolAddress poolAddress)
        {
            CheckPointObject cpObject = null;

            switch (poolAddress.AddressType)
            {
                case Juniper_NatPool.PoolAddress.NetworkType.Host:
                    cpObject = new CheckPoint_Host();
                    ((CheckPoint_Host)cpObject).IpAddress = poolAddress.IpAddress;
                    break;

                case Juniper_NatPool.PoolAddress.NetworkType.Subnet:
                    cpObject = new CheckPoint_Network();
                    ((CheckPoint_Network)cpObject).Subnet = poolAddress.IpAddress;
                    ((CheckPoint_Network)cpObject).Netmask = poolAddress.Netmask;
                    break;

                case Juniper_NatPool.PoolAddress.NetworkType.Range:
                    cpObject = new CheckPoint_Range();
                    ((CheckPoint_Range)cpObject).RangeFrom = poolAddress.IpAddress;
                    ((CheckPoint_Range)cpObject).RangeTo = poolAddress.RangeTo;
                    break;
            }

            return cpObject;
        }

        private CheckPointObject GetCheckPointObjectFromJuniperNatAddressName(string addressName, JuniperObject natRule)
        {
            if (addressName.Equals(JuniperObject.AnyIPv4, StringComparison.InvariantCultureIgnoreCase))
            {
                addressName = CheckPointObject.Any;
            }

            var cpObject = _cpObjects.GetObject(addressName);
            if (cpObject != null && cpObject.Name == CheckPointObject.Any)
            {
                return cpObject;
            }

            // MUST be from a global address book!!!
            if (cpObject != null && !string.IsNullOrEmpty(cpObject.Tag) && cpObject.Tag == JuniperObject.GlobalZoneName)
            {
                return cpObject;
            }

            return GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                    "Host",
                                                    natRule,
                                                    "Error creating a NAT rule, missing information for Juniper address name object",
                                                    "Address details: " + addressName + ".");
        }

        private CheckPointObject GetCheckPointServiceFromJuniperNatRuleApplication(string application)
        {
            return _cpObjects.GetObject(_juniper2CheckpointServiceDuplicates.ContainsKey(application)
                ? _juniper2CheckpointServiceDuplicates[application]
                : application);
        }

        private IEnumerable<CheckPointObject> GetCheckPointServicesFromJuniperNatRulePort(string sPort)
        {
            var services = new List<CheckPointObject>();

            bool alreadyExists;
            var cpServive = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects, "tcp", sPort, out alreadyExists);
            if (cpServive != null)
            {
                cpServive.Tag = "tcp";   // we need this info during NAT rule creation!!!
                if (!alreadyExists)
                {
                    AddCheckPointObject(cpServive);
                }
                services.Add(cpServive);
            }

            cpServive = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects, "udp", sPort, out alreadyExists);
            if (cpServive != null)
            {
                cpServive.Tag = "udp";   // we need this info during NAT rule creation!!!
                if (!alreadyExists)
                {
                    AddCheckPointObject(cpServive);
                }
                services.Add(cpServive);
            }

            return services;
        }

        private IEnumerable<CheckPointObject> GetCheckPointServicesFromJuniperNatRule(IEnumerable<string> protocols, IEnumerable<string> ports)
        {
            var services = new List<CheckPointObject>();

            foreach (var protocol in protocols)
            {
                switch (protocol)
                {
                    case "tcp":
                    case "udp":
                    case "sctp":
                        // Check the ports...
                        foreach (var port in ports)
                        {
                            bool alreadyExists;
                            var cpServive = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects, protocol, port, out alreadyExists);
                            if (cpServive != null)
                            {
                                if (!alreadyExists)
                                {
                                    AddCheckPointObject(cpServive);
                                }
                                services.Add(cpServive);
                            }
                        }
                        break;

                    case "icmp":
                        services.Add(_cpObjects.GetObject("icmp-proto"));
                        break;

                    default:
                        // General IP protocol name or number:
                        // In this case, the 'Protocol' will always hold the name, and the 'Port' will hold the number.
                        string protocolName;
                        string protocolPort = "";
                        if (JuniperKnownApplications.IsKnownProtocolOrPortName(protocol))
                        {
                            protocolPort = JuniperKnownApplications.ConvertProtocolOrPortNameToNumber(protocol);
                        }
                        else if (JuniperKnownApplications.IsKnownProtocolOrPortNumber(protocol, out protocolName))   // protocol number is used!!!
                        {
                            protocolPort = protocol;
                        }

                        if (!string.IsNullOrEmpty(protocolPort))
                        {
                            bool alreadyExists;
                            var cpServive = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects, "other", protocolPort, out alreadyExists);
                            if (cpServive != null)
                            {
                                if (!alreadyExists)
                                {
                                    AddCheckPointObject(cpServive);
                                }
                                services.Add(cpServive);
                            }
                        }
                        break;
                }
            }

            return services;
        }

        private void CreateNATRulebase()
        {
            var section1 = new List<CheckPoint_NAT_Rule>();
            var section2 = new List<CheckPoint_NAT_Rule>();
            var section3 = new List<CheckPoint_NAT_Rule>();
            var section4 = new List<CheckPoint_NAT_Rule>();
            var section5 = new List<CheckPoint_NAT_Rule>();
            var section6 = new List<CheckPoint_NAT_Rule>();
            var section7 = new List<CheckPoint_NAT_Rule>();

            // Create the NAT sections
            foreach (var cpNatRule in _cpPreorderedNatRules)
            {
                var juniperNatCustomData = ((JuniperNatCustomData)cpNatRule.VendorCustomData);

                switch (juniperNatCustomData.Priority)
                {
                    case JuniperNatCustomData.RulePriority.StaticInterface:
                        section1.Add(cpNatRule);
                        break;

                    case JuniperNatCustomData.RulePriority.StaticZone:
                        section2.Add(cpNatRule);
                        break;

                    case JuniperNatCustomData.RulePriority.DestinationInterface:
                        section3.Add(cpNatRule);
                        break;

                    case JuniperNatCustomData.RulePriority.DestinationZone:
                        section4.Add(cpNatRule);
                        break;

                    case JuniperNatCustomData.RulePriority.SourceInterface2Interface:
                        section5.Add(cpNatRule);
                        break;

                    case JuniperNatCustomData.RulePriority.SourceMixed:
                        section6.Add(cpNatRule);
                        break;

                    case JuniperNatCustomData.RulePriority.SourceZone2Zone:
                        section7.Add(cpNatRule);
                        break;
                }
            }

            // Create the NAT Rulebase
            _cpNatRules.AddRange(section1);
            _cpNatRules.AddRange(section2);
            _cpNatRules.AddRange(section3);
            _cpNatRules.AddRange(section4);
            _cpNatRules.AddRange(section5);
            _cpNatRules.AddRange(section6);
            _cpNatRules.AddRange(section7);
        }

        private void MatchNATRulesIntoFirewallPolicy()
        {
            CheckPoint_Package cpPackage = _cpPackages[0];

            foreach (CheckPoint_NAT_Rule cpNatRule in _cpNatRules)
            {
                var juniperNatCustomData = ((JuniperNatCustomData)cpNatRule.VendorCustomData);

                // Skip source NAT rules
                if (juniperNatCustomData.Priority > JuniperNatCustomData.RulePriority.DestinationZone)
                {
                    continue;
                }

                // Skip NO-NAT destination NAT rules
                if (cpNatRule.TranslatedDestination == null)
                {
                    continue;
                }

                // Skip static NAT mirrored rules
                if (juniperNatCustomData.IsStaticMirrorRule)
                {
                    continue;
                }

                foreach (CheckPoint_Rule cpParentRule in cpPackage.ParentLayer.Rules)
                {
                    if (cpParentRule.Action != CheckPoint_Rule.ActionType.SubPolicy)
                    {
                        continue;
                    }

                    if (cpParentRule.Source[0] is CheckPoint_PredifinedObject && cpParentRule.Source[0].Name.Equals(CheckPointObject.Any))
                    {
                        continue;
                    }
					
                    var parentLayerRuleZone = (CheckPoint_Zone)cpParentRule.Source[0];
                    if (parentLayerRuleZone == null)
                    {
                        Console.WriteLine("Ooopppsssss...............");   // shouldn't happen...
                        continue;
                    }

                    // NAT rule source zone(s)/interface(s) should match on firewall rule source zone
                    if (!IsFirewallRuleSourceZoneMatchedByNATRule(parentLayerRuleZone.Name, juniperNatCustomData))
                    {
                        continue;
                    }

                    // Get into the relevant sub-policy
                    foreach (CheckPoint_Layer subPolicy in cpPackage.SubPolicies)
                    {
                        if (subPolicy.Name != cpParentRule.SubPolicyName)
                        {
                            continue;
                        }

                        for (int ruleNumber = 0; ruleNumber < subPolicy.Rules.Count; ruleNumber++)
                        {
                            var cpRule = subPolicy.Rules[ruleNumber];

                            // Do not match on default action rule
                            if (!string.IsNullOrEmpty(cpRule.Name) && cpRule.Name == Juniper_GlobalPolicyRule.DefaultActionRuleName)
                            {
                                continue;
                            }

                            // Do not match if rule's destination is 'any'
                            if (cpRule.Destination.Count == 1 && cpRule.Destination[0].Name == CheckPointObject.Any)
                            {
                                continue;
                            }

                            bool serviceMatchedToo = false;

                            if (IsFirewallRuleMatchedByNATRule(cpNatRule, cpRule, out serviceMatchedToo))
                            {
                                string natServiceName = (cpNatRule.Service != null) ? cpNatRule.Service.Name : "";

                                var newRule = new CheckPoint_Rule();

                                newRule.Enabled = cpRule.Enabled;
                                newRule.Source.AddRange(cpRule.Source);
                                newRule.Destination.Add(cpNatRule.Destination);
                                if (serviceMatchedToo && !string.IsNullOrEmpty(natServiceName))
                                {
                                    newRule.Service.Add(_cpObjects.GetObject(natServiceName));
                                }
                                else
                                {
                                    newRule.Service.AddRange(cpRule.Service);
                                }
                                newRule.Action = cpRule.Action;
                                newRule.Layer = subPolicy.Name;
                                newRule.ConvertedCommandId = cpNatRule.ConvertedCommandId;
                                newRule.ConversionIncidentType = (cpRule.ConversionIncidentType != ConversionIncidentType.None) ? cpRule.ConversionIncidentType : cpNatRule.ConversionIncidentType;
                                newRule.ConversionComments = string.Format("Matched NAT rule, line {0}", cpNatRule.ConvertedCommandId);

                                // Recall this rule for duplicates lookup.
                                bool similiarRuleExists = false;

                                List<CheckPoint_Rule> matchedRules;
                                if (_natMatchedFirewallRules.TryGetValue(cpRule.ConvertedCommandId, out matchedRules))
                                {
                                    if (matchedRules.Any(matchedRule => matchedRule.CompareTo(newRule)))
                                    {
                                        similiarRuleExists = true;
                                    }

                                    if (!similiarRuleExists)
                                    {
                                        matchedRules.Add(newRule);
                                    }
                                }
                                else
                                {
                                    matchedRules = new List<CheckPoint_Rule> { newRule };
                                    _natMatchedFirewallRules.Add(cpRule.ConvertedCommandId, matchedRules);
                                }

                                if (!similiarRuleExists)
                                {
                                    // Add a new rule ABOVE the matched rule.
                                    subPolicy.Rules.Insert(ruleNumber, newRule);

                                    if (newRule.ConversionIncidentType != ConversionIncidentType.None)
                                    {
                                        cpPackage.ConversionIncidentType = ConversionIncidentType.Informative;
                                    }
                                }

                                // If NAT rule's service is "any" (null), we need to keep matching for all relevant FW rules.
                                if (serviceMatchedToo)
                                {
                                    break;
                                }
                                else if (!similiarRuleExists)
                                {
                                    ++ruleNumber;   // this is because we are changing the collection during iteration!!!
                                }
                            }
                        }
                    }
                }
            }
        }

        private bool IsFirewallRuleSourceZoneMatchedByNATRule(string fwRuleSourceZone, JuniperNatCustomData natCustomData)
        {
            if (natCustomData.Priority == JuniperNatCustomData.RulePriority.StaticZone || natCustomData.Priority == JuniperNatCustomData.RulePriority.DestinationZone)
            {
                return natCustomData.SourceZonesOrInterfaces.Any(sourceZone => sourceZone == fwRuleSourceZone);
            }

            foreach (var sourceInterface in natCustomData.SourceZonesOrInterfaces)
            {
                foreach (Juniper_Zone zone in JuniperZones)
                {
                    if (zone.Interfaces.Any(ifcName => sourceInterface == ifcName))
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        private bool IsFirewallRuleMatchedByNATRule(CheckPoint_NAT_Rule natRule, CheckPoint_Rule fwRule, out bool serviceMatchedToo)
        {
            serviceMatchedToo = false;

            var natSourceRanges = (natRule.Source != null) ? GetRanges(natRule.Source) : IPRanges.Any();
            var natTranslatedDestRanges = (natRule.TranslatedDestination != null) ? GetRanges(natRule.TranslatedDestination) : IPRanges.Any();
            var fwRuleSourceRanges = (fwRule.Source.Count > 0) ? GetRanges(fwRule.Source[0]) : IPRanges.Any();
            var fwRuleDestRanges = (fwRule.Destination.Count > 0) ? GetRanges(fwRule.Destination[0]) : IPRanges.Any();

            if (fwRuleSourceRanges.Overlaps(natSourceRanges) && fwRuleDestRanges.Overlaps(natTranslatedDestRanges))
            {
                // Match on service too...
                if (natRule.TranslatedService == null)
                {
                    // No NAT service at all
                    return true;
                }

                if (fwRule.Service.Count == 0)
                {
                    // TODO: ???
                }
                else if (fwRule.Service.Count == 1 && fwRule.Service[0].Name == CheckPointObject.Any)
                {
                    // There is only one service in FW rule and it is "any", no matter what NAT rule service is...
                    serviceMatchedToo = true;
                    return true;
                }
                else if (fwRule.Service.Any(fwService => natRule.TranslatedService.Name == fwService.Name))
                {
                    // Service names match - NAT rule service appears in the list of FW rule's services
                    serviceMatchedToo = true;
                    return true;
                }
            }

            return false;
        }

        private IPRanges GetRanges(CheckPointObject cpObject)
        {
            if (cpObject == null || cpObject.Name == CheckPointObject.Any)
            {
                return new IPRanges(new IPRange(IPRange.Any));
            }

            if (cpObject.GetType().ToString().EndsWith("_NetworkGroup"))
            {
                return GetGroupRanges((CheckPoint_NetworkGroup)cpObject);
            }

            if (cpObject.GetType().ToString().EndsWith("_Host"))
            {
                return ((CheckPoint_Host)cpObject).GetIPRanges();
            }

            if (cpObject.GetType().ToString().EndsWith("_Network"))
            {
                return ((CheckPoint_Network)cpObject).GetIPRanges();
            }

            if (cpObject.GetType().ToString().EndsWith("_Range"))
            {
                return ((CheckPoint_Range)cpObject).GetIPRanges();
            }

            return new IPRanges();
        }

        private void ApplyConversionIncidentOnCheckPointObject(CheckPointObject cpObject, JuniperObject juniperObject)
        {
            cpObject.ConvertedCommandId = juniperObject.LineNumber;

            if (juniperObject.ConversionIncidentType != ConversionIncidentType.None)
            {
                cpObject.ConversionIncidentType = juniperObject.ConversionIncidentType;

                if (!string.IsNullOrEmpty(juniperObject.ConversionIncidentMessage))
                {
                    int pos = juniperObject.GetType().ToString().IndexOf("_");
                    string errorDesc = juniperObject.GetType().ToString().Substring(pos + 1) + " details: " + juniperObject.Name + ".";

                    _conversionIncidents.Add(new ConversionIncident(juniperObject.LineNumber,
                                                                    juniperObject.ConversionIncidentMessage,
                                                                    errorDesc,
                                                                    juniperObject.ConversionIncidentType));
                }
            }
        }

        private bool DoesJuniperApplicationMatchCheckpointPredefinedService(Juniper_Application application, string serviceName)
        {
            bool matchFound;
            serviceName = _cpObjects.GetKnownServiceName(serviceName, out matchFound);

            if (matchFound)
            {
                if (serviceName != application.Name)
                {
                    try
                    {
                        _juniper2CheckpointServiceDuplicates.Add(application.Name, serviceName);
                    }
                    catch (Exception e) {}

                    application.ConversionIncidentType = ConversionIncidentType.Informative;

                    string errorDescription = string.Format("Juniper application name: {0}. Check Point service name: {1}", application.Name, serviceName);
                    _conversionIncidents.Add(new ConversionIncident(application.IsJunosDefault ? 0 : application.LineNumber,
                                                                    "Juniper application has an equivalent Check Point service. Using a Check Point service instead.",
                                                                    errorDescription,
                                                                    application.ConversionIncidentType));
                }

                return true;
            }

            return false;
        }

        private bool IsNetworkObjectReachableFromInterface(CheckPointObject cpObject, Juniper_Interface juniperInterface)
        {
            if (cpObject.Name == CheckPointObject.Any || cpObject.Tag == "ANY_NETWORK")   // !!!
            {
                return true;
            }

            var interfaceTopology = GetJuniperInterfaceTopology(juniperInterface);
            if (interfaceTopology != null && interfaceTopology.Any() && IsNetworkObjectContainedInInterfaceTopology(cpObject, interfaceTopology))
            {
                return true;
            }

            return false;
        }

        private bool IsNetworkObjectContainedInMultipleZones(CheckPointObject cpObject, JuniperObject juniperObject)
        {
            if ((cpObject.Tag != JuniperObject.GlobalZoneName) && _juniperParser.IsNetworkObjectContainedInMultipleZones(cpObject.Name))
            {
                _cpNetworkObjectsInMultipleZones.Add(cpObject);

                juniperObject.ConversionIncidentType = ConversionIncidentType.Informative;
                cpObject.ConversionIncidentType = ConversionIncidentType.Informative;   // report on converted object as well!!!

                string modifiedName = (cpObject.Name != cpObject.SafeName()) ? cpObject.SafeName() : cpObject.Name;

                string errorDescription = string.Format("Object name: {0}, attached zone: {1}. Modified name: {0}_{1}", modifiedName, cpObject.Tag);
                _conversionIncidents.Add(new ConversionIncident(juniperObject.LineNumber,
                                                                "Juniper object with the same name is attached to different zones. Applying zone name to object name for Check Point name uniqueness.",
                                                                errorDescription,
                                                                juniperObject.ConversionIncidentType));
                return true;
            }

            return false;
        }

        private bool AreNetworkAndZoneNamesDuplicated(string networkName)
        {
            foreach (Juniper_Zone zone in JuniperZones)
            {
                if (networkName.Equals(zone.Name, StringComparison.InvariantCultureIgnoreCase))
                {
                    return true;
                }
            }

            return false;
        }

        private bool IsNetworkObjectContainedInInterfaceTopology(CheckPointObject cpObject, IEnumerable<IPNetwork> interfaceTopology)
        {
            if (cpObject == null || cpObject.Name.Contains(AutoGeneratedNameWithError))
            {
                return false;
            }

            var cpNetworkGroup = cpObject as CheckPoint_NetworkGroup;
            if (cpNetworkGroup != null)
            {
                foreach (var memberName in cpNetworkGroup.Members)
                {
                    var member = _cpObjects.GetObject(memberName);
                    if (IsNetworkObjectContainedInInterfaceTopology(member, interfaceTopology))
                    {
                        return true;
                    }
                }

                return false;
            }

            var cpNetwork = cpObject as CheckPoint_Network;
            if (cpNetwork != null)
            {
                IPNetwork network;
                if (IPNetwork.TryParse(cpNetwork.Subnet, cpNetwork.Netmask, out network))
                {
                    return interfaceTopology.Any(topology => IPNetwork.Contains(topology, network));
                }

                return false;
            }

            var cpRange = cpObject as CheckPoint_Range;
            if (cpRange != null)
            {
                IPNetwork network = IPNetwork.WideSubnet(cpRange.RangeFrom, cpRange.RangeTo);
                return interfaceTopology.Any(topology => IPNetwork.Contains(topology, network));
            }

            var cpHost = cpObject as CheckPoint_Host;
            if (cpHost != null)
            {
                IPNetwork network;
                if (IPNetwork.TryParse(cpHost.IpAddress, 32, out network))
                {
                    return interfaceTopology.Any(topology => IPNetwork.Contains(topology, network));
                }
            }

            return false;
        }

        private List<IPNetwork> GetJuniperInterfaceTopology(Juniper_Interface ifc)
        {
            List<IPNetwork> interfaceTopology = null;

            if (ifc.Topology.Count > 0 && !_juniperInterfacesTopology.TryGetValue(ifc.Name, out interfaceTopology))
            {
                interfaceTopology = new List<IPNetwork>();

                foreach (var topology in ifc.Topology)
                {
                    IPNetwork ipNetwork;
                    if (IPNetwork.TryParse(topology.IpAddress, topology.Netmask, out ipNetwork))
                    {
                        interfaceTopology.Add(ipNetwork);
                    }
                }

                if (interfaceTopology.Count > 0)
                {
                    _juniperInterfacesTopology.Add(ifc.Name, interfaceTopology);
                }
            }

            return interfaceTopology;
        }

        private void CheckObjectNameValidity(CheckPointObject cpObject, JuniperObject juniperObject, bool inMultipleZones = false, bool safeNameOnly = false)
        {
            string originalName = cpObject.Name;

            if (originalName != cpObject.SafeName())
            {
                string unsafeName = inMultipleZones ? (originalName + "_" + cpObject.Tag) : originalName;   // this is important!!!
                _cpUnsafeNames.Add(unsafeName);
            }

            if (safeNameOnly)
            {
                return;
            }

            if (cpObject.GetType().ToString().EndsWith("_TcpService") || cpObject.GetType().ToString().EndsWith("_UdpService"))
            {
                // TCP/UDP service name must start with a letter!!!
                if (!Char.IsLetter(originalName[0]))
                {
                    _cpServiceInvalidNames.Add(originalName);

                    juniperObject.ConversionIncidentType = ConversionIncidentType.Informative;
                    cpObject.ConversionIncidentType = ConversionIncidentType.Informative;   // report on converted object as well!!!

                    string errorDescription = string.Format("Service original name: {0}. Modified name: {1}", originalName, InvalidServiceNamePrefix + originalName);
                    _conversionIncidents.Add(new ConversionIncident(juniperObject.LineNumber,
                                                                    "TCP/UDP service object name must start with a letter. Modifying the original name to a Check Point valid name.",
                                                                    errorDescription,
                                                                    juniperObject.ConversionIncidentType));
                }
            }

            DuplicateNameInfo duplicateNameInfo;
            if (_duplicateNamesLookup.TryGetValue(originalName, out duplicateNameInfo))
            {
                if (inMultipleZones)
                {
                    if (!duplicateNameInfo.Zones.Contains(cpObject.Tag))
                    {
                        duplicateNameInfo.Zones.Add(cpObject.Tag);
                        _duplicateNamesLookup[originalName] = duplicateNameInfo;
                        return;
                    }
                }

                if (duplicateNameInfo.IsJuniperApplicationFromTerm && juniperObject.GetType().ToString().EndsWith("_Application"))
                {
                    var juniperApplication = (Juniper_Application)juniperObject;
                    if (juniperApplication.IsFromTerm)
                    {
                        // This is not a real duplicate...
                        return;
                    }
                }

                juniperObject.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                string errorTitle = duplicateNameInfo.IsCPPredefinedName
                                        ? "Detected an object with a same name in Check Point's predefined service objects repository."
                                        : "Detected an object with a non unique name. Check Point names should be case insensitive.";
                errorTitle += " Please review for further possible modifications to object configuration before the final migration.";

                string errorDescription = string.Format("Object details: {0} [{1}].", originalName, juniperObject.GetType().ToString().Split('_')[1]);

                _conversionIncidents.Add(new ConversionIncident(juniperObject.LineNumber, errorTitle, errorDescription, juniperObject.ConversionIncidentType));
            }
            else
            {
                duplicateNameInfo = new DuplicateNameInfo(false);
                if (inMultipleZones)
                {
                    duplicateNameInfo.Zones.Add(cpObject.Tag);
                }
                if (juniperObject.GetType().ToString().EndsWith("_Application"))
                {
                    var juniperApplication = (Juniper_Application)juniperObject;
                    if (juniperApplication.IsFromTerm)
                    {
                        // In this case there may be several applications with the same name...
                        duplicateNameInfo.IsJuniperApplicationFromTerm = true;
                    }
                }

                _duplicateNamesLookup.Add(originalName, duplicateNameInfo);
            }
        }

        private void AlertOnDomainNameModification(Juniper_Fqdn fqdn, bool inMultipleZones)
        {
            fqdn.ConversionIncidentType = ConversionIncidentType.Informative;

            string errorDescription = inMultipleZones
                ? string.Format("Juniper name: {0}, attached to zone {1}. New name: .{2}", fqdn.Name, fqdn.ZoneName, fqdn.DnsName)
                : string.Format("Juniper name: {0}. New name: .{1}", fqdn.Name, fqdn.DnsName);

            _conversionIncidents.Add(new ConversionIncident(fqdn.LineNumber,
                                                            "Juniper Domain object is converted to Check Point Domain object using dns-name prefixed with a dot as converted object name.",
                                                            errorDescription,
                                                            fqdn.ConversionIncidentType));
        }

        private void EnforceObjectNameValidity()
        {
            // Fix juniper dns names to be valid check point domain names
            foreach (var domain in _cpDomains)
            {
                string originalName = domain.Name;
                string validName = "." + domain.Fqdn;
                domain.Name = validName;
                domain.ConversionIncidentType = ConversionIncidentType.Informative;

                // Search references in network groups
                foreach (var networkGroup in _cpNetworkGroups)
                {
                    if (domain.Tag == networkGroup.Tag)   // search in the same zone only...
                    {
                        int pos = networkGroup.Members.IndexOf(originalName);
                        if (pos != -1)
                        {
                            networkGroup.Members[pos] = validName;
                        }
                    }
                }
            }

            // Fix invalid TCP/UDP service names
            foreach (var invalidName in _cpServiceInvalidNames)
            {
                bool found = false;
                string validName = InvalidServiceNamePrefix + invalidName;

                // Search in TCP services
                foreach (var tcpService in _cpTcpServices)
                {
                    if (invalidName == tcpService.Name)
                    {
                        tcpService.Name = validName;
                        found = true;
                        break;
                    }
                }

                // Otherwise, search in UDP services
                if (!found)
                {
                    foreach (var udpService in _cpUdpServices)
                    {
                        if (invalidName == udpService.Name)
                        {
                            udpService.Name = validName;
                            break;
                        }
                    }
                }

                // Finally, search references in service groups
                foreach (var serviceGroup in _cpServiceGroups)
                {
                    int pos = serviceGroup.Members.IndexOf(invalidName);
                    if (pos != -1)
                    {
                        serviceGroup.Members[pos] = validName;
                    }
                }
            }

            // Fix unsafe names
            foreach (var unsafeName in _cpUnsafeNames)
            {
                CheckPointObject cpObject = _cpObjects.GetObject(unsafeName);
                if (cpObject != null)
                {
                    cpObject.Name = cpObject.SafeName();

                    // Search references in service groups
                    foreach (var serviceGroup in _cpServiceGroups)
                    {
                        int pos = serviceGroup.Members.IndexOf(unsafeName);
                        if (pos != -1)
                        {
                            serviceGroup.Members[pos] = cpObject.Name;
                        }
                    }

                    // Search references in network groups
                    foreach (var networkGroup in _cpNetworkGroups)
                    {
                        int pos = networkGroup.Members.IndexOf(unsafeName);
                        if (pos != -1)
                        {
                            networkGroup.Members[pos] = cpObject.Name;
                        }
                    }

                    // Search references in network groups with exclusion
                    foreach (var networkGroup in _cpGroupsWithExclusion)
                    {
                        if (networkGroup.Include == unsafeName)
                        {
                            networkGroup.Include = cpObject.Name;
                        }
                        if (networkGroup.Except == unsafeName)
                        {
                            networkGroup.Except = cpObject.Name;
                        }
                    }
                }
            }
        }

        private void ReplaceJuniperApplicationsWithEquivalentCheckpointServices()
        {
            foreach (var serviceDuplicate in _juniper2CheckpointServiceDuplicates)
            {
                // Search references in service groups
                foreach (var serviceGroup in _cpServiceGroups)
                {
                    int pos = serviceGroup.Members.IndexOf(serviceDuplicate.Key);
                    if (pos != -1)
                    {
                        serviceGroup.Members[pos] = serviceDuplicate.Value;
                    }
                }
            }
        }

        private void ReplaceJuniperInvalidApplicationsReferences()
        {
            foreach (var invalidApplication in _juniperInvalidApplicationsReferences)
            {
                // Search references in service groups
                foreach (var serviceGroup in _cpServiceGroups)
                {
                    int pos = serviceGroup.Members.IndexOf(invalidApplication.Key);
                    if (pos != -1)
                    {
                        serviceGroup.Members[pos] = invalidApplication.Value;
                    }
                }
            }
        }

        private CheckPointObject GetCheckPointObjectOrCreateDummy(string cpObjectName, string dummyObjectType, JuniperObject juniperObject, string errorTitle, string errorDescription, bool createDummy = true)
        {
            if (cpObjectName.Equals(JuniperObject.AnyIPv4, StringComparison.InvariantCultureIgnoreCase))
            {
                cpObjectName = CheckPointObject.Any;
            }

            var cpObject = _cpObjects.GetObject(cpObjectName);
            if (cpObject != null || !createDummy)
            {
                return cpObject;
            }

            CheckPointObject cpDummyObject = null;

            switch (dummyObjectType)
            {
                case "Host":
                    cpDummyObject = new CheckPoint_Host { Name = "_Err_in_network-line_" + juniperObject.LineNumber, IpAddress = "1.1.1.1" };
                    break;

                case "NetworkGroup":
                    cpDummyObject = new CheckPoint_NetworkGroup { Name = "_Err_in_topology-line_" + juniperObject.LineNumber };
                    break;

                case "ServiceGroup":
                    string cpServiceName;
                    if (_juniper2CheckpointServiceDuplicates.TryGetValue(cpObjectName, out cpServiceName))
                    {
                        cpObject = _cpObjects.GetObject(cpServiceName);
                        if (cpObject != null)
                        {
                            return cpObject;
                        }
                    }

                    cpDummyObject = new CheckPoint_ServiceGroup { Name = "_Err_in_service-line_" + juniperObject.LineNumber };
                    break;
                case "Time":
                    cpDummyObject = new CheckPoint_Time { Name = cpObjectName};
                    break;
            }

            if (cpDummyObject != null)
            {
                cpDummyObject.ConvertedCommandId = juniperObject.LineNumber;
                cpDummyObject.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                AddCheckPointObject(cpDummyObject);

                juniperObject.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                errorDescription = string.Format("{0} Using dummy object: {1}.", errorDescription, cpDummyObject.Name);
                _conversionIncidents.Add(new ConversionIncident(juniperObject.LineNumber, errorTitle, errorDescription, juniperObject.ConversionIncidentType));
            }

            return cpDummyObject;
        }

        protected override string GetVendorName()
        {
            return Vendor.JuniperJunosOS.ToString();
        }
        #endregion

        #region Public Methods

        public override void Initialize(VendorParser vendorParser, string vendorFilePath, string toolVersion, string targetFolder, string domainName)
        {
            _juniperParser = (JuniperParser)vendorParser;
            if (_juniperParser == null)
            {
                throw new InvalidDataException("Unexpected!!!");
            }

            base.Initialize(vendorParser, vendorFilePath, toolVersion, targetFolder, domainName);
        }

        public override void Convert(bool convertNat)
        {
            RaiseConversionProgress(20, "Converting obects ...");
            _cpObjects.Initialize();   // must be first!!!

            foreach (var cpObject in _cpObjects.GetPredefinedObjects())
            {
                _duplicateNamesLookup.Add(cpObject.Name, new DuplicateNameInfo(true));
            }
            Add_Schedulers();
            Add_NetworkObjects();
            Add_InterfacesAndRoutes();
            Add_or_Modify_InterfaceNetworkGroups();
            Add_Zones();   // must be called AFTER handling all network stuff!!!
            Add_ServiceObjects();

            RaiseConversionProgress(30, "Converting rules ...");
            Add_Package();

            if (convertNat)
            {
                RaiseConversionProgress(40, "Converting NAT rules ...");
                Add_Static_NAT();
                Add_Destination_NAT();
                Add_Source_NAT();
                RaiseConversionProgress(50, "Creating NAT rulebase ...");
                CreateNATRulebase();
                RaiseConversionProgress(60, "Creating Firewall rulebase ...");
                MatchNATRulesIntoFirewallPolicy();
            }

            // This should be done here, after all objects are converted!!!
            RaiseConversionProgress(70, "Validating converted objects ...");
            EnforceObjectNameValidity();
            ReplaceJuniperApplicationsWithEquivalentCheckpointServices();
            ReplaceJuniperInvalidApplicationsReferences();

            RaiseConversionProgress(80, "Generating CLI scripts ...");
            CreateObjectsScript();
            CreatePackagesScript();
            CreateObjectsHtml();

            // This data container is important, and is used during html reports generation for incidents lookup!!!
            var incidentsGroupedByLineNumber = _conversionIncidents.GroupBy(error => error.LineNumber);
            _conversionIncidentsByLineNumber = incidentsGroupedByLineNumber.ToDictionary(error => error.Key, error => error.Distinct().ToList());

            // Resolve the conversion categories/lines count to report to the user.
            ConversionIncidentCategoriesCount = _conversionIncidents.GroupBy(error => error.Title).Count();
            ConversionIncidentsCommandsCount = _conversionIncidents.GroupBy(error => error.LineNumber).Count();
			
            CreateSmartConnector();
        }
        
        public override int RulesInConvertedPackage()
        {
            return _cpPackages[0].TotalRules();
        }

        public override int RulesInConvertedOptimizedPackage()
        {
            return 0;
        }

        public override int RulesInNatLayer()
        {
            return _cpNatRules.Count;
        }

        public override void ExportConfigurationAsHtml()
        {
            using (var file = new StreamWriter(VendorHtmlFile))
            {
                file.WriteLine("<html>");
                file.WriteLine("<head>");
                file.WriteLine("<style>");
                file.WriteLine("  body { font-family: Arial; }");
                file.WriteLine("  .report_table { border-collapse: separate; border-spacing: 0px; font-family: Lucida Console; white-space: pre; }");
                file.WriteLine("  td {padding: 5px; vertical-align: top}");
                file.WriteLine("  .line_number {background: lightgray;}");
                file.WriteLine("  .converterr {color: Red;}");
                file.WriteLine("  .convertinfo {color: Blue;}");
                file.WriteLine("  .err_title {color: Red;}");
                file.WriteLine("  .info_title {color: Blue;}");
                file.WriteLine("</style>");
                file.WriteLine("</head>");

                file.WriteLine("<body>");
                file.WriteLine("<h2>Juniper config file</h2>");

                file.WriteLine("<table style='margin-bottom: 20px; background: rgb(250,250,250);'>");
                file.WriteLine("   <tr><td style='font-size: 14px; text-decoration: underline;'>Colors Legend</td></tr>");
                file.WriteLine("   <tr><td style='font-size: 12px; color: Red;'>Commands with conversion error</td></tr>");
                file.WriteLine("   <tr><td style='font-size: 12px; color: Blue;'>Commands with conversion notification</td></tr>");
                file.WriteLine("</table>");

                file.WriteLine("<div style='margin-bottom: 20px; font-size: 14px; color: Blue;'>");
                file.WriteLine("   <span style='vertical-align: middle; font-size: 14px;'>" + HtmlAlertImageTag);
                file.WriteLine("      <a> Valid Check Point object name consists of the following characters only - \"A-Za-z0-9_.-\". Any invalid character will be replaced with a \"_\" character.</a>");
                file.WriteLine("   </span>");
                file.WriteLine("</div>");

                if (_conversionIncidents.Count > 0)
                {
                    file.WriteLine("<div style='margin-bottom: 20px;'>");
                    file.WriteLine("   <span style='vertical-align: middle; font-size: 14px;'>" + HtmlAlertImageTag);
                    file.WriteLine("      <a href='#ConversionIncidents'>Found " + ConversionIncidentCategoriesCount + " conversion issues in " + ConversionIncidentsCommandsCount + " configuration lines</a>");
                    file.WriteLine("   </span>");
                    file.WriteLine("</div>");
                }

                file.WriteLine("<table class=\"report_table\">");

                string[] lines = File.ReadAllLines(_vendorFilePath);
                int lineNumber = 0;

                _juniperParser.ParsedLines = lines.Count();

                foreach (string line in lines)
                {
                    ++lineNumber;

                    ConversionIncidentType highestIncidentType;
                    string incidentFlag = BuildConversionIncidentInfo(lineNumber, out highestIncidentType);

                    string lineStyle = "";

                    switch (highestIncidentType)
                    {
                        case ConversionIncidentType.Informative:
                            lineStyle = " class=\"convertinfo\" ";
                            break;
                        case ConversionIncidentType.ManualActionRequired:
                            lineStyle = " class=\"converterr\" ";
                            break;
                    }

                    file.WriteLine("<tr>");
                    file.WriteLine("  <td id=\"line_" + lineNumber + "\" class=\"line_number\" style=\"text-align: right;\">" + incidentFlag + lineNumber + "</td>" + "<td " + lineStyle + " >" + WebUtility.HtmlEncode(line) + "</td>");
                    file.WriteLine("</tr>");
                }

                file.WriteLine("</table>");

                if (_conversionIncidents.Count > 0)
                {
                    file.WriteLine("<hr/>");
                    file.WriteLine("<h2 id=\"ConversionIncidents\">Conversion Issues</h2>");

                    bool first = true;
                    ConversionIncident prevErr = null;

                    foreach (ConversionIncident err in _conversionIncidents.OrderByDescending(item => item.IncidentType).ThenBy(item => item.Title).ThenBy(item => item.LineNumber).ToList())
                    {
                        if (first)
                        {
                            if (err.IncidentType == ConversionIncidentType.ManualActionRequired)
                            {
                                file.WriteLine("<h4 class=\"err_title\">" + err.Title + "</h4>");
                            }
                            else
                            {
                                file.WriteLine("<h4 class=\"info_title\">" + err.Title + "</h4>");
                            }
                            file.WriteLine("<table class=\"report_table\">");
                        }

                        if (!first && prevErr.Title != err.Title)
                        {
                            file.WriteLine("</table>");

                            if (err.IncidentType == ConversionIncidentType.ManualActionRequired)
                            {
                                file.WriteLine("<h4 class=\"err_title\">" + err.Title + "</h4>");
                            }
                            else
                            {
                                file.WriteLine("<h4 class=\"info_title\">" + err.Title + "</h4>");
                            }
                            file.WriteLine("<table class=\"report_table\">");
                        }

                        // Do not display the same description for the same line...
                        if (prevErr == null || prevErr.LineNumber != err.LineNumber || prevErr.Description != err.Description)
                        {
                            file.WriteLine("  <tr>");
                            file.WriteLine("    <td class=\"line_number\" style=\"text-align: right;\"> <a href=\"#line_" + err.LineNumber + "\">" + err.LineNumber + "</a></td>");
                            file.WriteLine("    <td>" + err.Description + "</td>");
                            file.WriteLine("  </tr>");
                        }

                        first = false;
                        prevErr = err;
                    }
                }

                file.WriteLine("</body>");
                file.WriteLine("</html>");
            }
        }

        public override void ExportPolicyPackagesAsHtml()
        {
            const string ruleIdPrefix = "rule_";
            var package = _cpPackages[0];
            string filename = _targetFolder + "\\" + package.Name + ".html";

            using (var file = new StreamWriter(filename, false))
            {
                var rulesWithConversionErrors = new Dictionary<string, CheckPoint_Rule>();
                var rulesWithConversionInfos = new Dictionary<string, CheckPoint_Rule>();

                GeneratePackageHtmlReportHeaders(file, package.Name, package.ConversionIncidentType != ConversionIncidentType.None);

                // Generate the report body
                file.WriteLine("<table>");
                file.WriteLine("   <tr>");
                file.WriteLine("      <th colspan='3'>No.</th> <th>Name</th> <th>Source</th> <th>Destination</th> <th>Service</th> <th>Action</th> <th>Track</th> <th>Comments</th> <th>Conversion Comments</th>");
                file.WriteLine("   </tr>");

                int ruleNumber = 1;

                foreach (CheckPoint_Rule rule in package.ParentLayer.Rules)
                {
                    bool isSubPolicy = false;
                    string action = "";
                    string actionStyle = "";
                    var dummy = ConversionIncidentType.None;

                    switch (rule.Action)
                    {
                        case CheckPoint_Rule.ActionType.Accept:
                        case CheckPoint_Rule.ActionType.Drop:
                        case CheckPoint_Rule.ActionType.Reject:
                            action = rule.Action.ToString();
                            actionStyle = rule.Action.ToString().ToLower();
                            break;

                        case CheckPoint_Rule.ActionType.SubPolicy:
                            isSubPolicy = true;
                            action = "Sub-policy: " + rule.SubPolicyName;
                            actionStyle = "";
                            break;
                    }

                    string curParentRuleId = string.Format("{0}{1}", ruleIdPrefix, ruleNumber);

                    if (rule.Enabled)
                    {
                        file.WriteLine("  <tr class='parent_rule' id=\"" + curParentRuleId + "\">");
                        if (isSubPolicy)
                        {
                            file.WriteLine("      <td class='rule_number' colspan='3' onclick='toggleSubRules(this)'>" +
                                string.Format(HtmlSubPolicyArrowImageTagFormat, curParentRuleId + "_img", HtmlDownArrowImageSourceData) + ruleNumber + "</td>");
                        }
                        else
                        {
                            file.WriteLine("      <td class='rule_number' colspan='3' style='padding-left:22px;'>" + ruleNumber + "</td>");
                        }
                    }
                    else
                    {
                        file.WriteLine("  <tr class='parent_rule_disabled' id=\"" + curParentRuleId + "\">");
                        if (isSubPolicy)
                        {
                            file.WriteLine("      <td class='rule_number' colspan='3' onclick='toggleSubRules(this)'>" +
                                string.Format(HtmlSubPolicyArrowImageTagFormat, curParentRuleId + "_img", HtmlDownArrowImageSourceData) + ruleNumber + HtmlDisabledImageTag + "</td>");
                        }
                        else
                        {
                            file.WriteLine("      <td class='rule_number' colspan='3' style='padding-left:22px;'>" + ruleNumber + HtmlDisabledImageTag + "</td>");
                        }
                    }
                    file.WriteLine("      <td>" + rule.Name + "</td>");
                    file.WriteLine("      <td>" + RuleItemsList2Html(rule.Source, rule.SourceNegated, CheckPointObject.Any, ref dummy) + "</td>");
                    file.WriteLine("      <td>" + RuleItemsList2Html(rule.Destination, rule.DestinationNegated, CheckPointObject.Any, ref dummy) + "</td>");
                    file.WriteLine("      <td>" + RuleItemsList2Html(rule.Service, false, CheckPointObject.Any, ref dummy) + "</td>");
                    file.WriteLine("      <td class='" + actionStyle + "'>" + action + "</td>");
                    file.WriteLine("      <td>" + rule.Track.ToString() + "</td>");
                    file.WriteLine("      <td>" + rule.Comments + "</td>");
                    file.WriteLine("      <td>" + rule.ConversionComments + "</td>");
                    file.WriteLine("  </tr>");

                    if (isSubPolicy)
                    {
                        foreach (CheckPoint_Layer subPolicy in package.SubPolicies)
                        {
                            int subRuleNumber = 1;

                            foreach (CheckPoint_Rule subRule in subPolicy.Rules)
                            {
                                if (subRule.Layer == rule.SubPolicyName)
                                {
                                    bool isSubSubPolicy = false;
                                    string subAction = "";
                                    string subActionStyle = "";

                                    switch (subRule.Action)
                                    {
                                        case CheckPoint_Rule.ActionType.Accept:
                                        case CheckPoint_Rule.ActionType.Drop:
                                        case CheckPoint_Rule.ActionType.Reject:
                                            subAction = subRule.Action.ToString();
                                            subActionStyle = subRule.Action.ToString().ToLower();
                                            break;

                                        case CheckPoint_Rule.ActionType.SubPolicy:
                                            isSubSubPolicy = true;
                                            subAction = "Sub-policy: " + subRule.SubPolicyName;
                                            subActionStyle = "";
                                            break;
                                    }
									
                                    var ruleConversionIncidentType = ConversionIncidentType.None;
                                    string curRuleNumber = ruleNumber + "." + subRuleNumber;
                                    string curRuleId = ruleIdPrefix + curRuleNumber;

                                    if (subRule.Enabled)
                                    {
                                        file.WriteLine("  <tr id=\"" + curRuleId + "\">");
                                    }
                                    else
                                    {
                                        file.WriteLine("  <tr class='disabled_rule' id=\"" + curRuleId + "\">");
                                    }

                                    var sbCurRuleNumberColumnTag = new StringBuilder();
                                    sbCurRuleNumberColumnTag.Append("      <td class='indent_rule_number'/>");
                                    if (isSubSubPolicy)
                                    {
                                        sbCurRuleNumberColumnTag.Append("      <td class='rule_number' colspan='2' onclick='toggleSubRules(this)'>" + 
                                            string.Format(HtmlSubPolicyArrowImageTagFormat, curRuleId + "_img", HtmlDownArrowImageSourceData) + curRuleNumber);
                                    }
                                    else
                                    {
                                        sbCurRuleNumberColumnTag.Append("      <td class='rule_number' colspan='2'>");
                                        sbCurRuleNumberColumnTag.Append(curRuleNumber);
                                    }
                                    if (subRule.ConversionIncidentType != ConversionIncidentType.None)
                                    {
                                        sbCurRuleNumberColumnTag.Append(BuildConversionIncidentLinkTag(subRule.ConvertedCommandId));
                                        ruleConversionIncidentType = subRule.ConversionIncidentType;
                                    }
                                    if (!subRule.Enabled)
                                    {
                                        sbCurRuleNumberColumnTag.Append(HtmlDisabledImageTag);
                                    }
                                    sbCurRuleNumberColumnTag.Append("</td>");
                                    file.WriteLine(sbCurRuleNumberColumnTag.ToString());

                                    file.WriteLine("      <td>" + subRule.Name + "</td>");
                                    file.WriteLine("      <td>" + RuleItemsList2Html(subRule.Source, subRule.SourceNegated, CheckPointObject.Any, ref ruleConversionIncidentType) + "</td>");
                                    file.WriteLine("      <td>" + RuleItemsList2Html(subRule.Destination, subRule.DestinationNegated, CheckPointObject.Any, ref ruleConversionIncidentType) + "</td>");
                                    file.WriteLine("      <td>" + RuleItemsList2Html(subRule.Service, false, CheckPointObject.Any, ref ruleConversionIncidentType) + "</td>");
                                    file.WriteLine("      <td class='" + subActionStyle + "'>" + subAction + "</td>");
                                    file.WriteLine("      <td>" + subRule.Track.ToString() + "</td>");
                                    file.WriteLine("      <td class='comments'>" + subRule.Comments + "</td>");
                                    file.WriteLine("      <td class='comments'>" + subRule.ConversionComments + "</td>");
                                    file.WriteLine("  </tr>");

                                    if(isSubSubPolicy)
                                    {
                                        foreach (CheckPoint_Layer subSubPolicy in package.SubPolicies)
                                        {
                                            int subSubRuleNumber = 1;

                                            foreach (CheckPoint_Rule subSubRule in subSubPolicy.Rules)
                                            {
                                                if (subSubRule.Layer == subRule.SubPolicyName)
                                                {
                                                    var subRuleConversionIncidentType = ConversionIncidentType.None;
                                                    string subCurRuleNumber = ruleNumber + "." + subRuleNumber + "." + subSubRuleNumber;
                                                    string subCurRuleId = ruleIdPrefix + subCurRuleNumber;

                                                    if (subSubRule.Enabled)
                                                    {
                                                        file.WriteLine("  <tr id=\"" + subCurRuleId + "\">");
                                                    }
                                                    else
                                                    {
                                                        file.WriteLine("  <tr class='disabled_rule' id=\"" + subCurRuleId + "\">");
                                                    }

                                                    var sbSubCurRuleNumberColumnTag = new StringBuilder();
                                                    sbSubCurRuleNumberColumnTag.Append("      <td class='indent_rule_number'/>");
                                                    sbSubCurRuleNumberColumnTag.Append("      <td class='indent_rule_number'/>");
                                                    sbSubCurRuleNumberColumnTag.Append("      <td class='rule_number'>");
                                                    sbSubCurRuleNumberColumnTag.Append(subCurRuleNumber);
                                                    if (subSubRule.ConversionIncidentType != ConversionIncidentType.None)
                                                    {
                                                        sbSubCurRuleNumberColumnTag.Append(BuildConversionIncidentLinkTag(subSubRule.ConvertedCommandId));
                                                        subRuleConversionIncidentType = subSubRule.ConversionIncidentType;
                                                    }
                                                    if (!subSubRule.Enabled)
                                                    {
                                                        sbSubCurRuleNumberColumnTag.Append(HtmlDisabledImageTag);
                                                    }
                                                    sbSubCurRuleNumberColumnTag.Append("</td>");
                                                    file.WriteLine(sbSubCurRuleNumberColumnTag.ToString());

                                                    file.WriteLine("      <td>" + subSubRule.Name + "</td>");
                                                    file.WriteLine("      <td>" + RuleItemsList2Html(subSubRule.Source, subSubRule.SourceNegated, CheckPointObject.Any, ref subRuleConversionIncidentType) + "</td>");
                                                    file.WriteLine("      <td>" + RuleItemsList2Html(subSubRule.Destination, subSubRule.DestinationNegated, CheckPointObject.Any, ref subRuleConversionIncidentType) + "</td>");
                                                    file.WriteLine("      <td>" + RuleItemsList2Html(subSubRule.Service, false, CheckPointObject.Any, ref subRuleConversionIncidentType) + "</td>");
                                                    file.WriteLine("      <td class='" + subSubRule.Action.ToString().ToLower() + "'>" + subSubRule.Action.ToString() + "</td>");
                                                    file.WriteLine("      <td>" + subSubRule.Track.ToString() + "</td>");
                                                    file.WriteLine("      <td class='comments'>" + subSubRule.Comments + "</td>");
                                                    file.WriteLine("      <td class='comments'>" + subSubRule.ConversionComments + "</td>");
                                                    file.WriteLine("  </tr>");

                                                    subSubRuleNumber++;

                                                    if (package.ConversionIncidentType != ConversionIncidentType.None && subRuleConversionIncidentType != ConversionIncidentType.None)
                                                    {
                                                        if (subRuleConversionIncidentType == ConversionIncidentType.ManualActionRequired)
                                                        {
                                                            rulesWithConversionErrors.Add(subCurRuleId, subSubRule);
                                                        }
                                                        else
                                                        {
                                                            rulesWithConversionInfos.Add(subCurRuleId, subSubRule);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
									
                                    subRuleNumber++;

                                    if (package.ConversionIncidentType != ConversionIncidentType.None && ruleConversionIncidentType != ConversionIncidentType.None)
                                    {
                                        if (ruleConversionIncidentType == ConversionIncidentType.ManualActionRequired)
                                        {
                                            rulesWithConversionErrors.Add(curRuleId, subRule);
                                        }
                                        else
                                        {
                                            rulesWithConversionInfos.Add(curRuleId, subRule);
                                        }
                                    }
                                }
                            }
                        }
                    }

                    ruleNumber++;
                }

                file.WriteLine("</table>");

                if (rulesWithConversionErrors.Count > 0 || rulesWithConversionInfos.Count > 0)
                {
                    file.WriteLine("<div id=\"PolicyConversionIncidents\" style='margin-left: 20px;'><h2>Policy Conversion Issues</h2></div>");
                }

                // Generate the errors report
                if (rulesWithConversionErrors.Count > 0)
                {
                    file.WriteLine("<script>");
                    file.WriteLine("   errorsCounter = " + rulesWithConversionErrors.Count + ";");
                    file.WriteLine("</script>");

                    file.WriteLine("<div id=\"PolicyConversionErrors\" style='margin-left: 20px;'><h3>Conversion Errors</h3></div>");
                    file.WriteLine("<table style='background-color: rgb(255,255,150);'>");
                    file.WriteLine("   <tr>");
                    file.WriteLine("      <th class='errors_header'>No.</th> <th class='errors_header'>Name</th> <th class='errors_header'>Source</th> <th class='errors_header'>Destination</th> <th class='errors_header'>Service</th> <th class='errors_header'>Action</th> <th class='errors_header'>Track</th> <th class='errors_header'>Comments</th> <th class='errors_header'>Conversion Comments</th>");
                    file.WriteLine("   </tr>");

                    foreach (var ruleEntry in rulesWithConversionErrors)
                    {
                        var dummy = ConversionIncidentType.None;

                        if (ruleEntry.Value.Enabled)
                        {
                            file.WriteLine("  <tr>");
                        }
                        else
                        {
                            file.WriteLine("  <tr class='disabled_rule'>");
                        }

                        var sbCurRuleNumberColumnTag = new StringBuilder();
                        sbCurRuleNumberColumnTag.Append("      <td class='rule_number'>");
                        sbCurRuleNumberColumnTag.Append("<a href=\"#");
                        sbCurRuleNumberColumnTag.Append(ruleEntry.Key);
                        sbCurRuleNumberColumnTag.Append("\">");
                        sbCurRuleNumberColumnTag.Append(ruleEntry.Key.Replace(ruleIdPrefix, ""));
                        sbCurRuleNumberColumnTag.Append("</a>");
                        if (ruleEntry.Value.ConversionIncidentType != ConversionIncidentType.None)
                        {
                            sbCurRuleNumberColumnTag.Append(BuildConversionIncidentLinkTag(ruleEntry.Value.ConvertedCommandId));
                        }
                        if (!ruleEntry.Value.Enabled)
                        {
                            sbCurRuleNumberColumnTag.Append(HtmlDisabledImageTag);
                        }
                        sbCurRuleNumberColumnTag.Append("</td>");
                        file.WriteLine(sbCurRuleNumberColumnTag.ToString());

                        file.WriteLine("      <td>" + ruleEntry.Value.Name + "</td>");
                        file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Source, ruleEntry.Value.SourceNegated, CheckPointObject.Any, ref dummy) + "</td>");
                        file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Destination, ruleEntry.Value.DestinationNegated, CheckPointObject.Any, ref dummy) + "</td>");
                        file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Service, false, CheckPointObject.Any, ref dummy) + "</td>");
                        file.WriteLine("      <td class='" + ruleEntry.Value.Action.ToString().ToLower() + "'>" + ruleEntry.Value.Action.ToString() + "</td>");
                        file.WriteLine("      <td>" + ruleEntry.Value.Track.ToString() + "</td>");
                        file.WriteLine("      <td class='comments'>" + ruleEntry.Value.Comments + "</td>");
                        file.WriteLine("      <td class='comments'>" + ruleEntry.Value.ConversionComments + "</td>");
                        file.WriteLine("  </tr>");
                    }

                    file.WriteLine("</table>");
                }

                if (rulesWithConversionInfos.Count > 0)
                {
                    file.WriteLine("<script>");
                    file.WriteLine("   infosCounter = " + rulesWithConversionInfos.Count + ";");
                    file.WriteLine("</script>");
                    file.WriteLine("<div id=\"PolicyConversionInfos\" style='margin-left: 20px;'><h3>Conversion Notifications</h3></div>");
                }

                // Generate the information report
                if (rulesWithConversionInfos.Count > 0)
                {
                    file.WriteLine("<table style='background-color: rgb(220,240,247);'>");
                    file.WriteLine("   <tr>");
                    file.WriteLine("      <th class='errors_header'>No.</th> <th class='errors_header'>Name</th> <th class='errors_header'>Source</th> <th class='errors_header'>Destination</th> <th class='errors_header'>Service</th> <th class='errors_header'>Action</th> <th class='errors_header'>Track</th> <th class='errors_header'>Comments</th> <th class='errors_header'>Conversion Comments</th>");
                    file.WriteLine("   </tr>");

                    foreach (var ruleEntry in rulesWithConversionInfos)
                    {
                        var dummy = ConversionIncidentType.None;

                        if (ruleEntry.Value.Enabled)
                        {
                            file.WriteLine("  <tr>");
                        }
                        else
                        {
                            file.WriteLine("  <tr class='disabled_rule'>");
                        }

                        var sbCurRuleNumberColumnTag = new StringBuilder();
                        sbCurRuleNumberColumnTag.Append("      <td class='rule_number'>");
                        sbCurRuleNumberColumnTag.Append("<a href=\"#");
                        sbCurRuleNumberColumnTag.Append(ruleEntry.Key);
                        sbCurRuleNumberColumnTag.Append("\">");
                        sbCurRuleNumberColumnTag.Append(ruleEntry.Key.Replace(ruleIdPrefix, ""));
                        sbCurRuleNumberColumnTag.Append("</a>");
                        if (ruleEntry.Value.ConversionIncidentType != ConversionIncidentType.None)
                        {
                            sbCurRuleNumberColumnTag.Append(BuildConversionIncidentLinkTag(ruleEntry.Value.ConvertedCommandId));
                        }
                        if (!ruleEntry.Value.Enabled)
                        {
                            sbCurRuleNumberColumnTag.Append(HtmlDisabledImageTag);
                        }
                        sbCurRuleNumberColumnTag.Append("</td>");
                        file.WriteLine(sbCurRuleNumberColumnTag.ToString());

                        file.WriteLine("      <td>" + ruleEntry.Value.Name + "</td>");
                        file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Source, ruleEntry.Value.SourceNegated, CheckPointObject.Any, ref dummy) + "</td>");
                        file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Destination, ruleEntry.Value.DestinationNegated, CheckPointObject.Any, ref dummy) + "</td>");
                        file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Service, false, CheckPointObject.Any, ref dummy) + "</td>");
                        file.WriteLine("      <td class='" + ruleEntry.Value.Action.ToString().ToLower() + "'>" + ruleEntry.Value.Action.ToString() + "</td>");
                        file.WriteLine("      <td>" + ruleEntry.Value.Track.ToString() + "</td>");
                        file.WriteLine("      <td class='comments'>" + ruleEntry.Value.Comments + "</td>");
                        file.WriteLine("      <td class='comments'>" + ruleEntry.Value.ConversionComments + "</td>");
                        file.WriteLine("  </tr>");
                    }

                    file.WriteLine("</table>");
                }

                file.WriteLine("</body>");
                file.WriteLine("</html>");
            }
        }

        #endregion
    }
}
