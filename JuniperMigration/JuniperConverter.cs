/********************************************************************
Copyright (c) 2017, Check Point Software Technologies Ltd.
All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
********************************************************************/

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Text;
using System.Globalization;
using CheckPointObjects;
using CommonUtils;
using MigrationBase;
using System.Threading;
using static CheckPointObjects.CheckPoint_Rule;

namespace JuniperMigration
{
    /// <summary>
    /// Converts Juniper SRX objects repository into Check Point objects repository.
    /// Generates conversion reports for objects and policy packages.
    /// </summary>
    public class JuniperConverter : VendorConverter
    {
        #region GUI params

        public bool SkipUnusedObjects { get; set; } //check if Optimized configuration is requested

        #endregion

        #region Helper Classes

        private class DuplicateNameInfo
        {
            public bool IsJuniperApplicationFromTerm { get; set; }
            public bool IsCPPredefinedName { get; private set; }
            public List<string> Zones { get; private set; }

            public DuplicateNameInfo(bool isCPPredefinedName)
            {
                IsJuniperApplicationFromTerm = false;
                IsCPPredefinedName = isCPPredefinedName;
                Zones = new List<string>();
            }
        }

        private static class NetworkObjectNameGenerator
        {
            private static int _networkGroupNamecounter;

            public static string AutoGeneratedNetworkName(Subnet subnet)
            {
                return subnet.IsHost()
                           ? "host_" + subnet.IpAddress
                           : "network_" + subnet.IpAddress + "_" + NetworkUtils.GetMaskLength(subnet.Netmask);
            }

            public static string AutoGeneratedNetworkGroupName()
            {
                return string.Format("network_group_{0}", ++_networkGroupNamecounter);
            }
        }

        private static class CheckPointServiceObjectsFactory
        {
            public static CheckPointObject CreateServiceObj(CheckPointObjectsRepository cpObjects, string sProtocol, string sPort, out bool alreadyExists)
            {
                alreadyExists = false;

                string serviceName;

                switch (sProtocol)
                {
                    case "tcp":
                        serviceName = "TCP_" + sPort;
                        break;

                    case "udp":
                        serviceName = "UDP_" + sPort;
                        break;

                    case "sctp":
                        serviceName = "SCTP_" + sPort;   // dummy, just for the flow...
                        break;

                    case "other":
                        serviceName = "OTHER_" + sPort;
                        break;

                    default:
                        return null;
                }

                bool serviceFound = false;
                serviceName = cpObjects.GetKnownServiceName(serviceName, out serviceFound);

                if (serviceFound || cpObjects.HasObject(serviceName))
                {
                    alreadyExists = true;
                    return cpObjects.GetObject(serviceName);
                }

                CheckPointObject serviceObj;

                switch (sProtocol)
                {
                    case "tcp":
                        serviceObj = new CheckPoint_TcpService();
                        ((CheckPoint_TcpService)serviceObj).Port = sPort;
                        break;
                    case "udp":
                        serviceObj = new CheckPoint_UdpService();
                        ((CheckPoint_UdpService)serviceObj).Port = sPort;
                        break;
                    case "sctp":
                        serviceObj = new CheckPoint_SctpService();
                        ((CheckPoint_SctpService)serviceObj).Port = sPort;
                        break;
                    default:   // "other"
                        serviceObj = new CheckPoint_OtherService();
                        ((CheckPoint_OtherService)serviceObj).IpProtocol = sPort;
                        break;
                }

                serviceObj.Name = serviceName;
                return serviceObj;
            }
        }

        private class JuniperNatCustomData
        {
            // Traffic matching priority according to rule-set's from/to values.
            public enum RulePriority
            {
                StaticInterface = 1,
                StaticZone,
                DestinationInterface,
                DestinationZone,
                SourceInterface2Interface,
                SourceMixed,
                SourceZone2Zone
            };

            public RulePriority Priority { get; set; }
            public bool IsStaticMirrorRule { get; set; }
            public List<string> SourceZonesOrInterfaces = new List<string>();
        }
        
        #endregion

        #region Private Members

        private JuniperParser _juniperParser;

        private Dictionary<string, DuplicateNameInfo> _duplicateNamesLookup = new Dictionary<string, DuplicateNameInfo>(StringComparer.InvariantCultureIgnoreCase);
        private Dictionary<string, string> _juniper2CheckpointServiceDuplicates = new Dictionary<string, string>();
        private Dictionary<string, string> _juniperInvalidApplicationsReferences = new Dictionary<string, string>();
        private Dictionary<string, List<IPNetwork>> _juniperInterfacesTopology = new Dictionary<string, List<IPNetwork>>();
        private List<string> _cpUnsafeNames = new List<string>();
        private List<string> _cpServiceInvalidNames = new List<string>();
        private List<string> _policyZonesLookup = new List<string>();
        private List<CheckPointObject> _cpNetworkObjectsInMultipleZones = new List<CheckPointObject>();
        private List<CheckPoint_NAT_Rule> _cpPreorderedNatRules = new List<CheckPoint_NAT_Rule>();
        private Dictionary<int, List<CheckPoint_Rule>> _natMatchedFirewallRules = new Dictionary<int, List<CheckPoint_Rule>>();
        private Dictionary<string, CheckPointObject> _usedNetObjects = new Dictionary<string, CheckPointObject>();
        private Dictionary<string, HashSet<string>> _usedObjects = new Dictionary<string, HashSet<string>>(); //<type, [names of objects]>
        private string _outputFormat;

        private List<string> _errorsList = new List<string>(); //storing conversion errors for config
        private List<string> _warningsList = new List<string>(); //storing conversion warnings for config

        //if total package name over max count of chars (20) do not create *.sh, *.tar.gz, *.zip files
        private bool _isOverMaxLengthPackageName = false;
        private int _maxAllowedpackageNameLength = 20;

        private IEnumerable<JuniperObject> _juniperZones;
        public IEnumerable<JuniperObject> JuniperZones
        {
            get { return _juniperZones ?? (_juniperZones = _juniperParser.Filter("_Zone")); }
        }

        private IEnumerable<JuniperObject> _juniperInterfaces;
        private IEnumerable<JuniperObject> JuniperInterfaces
        {
            get { return _juniperInterfaces ?? (_juniperInterfaces = _juniperParser.Filter("_Interface")); }
        }

        private IEnumerable<JuniperObject> _juniperZonePolicies;
        private IEnumerable<JuniperObject> JuniperZonePolicies
        {
            get { return _juniperZonePolicies ?? (_juniperZonePolicies = _juniperParser.Filter("_ZonePolicy")); }
        }

        #endregion

        #region Private Methods

        private void BuildListOfUsedObjects(bool convertNat)
        {
            CheckPoint_Package package = Add_Package(true);

            //parent_layer
            PopulateUsedNetObjectsFromRules(package.ParentLayer.Rules);

            //sub policies
            foreach (CheckPoint_Layer layer in package.SubPolicies)
            {
                PopulateUsedNetObjectsFromRules(layer.Rules);

            }

            //NAT
            if (convertNat)
            {
                PopulateUsedNetObjectsFromNatRules();
            }

            //we may add groups with nested objects. need to add them as used recoursive, because groups can contain groups and etc.
            foreach (string key in _usedNetObjects.Keys)
            {
                BuildUsedNetObjectsRecoursive(_usedNetObjects[key].Name);
            }
        }

        private void PopulateUsedNetObjectsFromNatRules()
        {
            foreach (CheckPoint_NAT_Rule rule in _cpNatRules)
            {
                //Orig-Destination
                if (rule.Destination != null)
                {
                    if (rule.Destination.GetType() != typeof(CheckPoint_PredifinedObject))
                    {
                        if (!rule.Destination.Name.Contains("Err_in_"))
                            _usedNetObjects[rule.Destination.SafeName()] = rule.Destination;
                    }
                }

                //Orig-Service
                if (rule.Service != null)
                {
                    if (rule.Service.GetType() != typeof(CheckPoint_PredifinedObject))
                    {
                        if (!rule.Service.Name.Contains("Err_in_"))
                            _usedNetObjects[rule.Service.SafeName()] = rule.Service;
                    }
                }

                //Orig-Source
                if (rule.Source != null)
                {
                    if (rule.Source.GetType() != typeof(CheckPoint_PredifinedObject))
                    {
                        if (!rule.Source.Name.Contains("Err_in_"))
                            _usedNetObjects[rule.Source.SafeName()] = rule.Source;
                    }
                }

                //Translated-Destination
                if (rule.TranslatedDestination != null)
                {
                    if (rule.TranslatedDestination.GetType() != typeof(CheckPoint_PredifinedObject))
                    {
                        if (!rule.TranslatedDestination.Name.Contains("Err_in_"))
                            _usedNetObjects[rule.TranslatedDestination.SafeName()] = rule.TranslatedDestination;
                    }
                }

                //Translated-Service
                if (rule.TranslatedService != null)
                {
                    if (rule.TranslatedService.GetType() != typeof(CheckPoint_PredifinedObject))
                    {
                        if (!rule.TranslatedService.Name.Contains("Err_in_"))
                            _usedNetObjects[rule.TranslatedService.SafeName()] = rule.TranslatedService;
                    }
                }

                //Translated-Source
                if (rule.TranslatedSource != null)
                {
                    if (rule.TranslatedSource.GetType() != typeof(CheckPoint_PredifinedObject))
                    {
                        if (!rule.TranslatedSource.Name.Contains("Err_in_"))
                            _usedNetObjects[rule.TranslatedSource.SafeName()] = rule.TranslatedSource;
                    }
                }
            }
        }

        private void PopulateUsedNetObjectsFromRules(List<CheckPoint_Rule> rules)
        {
            foreach (CheckPoint_Rule rule in rules)
            {
                foreach (var dest in rule.Destination)
                {
                    if (dest.GetType() == typeof(CheckPoint_PredifinedObject))
                        continue;
                    else
                    {
                        if (!dest.Name.Contains("Err_in_"))
                            _usedNetObjects[dest.SafeName()] = dest;
                    }
                }

                foreach (var src in rule.Source)
                {
                    if (src.Name.StartsWith("bsr-sep-02") || src.Name.StartsWith("bsr-02.bbs"))
                    {
                        int i = 1;
                        i += 1;
                    }
                    if (src.GetType() == typeof(CheckPoint_PredifinedObject))
                        continue;
                    else
                    {
                        if (!src.Name.Contains("Err_in_"))
                            _usedNetObjects[src.SafeName()] = src;
                    }
                }

                foreach (var src in rule.Service)
                {
                    if (_usedNetObjects.Keys.Contains(src.Name))
                        continue;
                    else
                    {
                        if (!src.Name.Contains("Err_in_"))
                            _usedNetObjects[src.SafeName()] = src;
                    }
                }
            }
        }

        private void BuildUsedNetObjectsRecoursive(string checkName)
        {
            //host
            foreach (CheckPoint_Host host in _cpHosts)
            {
                //if checked name is host
                if (host.Name == checkName)
                {
                    AddUsedObject<CheckPoint_Host>(host.Name);
                    return;
                }
            }

            //network
            foreach (CheckPoint_Network net in _cpNetworks)
            {
                //if checked name is network
                if (net.Name == checkName)
                {
                    AddUsedObject<CheckPoint_Network>(checkName);
                    return;
                }
            }

            //checking on address range name
            foreach (CheckPoint_Range range in _cpRanges)
            {
                //if checked name is address range
                if (range.Name == checkName)
                {
                    AddUsedObject<CheckPoint_Range>(checkName);
                    return;
                }
            }


            //checking on net group
            foreach (CheckPoint_NetworkGroup gr in _cpNetworkGroups)
            {
                if (gr.Name == checkName)
                {
                    AddUsedObject<CheckPoint_NetworkGroup>(gr.Name);
                    //if has members
                    if (gr.Members.Count > 0)
                    {
                        foreach (string member in gr.Members)
                        {
                            BuildUsedNetObjectsRecoursive(member);
                        }
                    }
                }
            }

            //checking on address net group with exclusions
            foreach (CheckPoint_GroupWithExclusion gr in _cpGroupsWithExclusion)
            {
                if (gr.Name == checkName)
                {
                    AddUsedObject<CheckPoint_GroupWithExclusion>(gr.Name);

                    if (!string.IsNullOrEmpty(gr.Include))
                        AddUsedObject<CheckPoint_NetworkGroup>(gr.Include);
                    if (!string.IsNullOrEmpty(gr.Except))
                        AddUsedObject<CheckPoint_NetworkGroup>(gr.Except);
                    return;
                }
            }

            //checking on zone
            foreach (CheckPoint_Zone zone in _cpZones)
            {
                //if checked name is zone
                if (zone.Name == checkName)
                {
                    AddUsedObject<CheckPoint_Zone>(checkName);
                    return;
                }
            }

            //checking on TcpService
            foreach (CheckPoint_TcpService tcp in _cpTcpServices)
            {
                if (tcp.Name == checkName)
                {
                    AddUsedObject<CheckPoint_TcpService>(checkName);
                    return;
                }
            }

            //checking on UdpService
            foreach (CheckPoint_UdpService udp in _cpUdpServices)
            {
                if (udp.Name == checkName)
                {
                    AddUsedObject<CheckPoint_UdpService>(checkName);
                    return;
                }
            }

            //checking on Sctp
            foreach (CheckPoint_SctpService sctp in _cpSctpServices)
            {
                if (sctp.Name == checkName)
                {
                    AddUsedObject<CheckPoint_SctpService>(checkName);
                    return;
                }
            }

            //checking on Icmp
            foreach (CheckPoint_IcmpService icmp in _cpIcmpServices)
            {
                if (icmp.Name == checkName)
                {
                    AddUsedObject<CheckPoint_IcmpService>(checkName);
                    return;
                }
            }

            //checking on Rpc
            foreach (CheckPoint_RpcService rpc in _cpRpcServices)
            {
                if (rpc.Name == checkName)
                {
                    AddUsedObject<CheckPoint_RpcService>(checkName);
                    return;
                }
            }

            //checking on DceRpc
            foreach (CheckPoint_DceRpcService rpc in _cpDceRpcServices)
            {
                if (rpc.Name == checkName)
                {
                    AddUsedObject<CheckPoint_DceRpcService>(checkName);
                    return;
                }
            }

            //checking on Other services
            foreach (CheckPoint_OtherService os in _cpOtherServices)
            {
                if (os.Name == checkName)
                {
                    AddUsedObject<CheckPoint_OtherService>(checkName);
                    return;
                }
            }

            //checking on service group
            foreach (CheckPoint_ServiceGroup os in _cpServiceGroups)
            {
                if (os.Name == checkName)
                {
                    AddUsedObject<CheckPoint_ServiceGroup>(os.Name);
                    //if has members
                    if (os.Members.Count > 0)
                    {
                        foreach (string member in os.Members)
                        {
                            BuildUsedNetObjectsRecoursive(member);
                        }
                    }
                }
            }

            //checking on time obj
            foreach (CheckPoint_Time os in _cpTimes)
            {
                if (os.Name == checkName)
                {
                    AddUsedObject<CheckPoint_Time>(checkName);
                    return;
                }
            }

            //checking on time group
            foreach (CheckPoint_TimeGroup os in _cpTimeGroups)
            {
                if (os.Name == checkName)
                {
                    //if has members
                    if (os.Members.Count > 0)
                    {
                        foreach (string member in os.Members)
                        {
                            BuildUsedNetObjectsRecoursive(member);
                        }
                    }
                }
            }
        }

        private void CollectOnlyUsedObjects()
        {
            #region temp lists
            List<CheckPoint_Domain> newDomainsList = new List<CheckPoint_Domain>();
            List<CheckPoint_Host> newHostList = new List<CheckPoint_Host>();
            List<CheckPoint_Network> newNetList = new List<CheckPoint_Network>();
            List<CheckPoint_Range> newRangeList = new List<CheckPoint_Range>();
            List<CheckPoint_NetworkGroup> newNetworkGroups = new List<CheckPoint_NetworkGroup>();
            List<CheckPoint_GroupWithExclusion> newNetworkGroupsWI = new List<CheckPoint_GroupWithExclusion>();
            List<CheckPoint_Zone> newZoneList = new List<CheckPoint_Zone>();
            List<CheckPoint_DceRpcService> newDceList = new List<CheckPoint_DceRpcService>();
            List<CheckPoint_RpcService> newRpcList = new List<CheckPoint_RpcService>();
            List<CheckPoint_IcmpService> newIcmpList = new List<CheckPoint_IcmpService>();
            List<CheckPoint_SctpService> newSctpList = new List<CheckPoint_SctpService>();
            List<CheckPoint_UdpService> newUDPList = new List<CheckPoint_UdpService>();
            List<CheckPoint_TcpService> newTCPList = new List<CheckPoint_TcpService>();
            List<CheckPoint_OtherService> newOSList = new List<CheckPoint_OtherService>();
            List<CheckPoint_Time> newTimeList = new List<CheckPoint_Time>();
            List<CheckPoint_TimeGroup> newTimeGList = new List<CheckPoint_TimeGroup>();
            #endregion

            foreach (string typeName in _usedObjects.Keys)
            {
                switch (typeName)
                {
                    case "CheckPoint_Domain":
                        foreach (var domain in _cpDomains)
                        {
                            if (_usedObjects[typeName].Contains(domain.Name))
                                newDomainsList.Add(domain);
                        }
                        break;

                    case "CheckPoint_Host":
                        foreach (var host in _cpHosts)
                        {
                            if (_usedObjects[typeName].Contains(host.Name))
                                newHostList.Add(host);
                        }
                        break;

                    case "CheckPoint_Network":
                        foreach (var network in _cpNetworks)
                        {
                            if (_usedObjects[typeName].Contains(network.Name))
                                newNetList.Add(network);
                        }
                        break;

                    case "CheckPoint_Range":
                        foreach (var range in _cpRanges)
                        {
                            if (_usedObjects[typeName].Contains(range.Name))
                                newRangeList.Add(range);
                        }
                        break;

                    case "CheckPoint_NetworkGroup":
                        foreach (var gr in _cpNetworkGroups)
                        {
                            if (_usedObjects[typeName].Contains(gr.Name))
                                newNetworkGroups.Add(gr);
                        }
                        break;

                    case "CheckPoint_GroupWithExclusion":
                        foreach (var gr in _cpGroupsWithExclusion)
                        {
                            if (_usedObjects[typeName].Contains(gr.Name))
                                newNetworkGroupsWI.Add(gr);
                        }
                        break;

                    case "CheckPoint_Zone":
                        foreach (var zone in _cpZones)
                        {
                            if (_usedObjects[typeName].Contains(zone.Name))
                                newZoneList.Add(zone);
                        }
                        break;

                    case "CheckPoint_DceRpcService":
                        foreach (var dce in _cpDceRpcServices)
                        {
                            if (_usedObjects[typeName].Contains(dce.Name))
                                newDceList.Add(dce);
                        }
                        break;

                    case "CheckPoint_RpcService":
                        foreach (var rpc in _cpRpcServices)
                        {
                            if (_usedObjects[typeName].Contains(rpc.Name))
                                newRpcList.Add(rpc);
                        }
                        break;

                    case "CheckPoint_IcmpService":
                        foreach (var icmp in _cpIcmpServices)
                        {
                            if (_usedObjects[typeName].Contains(icmp.Name))
                                newIcmpList.Add(icmp);
                        }
                        break;

                    case "CheckPoint_SctpService":
                        foreach (var sctp in _cpSctpServices)
                        {
                            if (_usedObjects[typeName].Contains(sctp.Name))
                                newSctpList.Add(sctp);
                        }
                        break;

                    case "CheckPoint_UdpService":
                        foreach (var udp in _cpUdpServices)
                        {
                            if (_usedObjects[typeName].Contains(udp.Name))
                                newUDPList.Add(udp);
                        }
                        break;

                    case "CheckPoint_TcpService":
                        foreach (var os in _cpTcpServices)
                        {
                            if (_usedObjects[typeName].Contains(os.Name))
                                newTCPList.Add(os);
                        }
                        break;

                    case "CheckPoint_OtherService":
                        foreach (var os in _cpOtherServices)
                        {
                            if (_usedObjects[typeName].Contains(os.Name))
                                newOSList.Add(os);
                        }
                        break;

                    case "CheckPoint_Time":
                        foreach (var time in _cpTimes)
                        {
                            if (_usedObjects[typeName].Contains(time.Name))
                                newTimeList.Add(time);
                        }
                        break;

                    case "CheckPoint_TimeGroup":
                        foreach (var time in _cpTimeGroups)
                        {
                            if (_usedObjects[typeName].Contains(time.Name))
                                newTimeGList.Add(time);
                        }
                        break;
                }

            }

            _cpDomains = newDomainsList;
            _cpHosts = newHostList;
            _cpNetworks = newNetList;
            _cpRanges = newRangeList;
            _cpNetworkGroups = newNetworkGroups;
            _cpGroupsWithExclusion = newNetworkGroupsWI;
            _cpZones = newZoneList;
            _cpDceRpcServices = newDceList;
            _cpRpcServices = newRpcList;
            _cpIcmpServices = newIcmpList;
            _cpSctpServices = newSctpList;
            _cpUdpServices = newUDPList;
            _cpTcpServices = newTCPList;
            _cpOtherServices = newOSList;
            _cpServiceGroups = new List<CheckPoint_ServiceGroup>();
            _cpTimes = newTimeList;
            _cpTimeGroups = newTimeGList;
        }

        private void AddUsedObject<T>(string name)
        {
            if (!_usedObjects.Keys.Contains(typeof(T).ToString().Split('.').Last()))
                _usedObjects[typeof(T).ToString().Split('.').Last()] = new HashSet<string>();
            _usedObjects[typeof(T).ToString().Split('.').Last()].Add(Validators.ChangeNameAccordingToRules(name));
        }

        protected override bool AddCheckPointObject(CheckPointObject cpObject)
        {
            if (base.AddCheckPointObject(cpObject))
            {
                string vendor = Vendor.JuniperJunosOS.ToString();
                if (!cpObject.Tags.Contains(vendor))
                {
                    cpObject.Tags.Add(vendor);
                }
            }

            return false;
        }

        private void Add_Optimized_Package()
        {
            CheckPoint_Package regularPackage = _cpPackages[0];

            var optimizedPackage = new CheckPoint_Package();
            string checkOptimizedName = _policyPackageOptimizedName.Replace("_policy_opt", "_opt");
            string pckg_name = checkOptimizedName.Replace("_opt", "");
            if (pckg_name.Length > _maxAllowedpackageNameLength)
            {
                _isOverMaxLengthPackageName = true;
                _conversionIncidents.Add(new ConversionIncident(0, "max length exceeded", "Package " + pckg_name + " has name length more then " + _maxAllowedpackageNameLength + " chars", ConversionIncidentType.ManualActionRequired));
            }
            optimizedPackage.Name = _policyPackageOptimizedName;
            optimizedPackage.ParentLayer.Name = optimizedPackage.NameOfAccessLayer;
            optimizedPackage.ConversionIncidentType = regularPackage.ConversionIncidentType;

            var regular2OptimizedLayers = new Dictionary<string, string>();

            foreach (CheckPoint_Layer layer in regularPackage.SubPolicies)
            {
                string optimizedSubPolicyName = layer.Name + "_opt";

                CheckPoint_Layer optimizedLayer = RuleBaseOptimizer.Optimize(layer, optimizedSubPolicyName);
                foreach (CheckPoint_Rule subSubRule in optimizedLayer.Rules)
                {
                    if (subSubRule.SubPolicyName.Equals(GlobalRulesSubpolicyName))
                    {
                        //The Global sub-sub rule subpolicy name should also be renamed for consistency
                        subSubRule.SubPolicyName += "_opt";
                    }
                }
                if (!regular2OptimizedLayers.ContainsKey(layer.Name))
                {
                    regular2OptimizedLayers.Add(layer.Name, optimizedSubPolicyName);
                    optimizedPackage.SubPolicies.Add(optimizedLayer);
                    validatePackage(optimizedPackage);
                }
            }

            foreach (CheckPoint_Rule rule in regularPackage.ParentLayer.Rules)
            {
                CheckPoint_Rule newRule = rule.Clone();
                if (newRule.Action == CheckPoint_Rule.ActionType.SubPolicy)
                {
                    newRule.SubPolicyName = regular2OptimizedLayers[rule.SubPolicyName];
                }
                newRule.Layer = optimizedPackage.ParentLayer.Name;
                newRule.ConversionComments = rule.ConversionComments;

                optimizedPackage.ParentLayer.Rules.Add(newRule);
            }

            AddCheckPointObject(optimizedPackage);
        }

        private void ExportPackageAsHtml(CheckPoint_Package package)
        {
            const string ruleIdPrefix = "rule_";
            package.Name = (package.Name.Contains("_opt") && !package.Name.Contains("_policy_opt")) ? package.Name.Replace("_opt", "_policy_opt") : package.Name;
            string filename = _targetFolder + "\\" + package.Name + ".html";

            using (var file = new StreamWriter(filename, false))
            {
                var rulesWithConversionErrors = new Dictionary<string, CheckPoint_Rule>();
                var rulesWithConversionInfos = new Dictionary<string, CheckPoint_Rule>();

                GeneratePackageHtmlReportHeaders(file, package.Name, package.ConversionIncidentType != ConversionIncidentType.None);

                // Generate the report body
                file.WriteLine("<table>");
                file.WriteLine("   <tr>");
                file.WriteLine("      <th colspan='3'>No.</th> <th>Name</th> <th>Source</th> <th>Destination</th> <th>Service</th> <th>Action</th> <th>Track</th> <th>Comments</th> <th>Conversion Comments</th>");
                file.WriteLine("   </tr>");

                int ruleNumber = 1;

                foreach (CheckPoint_Rule rule in package.ParentLayer.Rules)
                {
                    bool isSubPolicy = false;
                    string action = "";
                    string actionStyle = "";
                    var dummy = ConversionIncidentType.None;

                    switch (rule.Action)
                    {
                        case CheckPoint_Rule.ActionType.Accept:
                        case CheckPoint_Rule.ActionType.Drop:
                        case CheckPoint_Rule.ActionType.Reject:
                            action = rule.Action.ToString();
                            actionStyle = rule.Action.ToString().ToLower();
                            break;

                        case CheckPoint_Rule.ActionType.SubPolicy:
                            isSubPolicy = true;
                            action = "Sub-policy: " + rule.SubPolicyName;
                            actionStyle = "";
                            break;
                    }

                    string curParentRuleId = string.Format("{0}{1}", ruleIdPrefix, ruleNumber);

                    if (rule.Enabled)
                    {
                        file.WriteLine("  <tr class='parent_rule' id=\"" + curParentRuleId + "\">");
                        if (isSubPolicy)
                        {
                            file.WriteLine("      <td class='rule_number' colspan='3' onclick='toggleSubRules(this)'>" +
                                string.Format(HtmlSubPolicyArrowImageTagFormat, curParentRuleId + "_img", HtmlDownArrowImageSourceData) + ruleNumber + "</td>");
                        }
                        else
                        {
                            file.WriteLine("      <td class='rule_number' colspan='3' style='padding-left:22px;'>" + ruleNumber + "</td>");
                        }
                    }
                    else
                    {
                        file.WriteLine("  <tr class='parent_rule_disabled' id=\"" + curParentRuleId + "\">");
                        if (isSubPolicy)
                        {
                            file.WriteLine("      <td class='rule_number' colspan='3' onclick='toggleSubRules(this)'>" +
                                string.Format(HtmlSubPolicyArrowImageTagFormat, curParentRuleId + "_img", HtmlDownArrowImageSourceData) + ruleNumber + HtmlDisabledImageTag + "</td>");
                        }
                        else
                        {
                            file.WriteLine("      <td class='rule_number' colspan='3' style='padding-left:22px;'>" + ruleNumber + HtmlDisabledImageTag + "</td>");
                        }
                    }
                    file.WriteLine("      <td>" + rule.Name + "</td>");
                    file.WriteLine("      <td>" + RuleItemsList2Html(rule.Source, rule.SourceNegated, CheckPointObject.Any, ref dummy) + "</td>");
                    file.WriteLine("      <td>" + RuleItemsList2Html(rule.Destination, rule.DestinationNegated, CheckPointObject.Any, ref dummy) + "</td>");
                    file.WriteLine("      <td>" + RuleItemsList2Html(rule.Service, false, CheckPointObject.Any, ref dummy) + "</td>");
                    file.WriteLine("      <td class='" + actionStyle + "'>" + action + "</td>");
                    file.WriteLine("      <td>" + rule.Track.ToString() + "</td>");
                    file.WriteLine("      <td>" + rule.Comments + "</td>");
                    file.WriteLine("      <td>" + rule.ConversionComments + "</td>");
                    file.WriteLine("  </tr>");

                    if (isSubPolicy)
                    {
                        foreach (CheckPoint_Layer subPolicy in package.SubPolicies)
                        {
                            int subRuleNumber = 1;

                            foreach (CheckPoint_Rule subRule in subPolicy.Rules)
                            {
                                if (subRule.Layer == rule.SubPolicyName)
                                {
                                    bool isSubSubPolicy = false;
                                    string subAction = "";
                                    string subActionStyle = "";

                                    switch (subRule.Action)
                                    {
                                        case CheckPoint_Rule.ActionType.Accept:
                                        case CheckPoint_Rule.ActionType.Drop:
                                        case CheckPoint_Rule.ActionType.Reject:
                                            subAction = subRule.Action.ToString();
                                            subActionStyle = subRule.Action.ToString().ToLower();
                                            break;

                                        case CheckPoint_Rule.ActionType.SubPolicy:
                                            isSubSubPolicy = true;
                                            subAction = "Sub-policy: " + subRule.SubPolicyName;
                                            subActionStyle = "";
                                            break;
                                    }

                                    var ruleConversionIncidentType = ConversionIncidentType.None;
                                    string curRuleNumber = ruleNumber + "." + subRuleNumber;
                                    string curRuleId = ruleIdPrefix + curRuleNumber;

                                    if (subRule.Enabled)
                                    {
                                        file.WriteLine("  <tr id=\"" + curRuleId + "\">");
                                    }
                                    else
                                    {
                                        file.WriteLine("  <tr class='disabled_rule' id=\"" + curRuleId + "\">");
                                    }

                                    var sbCurRuleNumberColumnTag = new StringBuilder();
                                    sbCurRuleNumberColumnTag.Append("      <td class='indent_rule_number'/>");
                                    if (isSubSubPolicy)
                                    {
                                        sbCurRuleNumberColumnTag.Append("      <td class='rule_number' colspan='2' onclick='toggleSubRules(this)'>" +
                                            string.Format(HtmlSubPolicyArrowImageTagFormat, curRuleId + "_img", HtmlDownArrowImageSourceData) + curRuleNumber);
                                    }
                                    else
                                    {
                                        sbCurRuleNumberColumnTag.Append("      <td class='rule_number' colspan='2'>");
                                        sbCurRuleNumberColumnTag.Append(curRuleNumber);
                                    }
                                    if (subRule.ConversionIncidentType != ConversionIncidentType.None)
                                    {
                                        sbCurRuleNumberColumnTag.Append(BuildConversionIncidentLinkTag(subRule.ConvertedCommandId));
                                        ruleConversionIncidentType = subRule.ConversionIncidentType;
                                    }
                                    if (!subRule.Enabled)
                                    {
                                        sbCurRuleNumberColumnTag.Append(HtmlDisabledImageTag);
                                    }
                                    sbCurRuleNumberColumnTag.Append("</td>");
                                    file.WriteLine(sbCurRuleNumberColumnTag.ToString());

                                    file.WriteLine("      <td>" + subRule.Name + "</td>");
                                    file.WriteLine("      <td>" + RuleItemsList2Html(subRule.Source, subRule.SourceNegated, CheckPointObject.Any, ref ruleConversionIncidentType) + "</td>");
                                    file.WriteLine("      <td>" + RuleItemsList2Html(subRule.Destination, subRule.DestinationNegated, CheckPointObject.Any, ref ruleConversionIncidentType) + "</td>");
                                    file.WriteLine("      <td>" + RuleItemsList2Html(subRule.Service, false, CheckPointObject.Any, ref ruleConversionIncidentType) + "</td>");
                                    file.WriteLine("      <td class='" + subActionStyle + "'>" + subAction + "</td>");
                                    file.WriteLine("      <td>" + subRule.Track.ToString() + "</td>");
                                    file.WriteLine("      <td class='comments'>" + subRule.Comments + "</td>");
                                    file.WriteLine("      <td class='comments'>" + subRule.ConversionComments + "</td>");
                                    file.WriteLine("  </tr>");

                                    if (isSubSubPolicy)
                                    {
                                        foreach (CheckPoint_Layer subSubPolicy in package.SubPolicies)
                                        {
                                            int subSubRuleNumber = 1;

                                            foreach (CheckPoint_Rule subSubRule in subSubPolicy.Rules)
                                            {
                                                if (subSubRule.Layer == subRule.SubPolicyName)
                                                {
                                                    var subRuleConversionIncidentType = ConversionIncidentType.None;
                                                    string subCurRuleNumber = ruleNumber + "." + subRuleNumber + "." + subSubRuleNumber;
                                                    string subCurRuleId = ruleIdPrefix + subCurRuleNumber;

                                                    if (subSubRule.Enabled)
                                                    {
                                                        file.WriteLine("  <tr id=\"" + subCurRuleId + "\">");
                                                    }
                                                    else
                                                    {
                                                        file.WriteLine("  <tr class='disabled_rule' id=\"" + subCurRuleId + "\">");
                                                    }

                                                    var sbSubCurRuleNumberColumnTag = new StringBuilder();
                                                    sbSubCurRuleNumberColumnTag.Append("      <td class='indent_rule_number'/>");
                                                    sbSubCurRuleNumberColumnTag.Append("      <td class='indent_rule_number'/>");
                                                    sbSubCurRuleNumberColumnTag.Append("      <td class='rule_number'>");
                                                    sbSubCurRuleNumberColumnTag.Append(subCurRuleNumber);
                                                    if (subSubRule.ConversionIncidentType != ConversionIncidentType.None)
                                                    {
                                                        sbSubCurRuleNumberColumnTag.Append(BuildConversionIncidentLinkTag(subSubRule.ConvertedCommandId));
                                                        subRuleConversionIncidentType = subSubRule.ConversionIncidentType;
                                                    }
                                                    if (!subSubRule.Enabled)
                                                    {
                                                        sbSubCurRuleNumberColumnTag.Append(HtmlDisabledImageTag);
                                                    }
                                                    sbSubCurRuleNumberColumnTag.Append("</td>");
                                                    file.WriteLine(sbSubCurRuleNumberColumnTag.ToString());

                                                    file.WriteLine("      <td>" + subSubRule.Name + "</td>");
                                                    file.WriteLine("      <td>" + RuleItemsList2Html(subSubRule.Source, subSubRule.SourceNegated, CheckPointObject.Any, ref subRuleConversionIncidentType) + "</td>");
                                                    file.WriteLine("      <td>" + RuleItemsList2Html(subSubRule.Destination, subSubRule.DestinationNegated, CheckPointObject.Any, ref subRuleConversionIncidentType) + "</td>");
                                                    file.WriteLine("      <td>" + RuleItemsList2Html(subSubRule.Service, false, CheckPointObject.Any, ref subRuleConversionIncidentType) + "</td>");
                                                    file.WriteLine("      <td class='" + subSubRule.Action.ToString().ToLower() + "'>" + subSubRule.Action.ToString() + "</td>");
                                                    file.WriteLine("      <td>" + subSubRule.Track.ToString() + "</td>");
                                                    file.WriteLine("      <td class='comments'>" + subSubRule.Comments + "</td>");
                                                    file.WriteLine("      <td class='comments'>" + subSubRule.ConversionComments + "</td>");
                                                    file.WriteLine("  </tr>");

                                                    subSubRuleNumber++;

                                                    if (package.ConversionIncidentType != ConversionIncidentType.None && subRuleConversionIncidentType != ConversionIncidentType.None)
                                                    {
                                                        if (subRuleConversionIncidentType == ConversionIncidentType.ManualActionRequired)
                                                        {
                                                            rulesWithConversionErrors.Add(subCurRuleId, subSubRule);
                                                        }
                                                        else
                                                        {
                                                            rulesWithConversionInfos.Add(subCurRuleId, subSubRule);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    subRuleNumber++;

                                    if (package.ConversionIncidentType != ConversionIncidentType.None && ruleConversionIncidentType != ConversionIncidentType.None)
                                    {
                                        if (ruleConversionIncidentType == ConversionIncidentType.ManualActionRequired)
                                        {
                                            rulesWithConversionErrors.Add(curRuleId, subRule);
                                        }
                                        else
                                        {
                                            rulesWithConversionInfos.Add(curRuleId, subRule);
                                        }
                                    }
                                }
                            }
                        }
                    }

                    ruleNumber++;
                }

                file.WriteLine("</table>");

                if (rulesWithConversionErrors.Count > 0 || rulesWithConversionInfos.Count > 0)
                {
                    file.WriteLine("<div id=\"PolicyConversionIncidents\" style='margin-left: 20px;'><h2>Policy Conversion Issues</h2></div>");
                }

                // Generate the errors report
                if (rulesWithConversionErrors.Count > 0)
                {
                    file.WriteLine("<script>");
                    file.WriteLine("   errorsCounter = " + rulesWithConversionErrors.Count + ";");
                    file.WriteLine("</script>");

                    file.WriteLine("<div id=\"PolicyConversionErrors\" style='margin-left: 20px;'><h3>Conversion Errors</h3></div>");
                    file.WriteLine("<table style='background-color: rgb(255,255,150);'>");
                    file.WriteLine("   <tr>");
                    file.WriteLine("      <th class='errors_header'>No.</th> <th class='errors_header'>Name</th> <th class='errors_header'>Source</th> <th class='errors_header'>Destination</th> <th class='errors_header'>Service</th> <th class='errors_header'>Action</th> <th class='errors_header'>Track</th> <th class='errors_header'>Comments</th> <th class='errors_header'>Conversion Comments</th>");
                    file.WriteLine("   </tr>");

                    foreach (var ruleEntry in rulesWithConversionErrors)
                    {
                        var dummy = ConversionIncidentType.None;

                        if (ruleEntry.Value.Enabled)
                        {
                            file.WriteLine("  <tr>");
                        }
                        else
                        {
                            file.WriteLine("  <tr class='disabled_rule'>");
                        }

                        var sbCurRuleNumberColumnTag = new StringBuilder();
                        sbCurRuleNumberColumnTag.Append("      <td class='rule_number'>");
                        sbCurRuleNumberColumnTag.Append("<a href=\"#");
                        sbCurRuleNumberColumnTag.Append(ruleEntry.Key);
                        sbCurRuleNumberColumnTag.Append("\">");
                        sbCurRuleNumberColumnTag.Append(ruleEntry.Key.Replace(ruleIdPrefix, ""));
                        sbCurRuleNumberColumnTag.Append("</a>");
                        if (ruleEntry.Value.ConversionIncidentType != ConversionIncidentType.None)
                        {
                            sbCurRuleNumberColumnTag.Append(BuildConversionIncidentLinkTag(ruleEntry.Value.ConvertedCommandId));
                        }
                        if (!ruleEntry.Value.Enabled)
                        {
                            sbCurRuleNumberColumnTag.Append(HtmlDisabledImageTag);
                        }
                        sbCurRuleNumberColumnTag.Append("</td>");
                        file.WriteLine(sbCurRuleNumberColumnTag.ToString());

                        file.WriteLine("      <td>" + ruleEntry.Value.Name + "</td>");
                        file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Source, ruleEntry.Value.SourceNegated, CheckPointObject.Any, ref dummy) + "</td>");
                        file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Destination, ruleEntry.Value.DestinationNegated, CheckPointObject.Any, ref dummy) + "</td>");
                        file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Service, false, CheckPointObject.Any, ref dummy) + "</td>");
                        file.WriteLine("      <td class='" + ruleEntry.Value.Action.ToString().ToLower() + "'>" + ruleEntry.Value.Action.ToString() + "</td>");
                        file.WriteLine("      <td>" + ruleEntry.Value.Track.ToString() + "</td>");
                        file.WriteLine("      <td class='comments'>" + ruleEntry.Value.Comments + "</td>");
                        file.WriteLine("      <td class='comments'>" + ruleEntry.Value.ConversionComments + "</td>");
                        file.WriteLine("  </tr>");
                    }

                    file.WriteLine("</table>");
                }

                if (rulesWithConversionInfos.Count > 0)
                {
                    file.WriteLine("<script>");
                    file.WriteLine("   infosCounter = " + rulesWithConversionInfos.Count + ";");
                    file.WriteLine("</script>");
                    file.WriteLine("<div id=\"PolicyConversionInfos\" style='margin-left: 20px;'><h3>Conversion Notifications</h3></div>");
                }

                // Generate the information report
                if (rulesWithConversionInfos.Count > 0)
                {
                    file.WriteLine("<table style='background-color: rgb(220,240,247);'>");
                    file.WriteLine("   <tr>");
                    file.WriteLine("      <th class='errors_header'>No.</th> <th class='errors_header'>Name</th> <th class='errors_header'>Source</th> <th class='errors_header'>Destination</th> <th class='errors_header'>Service</th> <th class='errors_header'>Action</th> <th class='errors_header'>Track</th> <th class='errors_header'>Comments</th> <th class='errors_header'>Conversion Comments</th>");
                    file.WriteLine("   </tr>");

                    foreach (var ruleEntry in rulesWithConversionInfos)
                    {
                        var dummy = ConversionIncidentType.None;

                        if (ruleEntry.Value.Enabled)
                        {
                            file.WriteLine("  <tr>");
                        }
                        else
                        {
                            file.WriteLine("  <tr class='disabled_rule'>");
                        }

                        var sbCurRuleNumberColumnTag = new StringBuilder();
                        sbCurRuleNumberColumnTag.Append("      <td class='rule_number'>");
                        sbCurRuleNumberColumnTag.Append("<a href=\"#");
                        sbCurRuleNumberColumnTag.Append(ruleEntry.Key);
                        sbCurRuleNumberColumnTag.Append("\">");
                        sbCurRuleNumberColumnTag.Append(ruleEntry.Key.Replace(ruleIdPrefix, ""));
                        sbCurRuleNumberColumnTag.Append("</a>");
                        if (ruleEntry.Value.ConversionIncidentType != ConversionIncidentType.None)
                        {
                            sbCurRuleNumberColumnTag.Append(BuildConversionIncidentLinkTag(ruleEntry.Value.ConvertedCommandId));
                        }
                        if (!ruleEntry.Value.Enabled)
                        {
                            sbCurRuleNumberColumnTag.Append(HtmlDisabledImageTag);
                        }
                        sbCurRuleNumberColumnTag.Append("</td>");
                        file.WriteLine(sbCurRuleNumberColumnTag.ToString());

                        file.WriteLine("      <td>" + ruleEntry.Value.Name + "</td>");
                        file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Source, ruleEntry.Value.SourceNegated, CheckPointObject.Any, ref dummy) + "</td>");
                        file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Destination, ruleEntry.Value.DestinationNegated, CheckPointObject.Any, ref dummy) + "</td>");
                        file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Service, false, CheckPointObject.Any, ref dummy) + "</td>");
                        file.WriteLine("      <td class='" + ruleEntry.Value.Action.ToString().ToLower() + "'>" + ruleEntry.Value.Action.ToString() + "</td>");
                        file.WriteLine("      <td>" + ruleEntry.Value.Track.ToString() + "</td>");
                        file.WriteLine("      <td class='comments'>" + ruleEntry.Value.Comments + "</td>");
                        file.WriteLine("      <td class='comments'>" + ruleEntry.Value.ConversionComments + "</td>");
                        file.WriteLine("  </tr>");
                    }

                    file.WriteLine("</table>");
                }

                file.WriteLine("</body>");
                file.WriteLine("</html>");
            }
        }

        private void Add_NetworkObjects()
        {
            bool inMultipleZones = false;
            var networkAndZoneNamesDuplicates = new List<CheckPointObject>();

            foreach (Juniper_Fqdn fqdn in _juniperParser.Filter("_Fqdn"))
            {
                if (string.IsNullOrEmpty(fqdn.DnsName))
                {
                    _conversionIncidents.Add(new ConversionIncident(fqdn.LineNumber,
                                                                    fqdn.ConversionIncidentMessage,
                                                                    "Fqdn details :" + fqdn.Name + ".",
                                                                    fqdn.ConversionIncidentType));
                    continue;
                }

                var cpDomain = new CheckPoint_Domain();
                cpDomain.Name = fqdn.Name;
                cpDomain.Comments = fqdn.Description;
                cpDomain.Fqdn = fqdn.DnsName;
                cpDomain.Tag = fqdn.ZoneName;
                ApplyConversionIncidentOnCheckPointObject(cpDomain, fqdn);
                inMultipleZones = IsNetworkObjectContainedInMultipleZones(cpDomain, fqdn);
                AlertOnDomainNameModification(fqdn, inMultipleZones);
                if (!inMultipleZones)
                {
                    AddCheckPointObject(cpDomain);
                }
            }

            foreach (Juniper_Host host in _juniperParser.Filter("_Host"))
            {
                var cpHost = new CheckPoint_Host();
                cpHost.Name = host.Name;
                cpHost.Comments = host.Description;
                cpHost.IpAddress = host.IpAddress;
                cpHost.Tag = host.ZoneName;
                ApplyConversionIncidentOnCheckPointObject(cpHost, host);
                inMultipleZones = IsNetworkObjectContainedInMultipleZones(cpHost, host);
                CheckObjectNameValidity(cpHost, host, inMultipleZones);
                if (!inMultipleZones)
                {
                    if (AreNetworkAndZoneNamesDuplicated(cpHost.Name))
                    {
                        networkAndZoneNamesDuplicates.Add(cpHost);
                    }
                    else
                    {
                        AddCheckPointObject(cpHost);
                    }
                }
            }

            foreach (Juniper_Network network in _juniperParser.Filter("_Network"))
            {
                var cpNetwork = new CheckPoint_Network();
                cpNetwork.Name = network.Name;
                cpNetwork.Comments = network.Description;
                cpNetwork.Subnet = network.IpAddress;
                cpNetwork.Netmask = network.Netmask;
                cpNetwork.Tag = network.ZoneName;
                ApplyConversionIncidentOnCheckPointObject(cpNetwork, network);
                inMultipleZones = IsNetworkObjectContainedInMultipleZones(cpNetwork, network);
                CheckObjectNameValidity(cpNetwork, network, inMultipleZones);
                if (!inMultipleZones)
                {
                    if (AreNetworkAndZoneNamesDuplicated(cpNetwork.Name))
                    {
                        networkAndZoneNamesDuplicates.Add(cpNetwork);
                    }
                    else
                    {
                        AddCheckPointObject(cpNetwork);
                    }
                }
            }

            foreach (Juniper_Range range in _juniperParser.Filter("_Range"))
            {
                var cpRange = new CheckPoint_Range();
                cpRange.Name = range.Name;
                cpRange.Comments = range.Description;
                cpRange.RangeFrom = range.RangeFrom;
                cpRange.RangeTo = range.RangeTo;
                cpRange.Tag = range.ZoneName;
                ApplyConversionIncidentOnCheckPointObject(cpRange, range);
                inMultipleZones = IsNetworkObjectContainedInMultipleZones(cpRange, range);
                CheckObjectNameValidity(cpRange, range, inMultipleZones);
                if (!inMultipleZones)
                {
                    if (AreNetworkAndZoneNamesDuplicated(cpRange.Name))
                    {
                        networkAndZoneNamesDuplicates.Add(cpRange);
                    }
                    else
                    {
                        AddCheckPointObject(cpRange);
                    }
                }
            }

            var groupsWithNonCreatedMembers = new List<CheckPoint_NetworkGroup>();

            foreach (Juniper_AddressGroup group in _juniperParser.Filter("_AddressGroup"))
            {
                var cpNetworkGroup = new CheckPoint_NetworkGroup();
                cpNetworkGroup.Name = group.Name;
                cpNetworkGroup.Comments = group.Description;
                cpNetworkGroup.Members.AddRange(group.Members);
                cpNetworkGroup.Members.AddRange(group.MemberGroupNames);
                cpNetworkGroup.Tag = group.ZoneName;
                ApplyConversionIncidentOnCheckPointObject(cpNetworkGroup, group);
                inMultipleZones = IsNetworkObjectContainedInMultipleZones(cpNetworkGroup, group);
                CheckObjectNameValidity(cpNetworkGroup, group, inMultipleZones);

                // Check if the member groups are already created to avoid "object not found" errors during the import to DB.
                bool hasNonCreatedMembers = false;
                if (!inMultipleZones)
                {
                    foreach (var memberGroupName in group.MemberGroupNames)
                    {
                        bool found = _cpNetworkGroups.Any(cpGroup => cpGroup.Name == memberGroupName);
                        if (!found)
                        {
                            groupsWithNonCreatedMembers.Add(cpNetworkGroup);
                            hasNonCreatedMembers = true;
                        }
                    }
                }

                if (!inMultipleZones && !hasNonCreatedMembers)
                {
                    AddCheckPointObject(cpNetworkGroup);
                }
            }

            // Now, add the objects with the same name that exist in multiple zones.
            foreach (var cpNetworkObject in _cpNetworkObjectsInMultipleZones)
            {
                string originalName = cpNetworkObject.Name;
                string uniqueName = originalName + "_" + cpNetworkObject.Tag;   // original name combined with the zone name
                cpNetworkObject.Name = uniqueName;   // replace the original name with the unique one
                AddCheckPointObject(cpNetworkObject);
            }

            // Add the network objects that have name duplication with zones names.
            foreach (var cpNetworkObject in networkAndZoneNamesDuplicates)
            {
                string originalName = cpNetworkObject.Name;
                string uniqueName = originalName + "_" + cpNetworkObject.Tag;   // original name combined with the zone name
                cpNetworkObject.Name = uniqueName;   // replace the original name with the unique one
                AddCheckPointObject(cpNetworkObject);
            }

            // After all groups are created, add the groups that had non created member groups.
            foreach (var networkGroup in groupsWithNonCreatedMembers)
            {
                AddCheckPointObject(networkGroup);
            }

            // Finally, search and update references in network groups, AFTER all objects are added.
            foreach (var cpNetworkObject in _cpNetworkObjectsInMultipleZones)
            {
                foreach (var networkGroup in _cpNetworkGroups)
                {
                    if (cpNetworkObject.Tag == networkGroup.Tag)   // search in the same zone only...
                    {
                        string zoneSuffix = "_" + cpNetworkObject.Tag;
                        string originalName = cpNetworkObject.Name.Replace(zoneSuffix, "");
                        int pos = networkGroup.Members.IndexOf(originalName);
                        if (pos != -1)
                        {
                            networkGroup.Members[pos] = cpNetworkObject.Name;
                        }
                    }
                }
            }

            // Apply the same for the network objects that have name duplication with zones names.
            foreach (var cpNetworkObject in networkAndZoneNamesDuplicates)
            {
                foreach (var networkGroup in _cpNetworkGroups)
                {
                    string zoneSuffix = "_" + cpNetworkObject.Tag;
                    string originalName = cpNetworkObject.Name.Replace(zoneSuffix, "");
                    int pos = networkGroup.Members.IndexOf(originalName);
                    if (pos != -1)
                    {
                        networkGroup.Members[pos] = cpNetworkObject.Name;
                    }
                }
            }
        }

        private void Add_InterfacesAndRoutes()
        {
            foreach (Juniper_Interface ifc in JuniperInterfaces)
            {
                if (ifc.Topology.Count == 0)
                {
                    // Invalid interface configuration...
                    continue;
                }

                // Create network group object that has the network associated with the interface.
                if (!ifc.LeadsToInternet)
                {
                    var distinctNetworks = new List<string>();

                    var cpNetworkGroup = new CheckPoint_NetworkGroup();
                    cpNetworkGroup.Name = ifc.Name + "_subnets";
                    cpNetworkGroup.Comments = ifc.Description;

                    foreach (var subnet in ifc.Topology)
                    {
                        if (distinctNetworks.Contains(subnet.IpAddress))
                        {
                            continue;
                        }
                        distinctNetworks.Add(subnet.IpAddress);

                        string networkName = "network_" + subnet.IpAddress + "_" + NetworkUtils.GetMaskLength(subnet.Netmask);

                        var cpNetwork = new CheckPoint_Network();
                        cpNetwork.Name = networkName;
                        cpNetwork.Subnet = subnet.IpAddress;
                        cpNetwork.Netmask = subnet.Netmask;
                        AddCheckPointObject(cpNetwork);

                        cpNetworkGroup.Members.Add(cpNetwork.Name);
                    }

                    ApplyConversionIncidentOnCheckPointObject(cpNetworkGroup, ifc);
                    CheckObjectNameValidity(cpNetworkGroup, ifc);
                    AddCheckPointObject(cpNetworkGroup);
                }

                // Create host object for the interface's primary/preferred IP address.
                var cpHost = new CheckPoint_Host();
                cpHost.Name = ifc.Name + "_address";
                cpHost.IpAddress = ifc.MainIpAddress;
                ApplyConversionIncidentOnCheckPointObject(cpHost, ifc);
                CheckObjectNameValidity(cpHost, ifc);
                AddCheckPointObject(cpHost);
            }
        }

        // This method resolves the interfaces subnets overlaping issue by creating 
        // a new network group with excusion (CheckPoint_GroupWithExclusion).
        private void Add_or_Modify_InterfaceNetworkGroups()
        {
            var interfaceGroupObjects = new List<CheckPoint_NetworkGroup>();

            foreach (Juniper_Interface ifc in JuniperInterfaces)
            {
                string interfaceGroupName = ifc.Name + "_subnets";
                var cpObject = _cpObjects.GetObject(interfaceGroupName);
                if (cpObject != null)
                {
                    interfaceGroupObjects.Add((CheckPoint_NetworkGroup)cpObject);
                }
            }

            var modifiedNetworkGroups = Add_or_Modify_InterfaceNetworkGroups(interfaceGroupObjects);

            // Apply object name verification.
            foreach (var modifiedNetworkGroup in modifiedNetworkGroups)
            {
                if (_cpUnsafeNames.Contains(modifiedNetworkGroup))
                {
                    _cpUnsafeNames.Add(modifiedNetworkGroup + "_include");
                    _cpUnsafeNames.Add(modifiedNetworkGroup + "_exclude");
                }
            }
        }

        private void Add_Zones()
        {
            foreach (Juniper_Zone zone in JuniperZones)
            {
                var cpZone = new CheckPoint_Zone();
                cpZone.Name = zone.Name;
                cpZone.Comments = zone.Description;
                CheckObjectNameValidity(cpZone, zone);
                AddCheckPointObject(cpZone);

                // Create a network group object that contains network group objects associated with each interface.
                var members = new List<string>();
                foreach (var ifcName in zone.Interfaces)
                {
                    foreach (Juniper_Interface ifc in JuniperInterfaces)
                    {
                        if (ifcName == ifc.Name)
                        {
                            if (ifc.LeadsToInternet)
                            {
                                zone.LeadsToInternet = true;
                            }
                            else
                            {
                                var cpObject = _cpObjects.GetObject(ifcName + "_subnets");
                                if (cpObject != null)
                                {
                                    members.Add(cpObject.Name);
                                }
                            }

                            break;
                        }
                    }

                    if (zone.LeadsToInternet)
                    {
                        break;
                    }
                }

                if (!zone.LeadsToInternet && (members.Count > 0))
                {
                    var cpNetworkGroup = new CheckPoint_NetworkGroup();
                    cpNetworkGroup.Name = "zone_" + zone.Name + "_subnets";
                    cpNetworkGroup.Members.AddRange(members);
                    cpNetworkGroup.CreateAfterGroupsWithExclusion = true;
                    CheckObjectNameValidity(cpNetworkGroup, zone);
                    AddCheckPointObject(cpNetworkGroup);
                }
            }
        }

        private void Add_ServiceObjects()
        {
            foreach (Juniper_Application application in _juniperParser.Filter("_Application"))
            {
                switch (application.Protocol)
                {
                    case "any":
                        // do nothing...
                        break;

                    case "tcp":
                        if (!string.IsNullOrEmpty(application.ProgramNumber))
                        {
                            var cpRpc = new CheckPoint_RpcService();
                            cpRpc.Name = application.Name;
                            cpRpc.Comments = application.Description;
                            cpRpc.ProgramNumber = application.ProgramNumber;
                            ApplyConversionIncidentOnCheckPointObject(cpRpc, application);
                            CheckObjectNameValidity(cpRpc, application);
                            AddCheckPointObject(cpRpc);
                        }
                        else if (!string.IsNullOrEmpty(application.InterfaceUuid))
                        {
                            var cpDceRpc = new CheckPoint_DceRpcService();
                            cpDceRpc.Name = application.Name;
                            cpDceRpc.Comments = application.Description;
                            cpDceRpc.InterfaceUuid = application.InterfaceUuid;
                            ApplyConversionIncidentOnCheckPointObject(cpDceRpc, application);
                            CheckObjectNameValidity(cpDceRpc, application);
                            AddCheckPointObject(cpDceRpc);
                        }
                        else if (!string.IsNullOrEmpty(application.Port))
                        {
                            string cpServiceName = "TCP_" + application.Port;

                            if (!DoesJuniperApplicationMatchCheckpointPredefinedService(application, cpServiceName))
                            {
                                var cpTcp = new CheckPoint_TcpService();
                                cpTcp.Name = application.Name;
                                cpTcp.Comments = application.Description;
                                cpTcp.Port = application.Port;
                                cpTcp.SessionTimeout = application.InactivityTimeout.ToString();
                                ApplyConversionIncidentOnCheckPointObject(cpTcp, application);
                                CheckObjectNameValidity(cpTcp, application);
                                AddCheckPointObject(cpTcp);
                            }
                        }
                        else
                        {
                            var error = new CheckPoint_ServiceGroup();
                            error.Name = "_Err_in_service-line_" + application.LineNumber;
                            error.Comments = application.Description;
                            ApplyConversionIncidentOnCheckPointObject(error, application);
                            AddCheckPointObject(error);
                            _juniperInvalidApplicationsReferences.Add(application.Name, error.Name);
                        }
                        break;

                    case "udp":
                        if (!string.IsNullOrEmpty(application.ProgramNumber))
                        {
                            var cpRpc = new CheckPoint_RpcService();
                            cpRpc.Name = application.Name;
                            cpRpc.Comments = application.Description;
                            cpRpc.ProgramNumber = application.ProgramNumber;
                            ApplyConversionIncidentOnCheckPointObject(cpRpc, application);
                            CheckObjectNameValidity(cpRpc, application);
                            AddCheckPointObject(cpRpc);
                        }
                        else if (!string.IsNullOrEmpty(application.InterfaceUuid))
                        {
                            var cpDceRpc = new CheckPoint_DceRpcService();
                            cpDceRpc.Name = application.Name;
                            cpDceRpc.Comments = application.Description;
                            cpDceRpc.InterfaceUuid = application.InterfaceUuid;
                            ApplyConversionIncidentOnCheckPointObject(cpDceRpc, application);
                            CheckObjectNameValidity(cpDceRpc, application);
                            AddCheckPointObject(cpDceRpc);
                        }
                        else if (!string.IsNullOrEmpty(application.Port))
                        {
                            string cpServiceName = "UDP_" + application.Port;

                            if (!DoesJuniperApplicationMatchCheckpointPredefinedService(application, cpServiceName))
                            {
                                var cpUdp = new CheckPoint_UdpService();
                                cpUdp.Name = application.Name;
                                cpUdp.Comments = application.Description;
                                cpUdp.Port = application.Port;
                                cpUdp.SessionTimeout = application.InactivityTimeout.ToString();
                                ApplyConversionIncidentOnCheckPointObject(cpUdp, application);
                                CheckObjectNameValidity(cpUdp, application);
                                AddCheckPointObject(cpUdp);
                            }
                        }
                        else
                        {
                            var error = new CheckPoint_ServiceGroup();
                            error.Name = "_Err_in_service-line_" + application.LineNumber;
                            error.Comments = application.Description;
                            ApplyConversionIncidentOnCheckPointObject(error, application);
                            AddCheckPointObject(error);
                            _juniperInvalidApplicationsReferences.Add(application.Name, error.Name);
                        }
                        break;

                    case "sctp":
                        var cpSctp = new CheckPoint_SctpService();
                        cpSctp.Name = application.Name;
                        cpSctp.Comments = application.Description;
                        cpSctp.Port = application.Port;
                        cpSctp.SessionTimeout = application.InactivityTimeout.ToString();
                        ApplyConversionIncidentOnCheckPointObject(cpSctp, application);
                        CheckObjectNameValidity(cpSctp, application);
                        AddCheckPointObject(cpSctp);
                        break;

                    case "icmp":
                        if (!string.IsNullOrEmpty(application.IcmpType))
                        {
                            string cpServiceName = "ICMP_" + application.IcmpType;

                            if (!DoesJuniperApplicationMatchCheckpointPredefinedService(application, cpServiceName))
                            {
                                var cpIcmp = new CheckPoint_IcmpService();
                                cpIcmp.Name = application.Name;
                                cpIcmp.Comments = application.Description;
                                cpIcmp.Type = application.IcmpType;
                                cpIcmp.Code = application.IcmpCode;
                                ApplyConversionIncidentOnCheckPointObject(cpIcmp, application);
                                CheckObjectNameValidity(cpIcmp, application);
                                AddCheckPointObject(cpIcmp);
                            }
                        }
                        else
                        {
                            var error = new CheckPoint_ServiceGroup();
                            error.Name = "_Err_in_service-line_" + application.LineNumber;
                            error.Comments = application.Description;
                            ApplyConversionIncidentOnCheckPointObject(error, application);
                            AddCheckPointObject(error);
                            _juniperInvalidApplicationsReferences.Add(application.Name, error.Name);
                        }
                        break;

                    default:   // "other" services...
                        if (!string.IsNullOrEmpty(application.Protocol) && JuniperKnownApplications.IsKnownProtocolOrPortName(application.Protocol))
                        {
                            string cpServiceName = "OTHER_" + application.Port;

                            if (!DoesJuniperApplicationMatchCheckpointPredefinedService(application, cpServiceName))
                            {
                                var other = new CheckPoint_OtherService();
                                other.Name = application.Name;
                                other.Comments = application.Description;
                                other.IpProtocol = application.Port;
                                ApplyConversionIncidentOnCheckPointObject(other, application);
                                CheckObjectNameValidity(other, application);
                                AddCheckPointObject(other);
                            }
                        }
                        else
                        {
                            var error = new CheckPoint_ServiceGroup();
                            error.Name = "_Err_in_service-line_" + application.LineNumber;
                            error.Comments = application.Description;
                            ApplyConversionIncidentOnCheckPointObject(error, application);
                            AddCheckPointObject(error);
                            _juniperInvalidApplicationsReferences.Add(application.Name, error.Name);
                        }
                        break;
                }
            }

            var groupsWithNonCreatedMembers = new List<CheckPoint_ServiceGroup>();

            foreach (Juniper_ApplicationGroup group in _juniperParser.Filter("_ApplicationGroup"))
            {
                var cpServiceGroup = new CheckPoint_ServiceGroup();
                cpServiceGroup.Name = group.Name;
                cpServiceGroup.Comments = group.Description;
                cpServiceGroup.Members.AddRange(group.Members);
                cpServiceGroup.Members.AddRange(group.MemberGroupNames);
                ApplyConversionIncidentOnCheckPointObject(cpServiceGroup, group);
                CheckObjectNameValidity(cpServiceGroup, group);

                // Check if the member groups are already created to avoid "object not found" errors during the import to DB.
                bool hasNonCreatedMembers = false;
                foreach (var memberGroupName in group.MemberGroupNames)
                {
                    bool found = _cpServiceGroups.Any(cpGroup => cpGroup.Name == memberGroupName);
                    if (!found)
                    {
                        groupsWithNonCreatedMembers.Add(cpServiceGroup);
                        hasNonCreatedMembers = true;
                    }
                }

                if (!hasNonCreatedMembers)
                {
                    AddCheckPointObject(cpServiceGroup);
                }
            }

            // After all groups are created, add the groups that had non created member groups.
            foreach (var serviceGroup in groupsWithNonCreatedMembers)
            {
                AddCheckPointObject(serviceGroup);
            }
        }
		private void Add_Schedulers()
        {
            List<string> cpTimeRangesNamesUniq = new List<string>();
            foreach (Juniper_Scheduler scheduler in _juniperParser.Filter("_Scheduler"))
            {
                List<CheckPoint_Time> timesList = new List<CheckPoint_Time>();//will store time-objects for separate days with different hours-ranges                              
                
                int postfixIndex = 1;//postfix of time-object in case Juniper scheduler is split to several objects     

                if (scheduler.StartStopDates.Count == 0)
                {// check if time object has Start Time
                    CheckPoint_Time cpTime = new CheckPoint_Time();
                    cpTime.Comments = "Old Time Object name: " + scheduler.Name;
                    cpTime.StartNow = true;
                    cpTime.EndNever = true;
					cpTime.Name = checkTimeNameLength(scheduler.Name, cpTimeRangesNamesUniq);
					
                    Add_TimeObject(scheduler, cpTime, timesList, cpTimeRangesNamesUniq);
                    foreach (CheckPoint_Time time in timesList)
                        AddCheckPointObject(time);
                }
                else {
                    foreach (string sdate in scheduler.StartStopDates) //create separate time-object for each start-date
                    {
                        CheckPoint_Time cpTime = new CheckPoint_Time();
                        cpTime.Comments = "Old Time Object name: " + scheduler.Name;
                        //2020-09-06.01:01;2020-09-08.12:30
                        if (scheduler.StartStopDates.Count == 1)
                        {
                            cpTime.Name = checkTimeNameLength(scheduler.Name, cpTimeRangesNamesUniq);                       
                        }
                        else
                        {
                            if (scheduler.Name.Length <= 8)
                                cpTime.Name = scheduler.Name + "_" + postfixIndex++;
                            else
                            {
                                cpTime.Name = scheduler.Name.Substring(0, 8) + "_" + postfixIndex++;
                                while (cpTimeRangesNamesUniq.Contains(cpTime.Name))
                                {
                                    cpTime.Name = scheduler.Name.Substring(0, 8) + "_" + postfixIndex++;
                                }                                
                            }                                
                        }
                        cpTime.StartNow = false;
                        DateTime date = DateTime.ParseExact(sdate.Substring(0, sdate.IndexOf(";")), "yyyy-MM-dd.HH:mm", CultureInfo.InvariantCulture);
                        cpTime.StartDate = date.ToString("dd-MMM-yyyy", CultureInfo.InvariantCulture).Trim();
                        cpTime.StartTime = date.ToString("HH:mm").Trim();

                        cpTime.EndNever = false;
                        date = DateTime.ParseExact(sdate.Substring(sdate.IndexOf(";") + 1), "yyyy-MM-dd.HH:mm", CultureInfo.InvariantCulture);
                        cpTime.EndDate = date.ToString("dd-MMM-yyyy", CultureInfo.InvariantCulture).Trim();
                        cpTime.EndTime = date.ToString("HH:mm").Trim();
                        
                        Add_TimeObject(scheduler, cpTime, timesList, cpTimeRangesNamesUniq);

                        foreach (CheckPoint_Time time in timesList)
                            AddCheckPointObject(time);
                    }                    
                }  
            }
        }

        /// <summary>
        /// Check the length of time object name.
        /// CheckPoint time object name is limited to 11 chars. In case it's more than 11 it's either truncated or truncated and completed with postfix so that to be unique.
        /// </summary>         
        private string checkTimeNameLength(string timeName, List<string> cpTimeRangesNamesUniq)
        {
            int postfixIndex = 1;
            if (timeName.Length > 11)
            {
                timeName = timeName.Substring(0, 11);
                while (cpTimeRangesNamesUniq.Contains(timeName))
                {
                    timeName = timeName.Substring(0, 8) + "_" + postfixIndex++;
                }
                return timeName;
            }
            else
            {
                return timeName;
            }
        }

        private List<CheckPoint_Time> Add_TimeObject(Juniper_Scheduler scheduler, CheckPoint_Time cpTime, List<CheckPoint_Time> timesList, List<string> cpTimeRangesNamesUniq)
        {
            List<string> daysList = new List<string> { "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" };

            int postfixIndex = 1;//postfix of time-object in case Juniper scheduler is split to several objects

            bool dailyIsConfigured = false;

            bool daysAreAddedToPattern = false;//used for exclude statement. 
            //In case some day is excluded from the scheduler, RecurrencePattern is changed to weekly and all days except excluded day are added to RecurrenceWeekdays (need to be done once)

            if (scheduler.patternDictionary.Keys.Count != 0)
            {
                foreach (var day in scheduler.patternDictionary.Keys)
                {
                    if (day.Equals("daily"))
                    {
                        dailyIsConfigured = true;
                        cpTime.RecurrencePattern = CheckPoint_Time.RecurrencePatternEnum.Daily;

                        processHoursRanges(scheduler.patternDictionary[day], cpTime);
                        
                        timesList.Add(cpTime);
                        cpTimeRangesNamesUniq.Add(cpTime.Name);
                    }
                    else
                    {
                        cpTime.RecurrencePattern = CheckPoint_Time.RecurrencePatternEnum.Weekly;

                        if (scheduler.patternDictionary[day][0].Equals("all-day"))
                        {                            
                            cpTime.RecurrenceWeekdays.Add((CheckPoint_Time.Weekdays)daysList.IndexOf(day));
                            
                            timesList.Add(cpTime);
                            cpTimeRangesNamesUniq.Add(cpTime.Name);
                        }
                        else if (scheduler.patternDictionary[day][0].Equals("exclude"))
                        {
                            if (!daysAreAddedToPattern && dailyIsConfigured)
                            {                                
                                if (!cpTime.RecurrenceWeekdays.Contains(CheckPoint_Time.Weekdays.Sun))
                                    cpTime.RecurrenceWeekdays.Add(CheckPoint_Time.Weekdays.Sun);
                                if (!cpTime.RecurrenceWeekdays.Contains(CheckPoint_Time.Weekdays.Mon))
                                    cpTime.RecurrenceWeekdays.Add(CheckPoint_Time.Weekdays.Mon);
                                if (!cpTime.RecurrenceWeekdays.Contains(CheckPoint_Time.Weekdays.Tue))
                                    cpTime.RecurrenceWeekdays.Add(CheckPoint_Time.Weekdays.Tue);
                                if (!cpTime.RecurrenceWeekdays.Contains(CheckPoint_Time.Weekdays.Wed))
                                    cpTime.RecurrenceWeekdays.Add(CheckPoint_Time.Weekdays.Wed);
                                if (!cpTime.RecurrenceWeekdays.Contains(CheckPoint_Time.Weekdays.Thu))
                                    cpTime.RecurrenceWeekdays.Add(CheckPoint_Time.Weekdays.Thu);
                                if (!cpTime.RecurrenceWeekdays.Contains(CheckPoint_Time.Weekdays.Fri))
                                    cpTime.RecurrenceWeekdays.Add(CheckPoint_Time.Weekdays.Fri);
                                if (!cpTime.RecurrenceWeekdays.Contains(CheckPoint_Time.Weekdays.Sat))
                                    cpTime.RecurrenceWeekdays.Add(CheckPoint_Time.Weekdays.Sat);
                                daysAreAddedToPattern = true;
                            }
                            cpTime.RecurrenceWeekdays.Remove((CheckPoint_Time.Weekdays)daysList.IndexOf(day));
                        }
                        else
                        {
                            CheckPoint_Time cpTimeAdd = new CheckPoint_Time();//create separate time-object for each day in case hours ranges for day are set                                              

                            cpTimeAdd = cpTime.Clone();

                            cpTime.RecurrenceWeekdays.Remove((CheckPoint_Time.Weekdays)daysList.IndexOf(day));//remove day from the common TO because for this day separate TO is created
                            cpTimeAdd.RecurrenceWeekdays.Add((CheckPoint_Time.Weekdays)daysList.IndexOf(day));

                            if (cpTimeAdd.Name.Length <= 8)
                                cpTimeAdd.Name = cpTimeAdd.Name + "_" + postfixIndex++;
                            else
                            {
                                cpTimeAdd.Name = cpTimeAdd.Name.Substring(0, 8) + "_" + postfixIndex++;
                                while (cpTimeRangesNamesUniq.Contains(cpTimeAdd.Name))
                                {
                                    cpTimeAdd.Name = cpTimeAdd.Name.Substring(0, 8) + "_" + postfixIndex++;
                                }
                            }

                            foreach (string timeRange in scheduler.patternDictionary[day])
                            {
                                processHoursRanges(scheduler.patternDictionary[day], cpTimeAdd);
                            }
                            
                            timesList.Add(cpTimeAdd);
                            cpTimeRangesNamesUniq.Add(cpTimeAdd.Name);
                        }
                    }
                }
            }
            else
            {
                cpTime.RecurrencePattern = CheckPoint_Time.RecurrencePatternEnum.None;
                timesList.Add(cpTime);
                cpTimeRangesNamesUniq.Add(cpTime.Name);
            }

            return timesList;                   
        }

        /// <summary>
        /// Convert Juniper scheduler start- and stop-time (in format HH:MM:SS) into CheckPoint hours-ranges parameter in required format (HH:MM)
        /// </summary>
        private void processHoursRanges(List<string> timeRanges, CheckPoint_Time cpTime)
        {
            foreach (string timeRange in timeRanges)
            {
                if (timeRange.IndexOf(";") != -1)
                {
                    string startTime = timeRange.Substring(0, timeRange.IndexOf(";"));                    
                    string stopTime = timeRange.Substring(timeRange.IndexOf(";") + 1);
                    
                    TimeSpan timeCheck0 = TimeSpan.ParseExact(startTime, "hh\\:mm\\:ss", CultureInfo.InvariantCulture);
                    TimeSpan timeCheck1 = TimeSpan.ParseExact(stopTime, "hh\\:mm\\:ss", CultureInfo.InvariantCulture);

                    if (TimeSpan.Compare(timeCheck0, timeCheck1) == -1)
                    {
                        if (timeRanges.IndexOf(timeRange) == 0)
                        {
                            cpTime.HoursRangesEnabled_1 = true;                                                        
                            cpTime.HoursRangesFrom_1 = timeCheck0.ToString(@"hh\:mm").Trim();                            
                            cpTime.HoursRangesTo_1 = timeCheck1.ToString(@"hh\:mm").Trim();
                        } else
                        {
                            cpTime.HoursRangesEnabled_2 = true;                            
                            cpTime.HoursRangesFrom_2 = timeCheck0.ToString(@"hh\:mm").Trim();                            
                            cpTime.HoursRangesTo_2 = timeCheck1.ToString(@"hh\:mm").Trim();
                        }                        
                    }                  
                }
            }            
        }

        private CheckPoint_Package Add_Package(bool isPreExecution = false)
        {
            var cpPackage = new CheckPoint_Package();
            cpPackage.Name = _policyPackageName;

            Add_ParentLayer(cpPackage);
            Add_Layers_And_Rules(cpPackage);
            Add_Global_Rules(cpPackage);

            if (!isPreExecution)
                AddCheckPointObject(cpPackage);

            return cpPackage;
        }

        private void Add_ParentLayer(CheckPoint_Package package)
        {
            package.ParentLayer.Name = package.NameOfAccessLayer;

            var cpManagementHost = GetJuniperManagementHost();
            var managementRules = new List<CheckPoint_Rule>();

            foreach (Juniper_ZonePolicy zonePolicy in JuniperZonePolicies)
            {
                // Should we add a special management-access parent rule?
                if (zonePolicy.IsManagementAccessPolicy)
                {
                    if (cpManagementHost == null)
                    {
                        zonePolicy.ConversionIncidentType = ConversionIncidentType.Informative;

                        _conversionIncidents.Add(new ConversionIncident(zonePolicy.LineNumber,
                                                                        "Error creating an access management policy, missing topology information for Juniper FXP0 interface",
                                                                        "All related rules are skipped.",
                                                                        zonePolicy.ConversionIncidentType));
                    }
                    else
                    {
                        foreach (var juniperRule in zonePolicy.Rules)
                        {
                            var cpManagementRule = Juniper_To_ManagementCPRule(juniperRule, package.NameOfAccessLayer, zonePolicy.SourceZone, cpManagementHost);
                            managementRules.Add(cpManagementRule);
                        }
                    }

                    continue;
                }

                var cpSourceZone = GetCheckPointObjectOrCreateDummy(zonePolicy.SourceZone,
                                                                    "NetworkGroup",
                                                                    zonePolicy,
                                                                    "Error creating a parent layer rule, missing information for Juniper source zone",
                                                                    "Source zone details: " + zonePolicy.SourceZone + ".");
                var cpDestZone = GetCheckPointObjectOrCreateDummy(zonePolicy.DestinationZone,
                                                                  "NetworkGroup",
                                                                  zonePolicy,
                                                                  "Error creating a parent layer rule, missing information for Juniper destination zone",
                                                                  "Destination zone details: " + zonePolicy.DestinationZone + ".");

                var cpRule = new CheckPoint_Rule();
                cpRule.Source.Add(cpSourceZone);
                cpRule.Destination.Add(cpDestZone);
                cpRule.Action = CheckPoint_Rule.ActionType.SubPolicy;
                cpRule.SubPolicyName = zonePolicy.SourceZone + "_to_" + zonePolicy.DestinationZone + "_sub_policy";
                cpRule.Layer = package.NameOfAccessLayer;
                ApplyConversionIncidentOnCheckPointObject(cpRule, zonePolicy);
                if (cpRule.Enabled == false)
                {
                    NewJunoAnalizStatistic._disabledServicesRulesCount++;
                }
                package.ParentLayer.Rules.Add(cpRule);

                string policyZone = zonePolicy.SourceZone + "-" + zonePolicy.DestinationZone;
                _policyZonesLookup.Add(policyZone);
            }

            if (managementRules.Count > 0)
            {
                int ruleNumber = 0;

                // Insert on top!!!
                foreach (var cpRule in managementRules)
                {
                    package.ParentLayer.Rules.Insert(ruleNumber, cpRule);

                    ++ruleNumber;
                }
            }
        }

        private void Add_Layers_And_Rules(CheckPoint_Package package)
        {
            foreach (Juniper_ZonePolicy zonePolicy in JuniperZonePolicies)
            {
                if (zonePolicy.IsManagementAccessPolicy)
                {
                    continue;
                }

                var cpLayer = new CheckPoint_Layer();
                cpLayer.Name = zonePolicy.SourceZone + "_to_" + zonePolicy.DestinationZone + "_sub_policy";
                cpLayer.Comments = zonePolicy.Description;
                cpLayer.Tag = zonePolicy.SourceZone + "," + zonePolicy.DestinationZone;   // this info is needed later for global policy rules

                foreach (var juniperRule in zonePolicy.Rules)
                {
                    var cpRule = Juniper_To_CPRule(juniperRule, cpLayer.Name, zonePolicy.SourceZone, zonePolicy.DestinationZone);

                    foreach (var chpObj in cpRule.Service)
                    {
                        if (chpObj.GetType() == typeof(CheckPoint_PredifinedObject))
                        {
                            if (chpObj.Name == "Any")
                            {
                                cpRule.Service.Clear();
                                cpRule.Service.Add(chpObj);
                                break;
                            }
                        }
                    }

                    cpLayer.Rules.Add(cpRule);

                    if (cpRule.ConversionIncidentType != ConversionIncidentType.None || juniperRule.ConversionIncidentType != ConversionIncidentType.None)
                    {
                        package.ConversionIncidentType = ConversionIncidentType.Informative;
                    }
                }

                package.SubPolicies.Add(cpLayer);
                validatePackage(package);
            }
        }

        private void Add_Global_Rules(CheckPoint_Package package)
        {
            bool isZonelessAllGlobalRules = true;
            foreach (var globalPolicyRule in _juniperParser.GetGlobalPolicyRules())
            {
                bool isZonelessGlobalRule = globalPolicyRule.SourceZones.Count == 1 && globalPolicyRule.SourceZones[0] == JuniperObject.Any &&
                                            globalPolicyRule.DestinationZones.Count == 1 && globalPolicyRule.DestinationZones[0] == JuniperObject.Any;
                if (isZonelessAllGlobalRules && !isZonelessGlobalRule)
                {
                    isZonelessAllGlobalRules = false;
                }
            }

            if (isZonelessAllGlobalRules && _juniperParser.GetGlobalPolicyRules().Count > 1)
            {
                CheckPoint_Rule cpRule4GlobalLayer = new CheckPoint_Rule();
                cpRule4GlobalLayer.Name = "";
                cpRule4GlobalLayer.Layer = package.NameOfAccessLayer;
                cpRule4GlobalLayer.Source.Add(_cpObjects.GetObject(CheckPointObject.Any));
                cpRule4GlobalLayer.Destination.Add(_cpObjects.GetObject(CheckPointObject.Any));
                cpRule4GlobalLayer.Action = CheckPoint_Rule.ActionType.SubPolicy;
                cpRule4GlobalLayer.Track = CheckPoint_Rule.TrackTypes.None;
                cpRule4GlobalLayer.Time.Add(_cpObjects.GetObject(CheckPointObject.Any));
                cpRule4GlobalLayer.Service.Add(_cpObjects.GetObject(CheckPointObject.Any));
                cpRule4GlobalLayer.SubPolicyName = GlobalRulesSubpolicyName;

                package.ParentLayer.Rules.Add(cpRule4GlobalLayer);

                CheckPoint_Layer cpSubLayer4GlobalRules = new CheckPoint_Layer();
                cpSubLayer4GlobalRules.ApplicationsAndUrlFiltering = true;
                cpSubLayer4GlobalRules.Shared = true;
                cpSubLayer4GlobalRules.Name = cpRule4GlobalLayer.SubPolicyName;

                package.SubPolicies.Insert(0, cpSubLayer4GlobalRules); // insert at the begging becuase Global Rules should be created before all policy
                validatePackage(package);

                foreach (var globalPolicyRule in _juniperParser.GetGlobalPolicyRules())
                {
                    // Append the global policy rules BELOW the existing sub-policies.
                    CheckPoint_Rule cpRule = Juniper_To_CPRule(globalPolicyRule, cpSubLayer4GlobalRules.Name, null, null);
                    cpSubLayer4GlobalRules.Rules.Add(cpRule);
                }

                // Fill in the shared layer with global policy rules INSIDE the existing sub-policies.
                foreach (CheckPoint_Layer subPolicy in package.SubPolicies)
                {
                    if (subPolicy.Name.Equals(cpSubLayer4GlobalRules.Name))
                    {
                        continue;
                    }

                    CheckPoint_Rule cpSubRule4GlobalLayer = cpRule4GlobalLayer.Clone();
                    cpSubRule4GlobalLayer.Name = "Global Layer";
                    cpSubRule4GlobalLayer.Layer = subPolicy.Name;

                    subPolicy.Rules.Add(cpSubRule4GlobalLayer);
                }


                //the last rule which is created by default by CheckPoint script importer. It is for report only.
                var cpRuleCleanUp = new CheckPoint_Rule();
                cpRuleCleanUp.Name = Juniper_GlobalPolicyRule.DefaultActionRuleName;
                package.ParentLayer.Rules.Add(cpRuleCleanUp);
            }
            else
            {
                foreach (var globalPolicyRule in _juniperParser.GetGlobalPolicyRules())
                {
                    // Fill in the global policy rules INSIDE the existing sub-policies.
                    foreach (CheckPoint_Rule cpParentRule in package.ParentLayer.Rules)
                    {
                        if (cpParentRule.Action != CheckPoint_Rule.ActionType.SubPolicy)
                        {
                            continue;
                        }

                        // Get into the relevant sub-policy
                        foreach (CheckPoint_Layer subPolicy in package.SubPolicies)
                        {
                            if (subPolicy.Name != cpParentRule.SubPolicyName)
                            {
                                continue;
                            }

                            bool sourceZoneMatches = (globalPolicyRule.SourceZones.Count == 1 && globalPolicyRule.SourceZones[0] == JuniperObject.Any);
                            bool destZoneMatches = (globalPolicyRule.DestinationZones.Count == 1 && globalPolicyRule.DestinationZones[0] == JuniperObject.Any);
                            string[] subPolicyZones = subPolicy.Tag.Split(',');   // [source-zone,dest-zone]

                            if (!sourceZoneMatches)
                            {
                                if (globalPolicyRule.SourceZones.Any(sourceZone => sourceZone == subPolicyZones[0]))
                                {
                                    sourceZoneMatches = true;
                                }
                            }
                            if (!destZoneMatches)
                            {
                                if (globalPolicyRule.DestinationZones.Any(destZone => destZone == subPolicyZones[1]))
                                {
                                    destZoneMatches = true;
                                }
                            }

                            if (!(sourceZoneMatches && destZoneMatches))
                            {
                                continue;
                            }

                            // This is done to avoid duplication of incident reporting over all matched sub-policy rules.
                            ConversionIncidentType aclConversionIncident = globalPolicyRule.ConversionIncidentType;
                            globalPolicyRule.ConversionIncidentType = ConversionIncidentType.None;

                            CheckPoint_Rule cpRule = Juniper_To_CPRule(globalPolicyRule, subPolicy.Name, null, null);
                            subPolicy.Rules.Add(cpRule);

                            // If the global rule didn't have an incident previously, 
                            // and the incident was just encountered during this convertion, retain the incident!!!
                            if (globalPolicyRule.ConversionIncidentType == ConversionIncidentType.None)
                            {
                                globalPolicyRule.ConversionIncidentType = aclConversionIncident;
                            }

                            if (cpRule.ConversionIncidentType != ConversionIncidentType.None || globalPolicyRule.ConversionIncidentType != ConversionIncidentType.None)
                            {
                                package.ConversionIncidentType = ConversionIncidentType.Informative;
                            }
                        }
                    }

                    // Append the global policy rules BELOW the existing sub-policies.
                    bool isZonelessGlobalRule = globalPolicyRule.SourceZones.Count == 1 && globalPolicyRule.SourceZones[0] == JuniperObject.Any &&
                                                globalPolicyRule.DestinationZones.Count == 1 && globalPolicyRule.DestinationZones[0] == JuniperObject.Any;

                    if (isZonelessGlobalRule)
                    {
                        CheckPoint_Rule cpRule = Juniper_To_CPRule(globalPolicyRule, package.NameOfAccessLayer, null, null);
                        package.ParentLayer.Rules.Add(cpRule);
                    }
                    else
                    {
                        // In this case we should create a new parent rule and associated sub-policy for each couple of sourceZone and destZone.
                        foreach (var sourceZone in globalPolicyRule.SourceZones)
                        {
                            var cpSourceZone = GetCheckPointObjectOrCreateDummy(sourceZone,
                                                                                "NetworkGroup",
                                                                                globalPolicyRule,
                                                                                "Error creating a parent layer rule for global policy, missing information for Juniper source zone",
                                                                                "Source zone details: " + sourceZone + ".");

                            foreach (var destZone in globalPolicyRule.DestinationZones)
                            {
                                var cpDestZone = GetCheckPointObjectOrCreateDummy(destZone,
                                                                                  "NetworkGroup",
                                                                                  globalPolicyRule,
                                                                                  "Error creating a parent layer rule for global policy, missing information for Juniper destination zone",
                                                                                  "Destination zone details: " + destZone + ".");

                                // Avoid zone duplications!!!
                                string policyZone = sourceZone + "-" + destZone;
                                if (_policyZonesLookup.Contains(policyZone))
                                {
                                    continue;
                                }
                                _policyZonesLookup.Add(policyZone);

                                // 1. Create a new parent rule
                                var cpParentRule = new CheckPoint_Rule();
                                cpParentRule.Source.Add(cpSourceZone);
                                cpParentRule.Destination.Add(cpDestZone);
                                cpParentRule.Action = CheckPoint_Rule.ActionType.SubPolicy;
                                cpParentRule.SubPolicyName = sourceZone + "_to_" + destZone + "_sub_policy";
                                cpParentRule.Layer = package.NameOfAccessLayer;
                                cpParentRule.Comments = "Automatically created for global policy rule zones";
                                ApplyConversionIncidentOnCheckPointObject(cpParentRule, globalPolicyRule);

                                package.ParentLayer.Rules.Add(cpParentRule);

                                // 2. Create associated sub-policy
                                var cpLayer = new CheckPoint_Layer();
                                cpLayer.Name = cpParentRule.SubPolicyName;
                                cpLayer.Tag = ",";   // this info is needed later for global policy rules - in this case this sub-policy will be skipped!!!

                                package.SubPolicies.Add(cpLayer);
                                validatePackage(package);

                                // 3. Create a new rule and add to this sub-policy
                                var cpRule = Juniper_To_CPRule(globalPolicyRule, cpLayer.Name, sourceZone, destZone);
                                cpLayer.Rules.Add(cpRule);

                                if (cpRule.ConversionIncidentType != ConversionIncidentType.None || globalPolicyRule.ConversionIncidentType != ConversionIncidentType.None)
                                {
                                    package.ConversionIncidentType = ConversionIncidentType.Informative;
                                }
                            }
                        }
                    }
                }
            }
        }

        private CheckPoint_Rule Juniper_To_CPRule(Juniper_PolicyRule juniperRule, string cpLayerName, string sourceZone, string destZone)
        {
            bool isGlobalRule = (juniperRule is Juniper_GlobalPolicyRule);

            var cpRule = new CheckPoint_Rule();
            cpRule.Name = juniperRule.Name;
            cpRule.Comments = juniperRule.Description;
            cpRule.Layer = cpLayerName;
            cpRule.Enabled = !juniperRule.Inactive;
            cpRule.ConversionComments = "Matched rule: " + juniperRule.Name;

            ApplyConversionIncidentOnCheckPointObject(cpRule, juniperRule);

            CheckPointObject cpObject;

            foreach (var source in juniperRule.Sources)
            {
                string sourceName = source;

                if (!isGlobalRule && _juniperParser.IsNetworkObjectContainedInMultipleZones(source))
                {
                    sourceName = source + "_" + sourceZone;   // original name combined with the zone name
                }

                cpObject = GetCheckPointObjectOrCreateDummy(sourceName,
                                                            "NetworkGroup",
                                                            juniperRule,
                                                            "Error creating a rule, missing information for source Juniper object",
                                                            "Source object details: " + sourceName + ".",
                                                            isGlobalRule);

                if (!isGlobalRule && cpObject == null)
                {
                    // If the source object was not found in the address-book of source-zone, 
                    // try in global address-book without zone suffix.
                    cpObject = GetCheckPointObjectOrCreateDummy(source,
                                                                "NetworkGroup",
                                                                juniperRule,
                                                                "Error creating a rule, missing information for source Juniper object",
                                                                "Source object details: " + source + ".");
                }

                cpRule.Source.Add(cpObject);
            }

            foreach (var dest in juniperRule.Destinations)
            {
                string destName = dest;

                if (!isGlobalRule && _juniperParser.IsNetworkObjectContainedInMultipleZones(dest))
                {
                    destName = dest + "_" + destZone;   // original name combined with the zone name
                }

                cpObject = GetCheckPointObjectOrCreateDummy(destName,
                                                            "NetworkGroup",
                                                            juniperRule,
                                                            "Error creating a rule, missing information for destination Juniper object",
                                                            "Destination object details: " + destName + ".",
                                                            isGlobalRule);

                if (!isGlobalRule && cpObject == null)
                {
                    // If the dest object was not found in the address-book of dest-zone, 
                    // try in global address-book without zone suffix.
                    cpObject = GetCheckPointObjectOrCreateDummy(dest,
                                                                "NetworkGroup",
                                                                juniperRule,
                                                                "Error creating a rule, missing information for destination Juniper object",
                                                                "Destination object details: " + dest + ".");
                }

                cpRule.Destination.Add(cpObject);
            }
			
            //add scheduler
            foreach (var scheduler in juniperRule.Scheduler)
            {   
                cpObject = GetCheckPointObjectOrCreateDummy(scheduler,
                                                        "Time",
                                                        juniperRule,
                                                        "Not applying time-range objects.",
                                                        "Appropriate time object should be added manually.");
                cpRule.Time.Add(cpObject);                
              
            }

            // Avoid general "icmp-proto" service duplicates
            bool hasGeneralIcmpService = false;

            foreach (var application in juniperRule.Applications)
            {
                cpObject = GetCheckPointObjectOrCreateDummy(application,
                                                            "ServiceGroup",
                                                            juniperRule,
                                                            "Error creating a rule, missing information for application Juniper object",
                                                            "Application object details: " + application + ".");
                
                if (cpObject.Name == "icmp-proto")
                {
                    if (hasGeneralIcmpService)
                    {
                        continue;
                    }
                    hasGeneralIcmpService = true;
                }

                cpRule.Service.Add(cpObject);
            }

            switch (juniperRule.Action)
            {
                case Juniper_PolicyRule.ActionType.Permit:
                    cpRule.Action = CheckPoint_Rule.ActionType.Accept;
                    break;
                case Juniper_PolicyRule.ActionType.Deny:
                    cpRule.Action = CheckPoint_Rule.ActionType.Drop;
                    break;
                case Juniper_PolicyRule.ActionType.Reject:
                    cpRule.Action = CheckPoint_Rule.ActionType.Reject;
                    break;
                default:
                    cpRule.Action = CheckPoint_Rule.ActionType.Drop;
                    break;
            }

            cpRule.SourceNegated = juniperRule.SourceNegate;
            cpRule.DestinationNegated = juniperRule.DestinationNegate;
            cpRule.Track = juniperRule.Log ? CheckPoint_Rule.TrackTypes.Log : CheckPoint_Rule.TrackTypes.None;

            return cpRule;
        }

        private CheckPoint_Rule Juniper_To_ManagementCPRule(Juniper_PolicyRule juniperRule, string cpLayerName, string sourceZone, CheckPointObject destination)
        {
            var cpRule = new CheckPoint_Rule();
            cpRule.Name = juniperRule.Name;
            cpRule.Layer = cpLayerName;
            cpRule.Enabled = !juniperRule.Inactive;
            cpRule.Destination.Add(destination);
            cpRule.SourceNegated = juniperRule.SourceNegate;
            cpRule.Track = juniperRule.Log ? CheckPoint_Rule.TrackTypes.Log : CheckPoint_Rule.TrackTypes.None;
            cpRule.ConversionComments = "Management Access";

            ApplyConversionIncidentOnCheckPointObject(cpRule, juniperRule);

            CheckPointObject cpObject;

            foreach (var source in juniperRule.Sources)
            {
                string sourceName = source;

                if (_juniperParser.IsNetworkObjectContainedInMultipleZones(source))
                {
                    sourceName = source + "_" + sourceZone;   // original name combined with the zone name
                }

                cpObject = GetCheckPointObjectOrCreateDummy(sourceName,
                                                            "NetworkGroup",
                                                            juniperRule,
                                                            "Error creating a rule, missing information for source Juniper object",
                                                            "Source object details: " + sourceName + ".",
                                                            false);

                if (cpObject == null)
                {
                    // If the source object was not found in the address-book of source-zone, 
                    // try in global address-book without zone suffix.
                    cpObject = GetCheckPointObjectOrCreateDummy(source,
                                                                "NetworkGroup",
                                                                juniperRule,
                                                                "Error creating a rule, missing information for source Juniper object",
                                                                "Source object details: " + source + ".");
                }

                cpRule.Source.Add(cpObject);
            }

            foreach (var application in juniperRule.Applications)
            {
                cpObject = GetCheckPointObjectOrCreateDummy(application,
                                                            "ServiceGroup",
                                                            juniperRule,
                                                            "Error creating a rule, missing information for application Juniper object",
                                                            "Application object details: " + application + ".");
                cpRule.Service.Add(cpObject);
            }

            switch (juniperRule.Action)
            {
                case Juniper_PolicyRule.ActionType.Permit:
                    cpRule.Action = CheckPoint_Rule.ActionType.Accept;
                    break;
                case Juniper_PolicyRule.ActionType.Deny:
                    cpRule.Action = CheckPoint_Rule.ActionType.Drop;
                    break;
                case Juniper_PolicyRule.ActionType.Reject:
                    cpRule.Action = CheckPoint_Rule.ActionType.Reject;
                    break;
                default:
                    cpRule.Action = CheckPoint_Rule.ActionType.Drop;
                    break;
            }

            return cpRule;
        }

        private void Add_Static_NAT()
        {
            foreach (Juniper_StaticNatPolicy natPolicy in _juniperParser.Filter("_StaticNatPolicy"))
            {
                if (natPolicy.IsRoutingInstanceDefined)
                {
                    natPolicy.ConversionIncidentType = ConversionIncidentType.Informative;

                    _conversionIncidents.Add(new ConversionIncident(natPolicy.LineNumber,
                                                                    "Not converting static NAT policy object which specifies a routing instance as a source of the traffic",
                                                                    "All related static NAT rules are skipped.",
                                                                    natPolicy.ConversionIncidentType));

                    continue;
                }

                if (natPolicy.SourceZones.Count == 0 && natPolicy.SourceInterfaces.Count == 0)
                {
                    natPolicy.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                    _conversionIncidents.Add(new ConversionIncident(natPolicy.LineNumber,
                                                                    "Missing a source of the traffic for static NAT policy object",
                                                                    "All related static NAT rules are skipped.",
                                                                    natPolicy.ConversionIncidentType));

                    continue;
                }

                var rulePriority = (natPolicy.SourceInterfaces.Count != 0)
                                       ? JuniperNatCustomData.RulePriority.StaticInterface
                                       : JuniperNatCustomData.RulePriority.StaticZone;

                foreach (var natRule in natPolicy.Rules)
                {
                    if (natRule.NoMatchInfo || natRule.NoActionInfo)
                    {
                        natRule.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                        _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                        natRule.NoMatchInfo ? "Missing match information for static NAT rule object" : "Missing action information for static NAT rule object",
                                                                        "Conversion of static NAT rule is skipped.",
                                                                        natRule.ConversionIncidentType));

                        continue;
                    }

                    var cpNatRule = new CheckPoint_NAT_Rule();
                    cpNatRule.Method = CheckPoint_NAT_Rule.NatMethod.Static;
                    cpNatRule.Enabled = !natRule.Inactive && !natPolicy.Inactive;
                    cpNatRule.Comments = string.Format("Converted from static NAT rule (line {0})", natRule.LineNumber);
                    if (!string.IsNullOrEmpty(natRule.Description))
                    {
                        cpNatRule.Comments = string.Format("{0},  {1}", natRule.Description, cpNatRule.Comments);
                    }

                    cpNatRule.VendorCustomData = new JuniperNatCustomData();
                    ((JuniperNatCustomData)cpNatRule.VendorCustomData).Priority = rulePriority;
                    ((JuniperNatCustomData)cpNatRule.VendorCustomData).SourceZonesOrInterfaces.AddRange(
                        rulePriority == JuniperNatCustomData.RulePriority.StaticZone
                        ? natPolicy.SourceZones
                        : natPolicy.SourceInterfaces);

                    ApplyConversionIncidentOnCheckPointObject(cpNatRule, natRule);

                    // Source
                    cpNatRule.Source = GetNatSourceFromJuniperNatRule(natPolicy, natRule);

                    // Ignore source port and notify user.
                    if (natRule.SourcePorts.Count > 0)
                    {
                        natRule.ConversionIncidentType = ConversionIncidentType.Informative;

                        _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                        "NAT rule points to a source port",
                                                                        "Ignoring source port: " + natRule.SourcePorts[0] + ".",
                                                                        natRule.ConversionIncidentType));
                    }

                    // Destination
                    cpNatRule.Destination = GetNatDestinationFromJuniperNatRule(natPolicy, natRule);

                    // Services
                    // We should create a NAT rule duplicated per service!!!
                    var originalServices = new List<CheckPointObject>();
                    foreach (var destinationPort in natRule.DestinationPorts)
                    {
                        originalServices.AddRange(GetCheckPointServicesFromJuniperNatRulePort(destinationPort));
                    }

                    // Translated destination
                    CheckPointObject translatedDestination = null;

                    if (natRule.TranslatedDestination != null)
                    {
                        translatedDestination = GetCheckPointObjectFromJuniperNatAddress(natRule.TranslatedDestination);
                    }
                    else if (!string.IsNullOrEmpty(natRule.TranslatedDestinationName))
                    {
                        // Lookup for the name in a global address book.
                        translatedDestination = GetCheckPointObjectFromJuniperNatAddressName(natRule.TranslatedDestinationName, natRule);
                    }
                    else
                    {
                        translatedDestination = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                                                 "Host",
                                                                                 natRule,
                                                                                 "Error creating a NAT rule, missing information for Juniper prefix object",
                                                                                 "No prefix was specified.");
                    }

                    cpNatRule.TranslatedDestination = translatedDestination;

                    // Translated services
                    // We should create a NAT rule duplicated per translated service!!!
                    var translatedServices = new List<CheckPointObject>();
                    if (!string.IsNullOrEmpty(natRule.TranslatedPort))
                    {
                        translatedServices.AddRange(GetCheckPointServicesFromJuniperNatRulePort(natRule.TranslatedPort));
                    }

                    //////////////////////////////////////////////////////////////////////////////////////////////
                    // !!! IMPORTANT !!! each NAT rule should be duplicated per original and translated service!!!
                    int originalServicesCounter = 0, originalServicesCount = originalServices.Count;

                    do
                    {
                        int translatedServicesCounter = 0, translatedServicesCount = translatedServices.Count;

                        do
                        {
                            var cpNatRuleDup = cpNatRule.Clone();

                            if (originalServicesCount > 0)
                            {
                                cpNatRuleDup.Service = originalServices[originalServicesCounter];
                            }
                            if (translatedServicesCount > 0)
                            {
                                cpNatRuleDup.TranslatedService = translatedServices[translatedServicesCounter++];
                            }

                            if (cpNatRuleDup.Service != null && cpNatRuleDup.TranslatedService != null)
                            {
                                // Verify that service to translated service flow is for the same protocol - TCP->TCP or UDP->UDP.
                                // Recall that for a given port we've created both TCP and UDP services.
                                if (cpNatRuleDup.Service.Tag == "tcp" && cpNatRuleDup.TranslatedService.Tag != "tcp")
                                {
                                    continue;   // skip this NAT rule!!!
                                }
                                if (cpNatRuleDup.Service.Tag == "udp" && cpNatRuleDup.TranslatedService.Tag != "udp")
                                {
                                    continue;   // skip this NAT rule!!!
                                }
                            }

                            cpNatRuleDup.VendorCustomData = new JuniperNatCustomData();
                            ((JuniperNatCustomData)cpNatRuleDup.VendorCustomData).Priority = ((JuniperNatCustomData)cpNatRule.VendorCustomData).Priority;
                            ((JuniperNatCustomData)cpNatRuleDup.VendorCustomData).SourceZonesOrInterfaces.AddRange(((JuniperNatCustomData)cpNatRule.VendorCustomData).SourceZonesOrInterfaces);

                            // Add a new NAT rule to the collection.
                            _cpPreorderedNatRules.Add(cpNatRuleDup);

                            // Check for conversion incidents.
                            bool natRuleObjectHasConversionIncident = (cpNatRuleDup.Source != null && cpNatRuleDup.Source.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                      (cpNatRuleDup.TranslatedSource != null && cpNatRuleDup.TranslatedSource.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                      (cpNatRuleDup.Destination != null && cpNatRuleDup.Destination.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                      (cpNatRuleDup.TranslatedDestination != null && cpNatRuleDup.TranslatedDestination.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                      (cpNatRuleDup.Service != null && cpNatRuleDup.Service.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                      (cpNatRuleDup.TranslatedService != null && cpNatRuleDup.TranslatedService.ConversionIncidentType != ConversionIncidentType.None);

                            if (cpNatRuleDup.ConversionIncidentType != ConversionIncidentType.None ||
                                natRule.ConversionIncidentType != ConversionIncidentType.None ||
                                natRuleObjectHasConversionIncident)
                            {
                                _hasNATConversionIncident = true;
                            }

                            // Mirrored NAT rule
                            var cpNatMirrorRule = new CheckPoint_NAT_Rule();
                            cpNatMirrorRule.Method = CheckPoint_NAT_Rule.NatMethod.Static;
                            cpNatMirrorRule.Source = cpNatRuleDup.TranslatedDestination;
                            cpNatMirrorRule.Destination = cpNatRuleDup.Source;
                            cpNatMirrorRule.Service = cpNatRuleDup.TranslatedService ?? cpNatRuleDup.Service;
                            cpNatMirrorRule.TranslatedSource = cpNatRuleDup.Destination;
                            cpNatMirrorRule.TranslatedService = (cpNatRuleDup.TranslatedService != null) ? cpNatRuleDup.Service : cpNatRuleDup.TranslatedService;
                            cpNatMirrorRule.Comments = "Mirror rule for static NAT rule";

                            cpNatMirrorRule.VendorCustomData = new JuniperNatCustomData();
                            ((JuniperNatCustomData)cpNatMirrorRule.VendorCustomData).Priority = ((JuniperNatCustomData)cpNatRuleDup.VendorCustomData).Priority;
                            ((JuniperNatCustomData)cpNatMirrorRule.VendorCustomData).IsStaticMirrorRule = true;
                            ((JuniperNatCustomData)cpNatMirrorRule.VendorCustomData).SourceZonesOrInterfaces.AddRange(((JuniperNatCustomData)cpNatRuleDup.VendorCustomData).SourceZonesOrInterfaces);

                            // Add a new mirrored NAT rule to the collection.
                            _cpPreorderedNatRules.Add(cpNatMirrorRule);
                        } while (translatedServicesCounter < translatedServicesCount);

                        ++originalServicesCounter;
                    } while (originalServicesCounter < originalServicesCount);
                    // !!! IMPORTANT !!!
                    //////////////////////////////////////////////////////////////////////////////////////////////
                }
            }
        }

        private void Add_Destination_NAT()
        {
            var natPool = _juniperParser.Filter("_DestinationNatPool");

            foreach (Juniper_DestinationNatPolicy natPolicy in _juniperParser.Filter("_DestinationNatPolicy"))
            {
                if (natPolicy.IsRoutingInstanceDefined)
                {
                    natPolicy.ConversionIncidentType = ConversionIncidentType.Informative;

                    _conversionIncidents.Add(new ConversionIncident(natPolicy.LineNumber,
                                                                    "Not converting destination NAT policy object which specifies a routing instance as a source of the traffic",
                                                                    "All related destination NAT rules are skipped.",
                                                                    natPolicy.ConversionIncidentType));

                    continue;
                }

                if (natPolicy.SourceZones.Count == 0 && natPolicy.SourceInterfaces.Count == 0)
                {
                    natPolicy.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                    _conversionIncidents.Add(new ConversionIncident(natPolicy.LineNumber,
                                                                    "Missing a source of the traffic for destination NAT policy object",
                                                                    "All related destination NAT rules are skipped.",
                                                                    natPolicy.ConversionIncidentType));

                    continue;
                }

                var rulePriority = (natPolicy.SourceInterfaces.Count != 0)
                                       ? JuniperNatCustomData.RulePriority.DestinationInterface
                                       : JuniperNatCustomData.RulePriority.DestinationZone;

                foreach (var natRule in natPolicy.Rules)
                {
                    if (natRule.NoMatchInfo || natRule.NoActionInfo)
                    {
                        natRule.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                        _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                        natRule.NoMatchInfo ? "Missing match information for destination NAT rule object" : "Missing action information for destination NAT rule object",
                                                                        "Conversion of destination NAT rule is skipped.",
                                                                        natRule.ConversionIncidentType));

                        continue;
                    }

                    var cpNatRule = new CheckPoint_NAT_Rule();
                    cpNatRule.Method = CheckPoint_NAT_Rule.NatMethod.Static;
                    cpNatRule.Enabled = !natRule.Inactive && !natPolicy.Inactive;
                    cpNatRule.Comments = cpNatRule.Comments = string.Format("Converted from destination NAT rule (line {0})", natRule.LineNumber);
                    if (!string.IsNullOrEmpty(natRule.Description))
                    {
                        cpNatRule.Comments = string.Format("{0},  {1}", natRule.Description, cpNatRule.Comments);
                    }

                    cpNatRule.VendorCustomData = new JuniperNatCustomData();
                    ((JuniperNatCustomData)cpNatRule.VendorCustomData).Priority = rulePriority;
                    ((JuniperNatCustomData)cpNatRule.VendorCustomData).SourceZonesOrInterfaces.AddRange(
                        rulePriority == JuniperNatCustomData.RulePriority.DestinationZone
                        ? natPolicy.SourceZones
                        : natPolicy.SourceInterfaces);

                    ApplyConversionIncidentOnCheckPointObject(cpNatRule, natRule);

                    // Source
                    cpNatRule.Source = GetNatSourceFromJuniperNatRule(natPolicy, natRule);

                    // Ignore source port and notify user.
                    if (natRule.SourcePorts.Count > 0)
                    {
                        natRule.ConversionIncidentType = ConversionIncidentType.Informative;

                        _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                        "NAT rule points to a source port",
                                                                        "Ignoring source port: " + natRule.SourcePorts[0] + ".",
                                                                        natRule.ConversionIncidentType));
                    }

                    // Destination
                    cpNatRule.Destination = GetNatDestinationFromJuniperNatRule(natPolicy, natRule);

                    // Services
                    // We should create a NAT rule duplicated per service!!!
                    var originalServices = new List<CheckPointObject>();
                    if (natRule.DestinationPorts.Count > 0 || natRule.Protocols.Count > 0 || natRule.Applications.Count > 0)
                    {
                        if (natRule.Protocols.Count > 0)
                        {
                            originalServices.AddRange(GetCheckPointServicesFromJuniperNatRule(natRule.Protocols, natRule.DestinationPorts));
                        }
                        else
                        {
                            foreach (var destinationPort in natRule.DestinationPorts)
                            {
                                originalServices.AddRange(GetCheckPointServicesFromJuniperNatRulePort(destinationPort));
                            }
                        }

                        foreach (var application in natRule.Applications)
                        {
                            var cpServive = GetCheckPointServiceFromJuniperNatRuleApplication(application);
                            if (cpServive == null)
                            {
                                cpServive = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                                             "ServiceGroup",
                                                                             natRule,
                                                                             "Error creating a NAT rule, missing information for Juniper NAT application",
                                                                             "Application details: " + application + ".");
                            }

                            originalServices.Add(cpServive);
                        }
                    }

                    string destinationPoolPort = "";

                    // Translated destination
                    if (natRule.TranslateDestination)
                    {
                        CheckPointObject translatedDestination = null;

                        if (!string.IsNullOrEmpty(natRule.TranslatedDestination))
                        {
                            foreach (Juniper_DestinationNatPool pool in natPool)
                            {
                                if (pool.Name == natRule.TranslatedDestination)
                                {
                                    if (pool.Address != null)
                                    {
                                        translatedDestination = GetCheckPointObjectFromJuniperNatPoolAddress(pool.Address);
                                        if (translatedDestination != null)
                                        {
                                            translatedDestination.Name = pool.Name;
                                            CheckObjectNameValidity(translatedDestination, pool, false, true);
                                            AddCheckPointObject(translatedDestination);
                                        }
                                    }

                                    if (!string.IsNullOrEmpty(pool.Port))
                                    {
                                        destinationPoolPort = pool.Port;
                                    }

                                    break;
                                }
                            }
                        }

                        if (translatedDestination == null)
                        {
                            translatedDestination = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                                                     "Host",
                                                                                     natRule,
                                                                                     "Error creating a NAT rule, missing information for Juniper NAT pool object",
                                                                                     "Pool details: " + natRule.TranslatedDestination + ".");
                        }

                        cpNatRule.TranslatedDestination = translatedDestination;
                    }

                    // Translated services
                    // We should create a NAT rule duplicated per translated service!!!
                    var translatedServices = new List<CheckPointObject>();
                    if (!string.IsNullOrEmpty(destinationPoolPort))
                    {
                        translatedServices.AddRange(GetCheckPointServicesFromJuniperNatRulePort(destinationPoolPort));
                    }

                    //////////////////////////////////////////////////////////////////////////////////////////////
                    // !!! IMPORTANT !!! each NAT rule should be duplicated per original and translated service!!!
                    int originalServicesCounter = 0, originalServicesCount = originalServices.Count;

                    do
                    {
                        int translatedServicesCounter = 0, translatedServicesCount = translatedServices.Count;

                        do
                        {
                            var cpNatRuleDup = cpNatRule.Clone();

                            if (originalServicesCount > 0)
                            {
                                cpNatRuleDup.Service = originalServices[originalServicesCounter];
                            }
                            if (translatedServicesCount > 0)
                            {
                                cpNatRuleDup.TranslatedService = translatedServices[translatedServicesCounter++];
                            }

                            if (cpNatRuleDup.Service != null && cpNatRuleDup.TranslatedService != null)
                            {
                                // Verify that service to translated service flow is for the same protocol - TCP->TCP or UDP->UDP.
                                // Recall that for a given port we've created both TCP and UDP services.
                                if (cpNatRuleDup.Service.Tag == "tcp" && cpNatRuleDup.TranslatedService.Tag != "tcp")
                                {
                                    continue;   // skip this NAT rule!!!
                                }
                                if (cpNatRuleDup.Service.Tag == "udp" && cpNatRuleDup.TranslatedService.Tag != "udp")
                                {
                                    continue;   // skip this NAT rule!!!
                                }
                            }

                            cpNatRuleDup.VendorCustomData = new JuniperNatCustomData();
                            ((JuniperNatCustomData)cpNatRuleDup.VendorCustomData).Priority = ((JuniperNatCustomData)cpNatRule.VendorCustomData).Priority;
                            ((JuniperNatCustomData)cpNatRuleDup.VendorCustomData).SourceZonesOrInterfaces.AddRange(((JuniperNatCustomData)cpNatRule.VendorCustomData).SourceZonesOrInterfaces);

                            // Add a new NAT rule to the collection.
                            _cpPreorderedNatRules.Add(cpNatRuleDup);

                            // Check for conversion incidents.
                            bool natRuleObjectHasConversionIncident = (cpNatRuleDup.Source != null && cpNatRuleDup.Source.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                      (cpNatRuleDup.TranslatedSource != null && cpNatRuleDup.TranslatedSource.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                      (cpNatRuleDup.Destination != null && cpNatRuleDup.Destination.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                      (cpNatRuleDup.TranslatedDestination != null && cpNatRuleDup.TranslatedDestination.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                      (cpNatRuleDup.Service != null && cpNatRuleDup.Service.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                      (cpNatRuleDup.TranslatedService != null && cpNatRuleDup.TranslatedService.ConversionIncidentType != ConversionIncidentType.None);

                            if (cpNatRuleDup.ConversionIncidentType != ConversionIncidentType.None ||
                                natRule.ConversionIncidentType != ConversionIncidentType.None ||
                                natRuleObjectHasConversionIncident)
                            {
                                _hasNATConversionIncident = true;
                            }
                        } while (translatedServicesCounter < translatedServicesCount);

                        ++originalServicesCounter;
                    } while (originalServicesCounter < originalServicesCount);
                    // !!! IMPORTANT !!!
                    //////////////////////////////////////////////////////////////////////////////////////////////
                }
            }
        }

        private void Add_Source_NAT()
        {
            var natPool = _juniperParser.Filter("_SourceNatPool");

            foreach (Juniper_SourceNatPolicy natPolicy in _juniperParser.Filter("_SourceNatPolicy"))
            {
                if (natPolicy.IsRoutingInstanceDefined)
                {
                    natPolicy.ConversionIncidentType = ConversionIncidentType.Informative;

                    _conversionIncidents.Add(new ConversionIncident(natPolicy.LineNumber,
                                                                    "Not converting source NAT policy object which specifies a routing instance as a source of the traffic",
                                                                    "All related source NAT rules are skipped.",
                                                                    natPolicy.ConversionIncidentType));

                    continue;
                }

                if (natPolicy.SourceZones.Count == 0 && natPolicy.SourceInterfaces.Count == 0)
                {
                    natPolicy.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                    _conversionIncidents.Add(new ConversionIncident(natPolicy.LineNumber,
                                                                    "Missing a source of the traffic for source NAT policy object",
                                                                    "All related source NAT rules are skipped.",
                                                                    natPolicy.ConversionIncidentType));

                    continue;
                }

                if (natPolicy.DestinationZones.Count == 0 && natPolicy.DestinationInterfaces.Count == 0)
                {
                    natPolicy.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                    _conversionIncidents.Add(new ConversionIncident(natPolicy.LineNumber,
                                                                    "Missing a destination of the traffic for source NAT policy object",
                                                                    "All related source NAT rules are skipped.",
                                                                    natPolicy.ConversionIncidentType));

                    continue;
                }

                JuniperNatCustomData.RulePriority rulePriority;

                if (natPolicy.SourceInterfaces.Count != 0 && natPolicy.DestinationInterfaces.Count != 0)
                {
                    rulePriority = JuniperNatCustomData.RulePriority.SourceInterface2Interface;
                }
                else if (natPolicy.SourceZones.Count != 0 && natPolicy.DestinationZones.Count != 0)
                {
                    rulePriority = JuniperNatCustomData.RulePriority.SourceZone2Zone;
                }
                else
                {
                    rulePriority = JuniperNatCustomData.RulePriority.SourceMixed;
                }

                foreach (var natRule in natPolicy.Rules)
                {
                    if (natRule.NoMatchInfo || natRule.NoActionInfo)
                    {
                        natRule.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                        _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                        natRule.NoMatchInfo ? "Missing match information for source NAT rule object" : "Missing action information for source NAT rule object",
                                                                        "Conversion of source NAT rule is skipped.",
                                                                        natRule.ConversionIncidentType));

                        continue;
                    }

                    var cpNatRule = new CheckPoint_NAT_Rule();
                    cpNatRule.Method = CheckPoint_NAT_Rule.NatMethod.Hide;
                    cpNatRule.Enabled = !natRule.Inactive && !natPolicy.Inactive;
                    cpNatRule.Comments = cpNatRule.Comments = string.Format("Converted from source NAT rule (line {0})", natRule.LineNumber);
                    if (!string.IsNullOrEmpty(natRule.Description))
                    {
                        cpNatRule.Comments = string.Format("{0},  {1}", natRule.Description, cpNatRule.Comments);
                    }

                    cpNatRule.VendorCustomData = new JuniperNatCustomData();
                    ((JuniperNatCustomData)cpNatRule.VendorCustomData).Priority = rulePriority;

                    ApplyConversionIncidentOnCheckPointObject(cpNatRule, natRule);

                    // Source
                    cpNatRule.Source = GetNatSourceFromJuniperNatRule(natPolicy, natRule);

                    // Ignore source port and notify user.
                    if (natRule.SourcePorts.Count > 0)
                    {
                        natRule.ConversionIncidentType = ConversionIncidentType.Informative;

                        _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                        "NAT rule points to a source port",
                                                                        "Ignoring source port: " + natRule.SourcePorts[0] + ".",
                                                                        natRule.ConversionIncidentType));
                    }

                    // Destination
                    cpNatRule.Destination = GetNatDestinationFromJuniperNatRule(natPolicy, natRule);

                    // Services
                    // We should create a NAT rule duplicated per service!!!
                    var originalServices = new List<CheckPointObject>();
                    if (natRule.DestinationPorts.Count > 0 || natRule.Protocols.Count > 0 || natRule.Applications.Count > 0)
                    {
                        if (natRule.Protocols.Count > 0)
                        {
                            originalServices.AddRange(GetCheckPointServicesFromJuniperNatRule(natRule.Protocols, natRule.DestinationPorts));
                        }
                        else
                        {
                            foreach (var destinationPort in natRule.DestinationPorts)
                            {
                                originalServices.AddRange(GetCheckPointServicesFromJuniperNatRulePort(destinationPort));
                            }
                        }

                        foreach (var application in natRule.Applications)
                        {
                            var cpServive = GetCheckPointServiceFromJuniperNatRuleApplication(application);
                            if (cpServive == null)
                            {
                                cpServive = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                                             "ServiceGroup",
                                                                             natRule,
                                                                             "Error creating a NAT rule, missing information for Juniper NAT application",
                                                                             "Application details: " + application + ".");
                            }

                            originalServices.Add(cpServive);
                        }
                    }

                    // Translated source
                    switch (natRule.TranslationMode)
                    {
                        case Juniper_SourceNatRule.SourceTranslationMode.Pool:
                            cpNatRule.TranslatedSource = GetNatTranslatedSourceFromJuniperSourceNatPool(natPool, natRule, cpNatRule);
                            break;

                        case Juniper_SourceNatRule.SourceTranslationMode.Interface:
                            cpNatRule.TranslatedSource = GetNatTranslatedSourceFromJuniperSourceNatInterface(natPolicy, natRule, cpNatRule);
                            break;
                    }

                    ///////////////////////////////////////////////////////////////////////////////
                    // !!! IMPORTANT !!! each NAT rule should be duplicated per original service!!!
                    int originalServicesCounter = 0, originalServicesCount = originalServices.Count;

                    do
                    {
                        var cpNatRuleDup = cpNatRule.Clone();

                        cpNatRuleDup.VendorCustomData = new JuniperNatCustomData();
                        ((JuniperNatCustomData)cpNatRuleDup.VendorCustomData).Priority = ((JuniperNatCustomData)cpNatRule.VendorCustomData).Priority;

                        if (originalServicesCount > 0)
                        {
                            cpNatRuleDup.Service = originalServices[originalServicesCounter];
                        }

                        // Add a new NAT rule to the collection.
                        _cpPreorderedNatRules.Add(cpNatRuleDup);

                        // Check for conversion incidents.
                        bool natRuleObjectHasConversionIncident = (cpNatRuleDup.Source != null && cpNatRuleDup.Source.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                  (cpNatRuleDup.TranslatedSource != null && cpNatRuleDup.TranslatedSource.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                  (cpNatRuleDup.Destination != null && cpNatRuleDup.Destination.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                  (cpNatRuleDup.TranslatedDestination != null && cpNatRuleDup.TranslatedDestination.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                  (cpNatRuleDup.Service != null && cpNatRuleDup.Service.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                  (cpNatRuleDup.TranslatedService != null && cpNatRuleDup.TranslatedService.ConversionIncidentType != ConversionIncidentType.None);

                        if (cpNatRuleDup.ConversionIncidentType != ConversionIncidentType.None ||
                            natRule.ConversionIncidentType != ConversionIncidentType.None ||
                            natRuleObjectHasConversionIncident)
                        {
                            _hasNATConversionIncident = true;
                        }

                        ++originalServicesCounter;
                    } while (originalServicesCounter < originalServicesCount);
                    // !!! IMPORTANT !!!
                    ///////////////////////////////////////////////////////////////////////////////
                }
            }
        }

        private CheckPointObject GetJuniperManagementHost()
        {
            foreach (Juniper_Interface ifc in JuniperInterfaces)
            {
                if (ifc.Name.StartsWith(JuniperObject.AccessManagementInterfaceName))
                {
                    return _cpObjects.GetObject(ifc.Name + "_address");
                }
            }

            return null;
        }

        private CheckPointObject GetNatSourceFromJuniperNatRule(Juniper_NatPolicy natPolicy, Juniper_NatRule natRule)
        {
            CheckPointObject natSource = null;

            if (natRule.SourceAddressNames.Count > 0 || natRule.SourceAddresses.Count > 0)
            {
                if (natRule.SourceAddressNames.Count + natRule.SourceAddresses.Count > 1)
                {
                    // Create a network group object to hold the source subnets list.
                    var cpNetworkGroup = new CheckPoint_NetworkGroup();
                    cpNetworkGroup.Name = NetworkObjectNameGenerator.AutoGeneratedNetworkGroupName();

                    foreach (var sourceAddressName in natRule.SourceAddressNames)
                    {
                        var cpObject = GetCheckPointObjectFromJuniperNatAddressName(sourceAddressName, natRule);
                        cpNetworkGroup.Members.Add(cpObject.Name);

                        if (cpObject.Name.Contains(AutoGeneratedNameWithError))
                        {
                            cpNetworkGroup.ConvertedCommandId = natRule.LineNumber;
                            cpNetworkGroup.ConversionIncidentType = cpObject.ConversionIncidentType;

                            _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                            "Error creating a NAT rule, network group object used as an original source has a member object with an error due to source address name.",
                                                                            "Network group object details: " + cpNetworkGroup.Name + ", Source address name: " + sourceAddressName + ".",
                                                                            cpNetworkGroup.ConversionIncidentType));
                        }
                    }

                    foreach (var sourceAddress in natRule.SourceAddresses)
                    {
                        var cpObject = GetCheckPointObjectFromJuniperNatAddress(sourceAddress);
                        cpNetworkGroup.Members.Add(cpObject.Name);
                    }

                    AddCheckPointObject(cpNetworkGroup);
                    natSource = cpNetworkGroup;
                }
                else if (natRule.SourceAddressNames.Count > 0)
                {
                    // Lookup for the name in a global address book.
                    natSource = GetCheckPointObjectFromJuniperNatAddressName(natRule.SourceAddressNames[0], natRule);
                }
                else   // SourceAddress
                {
                    // Create a host/network object as a source object for NAT rule.
                    natSource = GetCheckPointObjectFromJuniperNatAddress(natRule.SourceAddresses[0]);
                }
            }
            else   // no source addresses...
            {
                // Use a network group associated with a source zone/interface.
                if (natPolicy.SourceZones.Count > 0)
                {
                    bool sourceZoneLeadsToInternet = false;

                    // Create a network group object to wrap the network groups associated with source zones.
                    var cpNetworkGroup = new CheckPoint_NetworkGroup();
                    cpNetworkGroup.Name = NetworkObjectNameGenerator.AutoGeneratedNetworkGroupName();
                    cpNetworkGroup.CreateAfterGroupsWithExclusion = true;

                    foreach (var zoneName in natPolicy.SourceZones)
                    {
                        foreach (Juniper_Zone zone in JuniperZones)
                        {
                            if (zoneName == zone.Name)
                            {
                                if (zone.LeadsToInternet)
                                {
                                    sourceZoneLeadsToInternet = true;
                                }
                                else
                                {
                                    string zoneGroupName = "zone_" + zoneName + "_subnets";
                                    var cpObject = GetCheckPointObjectOrCreateDummy(zoneGroupName,
                                                                                    "NetworkGroup",
                                                                                    natRule,
                                                                                    "Error creating a NAT rule, missing interfaces information for Juniper source zone",
                                                                                    "Source zone details: " + zoneName + ".");
                                    cpNetworkGroup.Members.Add(cpObject.Name);

                                    if (cpObject.Name.Contains(AutoGeneratedNameWithError))
                                    {
                                        cpNetworkGroup.ConvertedCommandId = natRule.LineNumber;
                                        cpNetworkGroup.ConversionIncidentType = cpObject.ConversionIncidentType;

                                        _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                                        "Error creating a NAT rule, network group object used as an original source has a member object with an error due to source zone.",
                                                                                        "Network group object details: " + cpNetworkGroup.Name + ", Source zone name: " + zoneName + ".",
                                                                                        cpNetworkGroup.ConversionIncidentType));
                                    }
                                }

                                break;
                            }
                        }

                        if (sourceZoneLeadsToInternet)
                        {
                            break;
                        }
                    }

                    if (sourceZoneLeadsToInternet)
                    {
                        natSource = _cpObjects.GetObject(CheckPointObject.Any);
                    }
                    else
                    {
                        if (cpNetworkGroup.Members.Count > 1)
                        {
                            AddCheckPointObject(cpNetworkGroup);
                            natSource = cpNetworkGroup;
                        }
                        else
                        {
                            // No need to create a wrapper network group for a single source zone...
                            // Just use the network group associated with a source zone directly.
                            natSource = GetCheckPointObjectOrCreateDummy("zone_" + natPolicy.SourceZones[0] + "_subnets",
                                                                         "NetworkGroup",
                                                                         natPolicy,
                                                                         "Error creating a NAT rule, missing interfaces information for Juniper source zone",
                                                                         "Source zone details: " + natPolicy.SourceZones[0] + ".");
                        }
                    }
                }
                else   // SourceInterfaces
                {
                    bool sourceInterfaceLeadsToInternet = false;

                    // Create a network group object to wrap the network groups associated with source interfaces.
                    var cpNetworkGroup = new CheckPoint_NetworkGroup();
                    cpNetworkGroup.Name = NetworkObjectNameGenerator.AutoGeneratedNetworkGroupName();

                    foreach (var ifcName in natPolicy.SourceInterfaces)
                    {
                        foreach (Juniper_Interface ifc in JuniperInterfaces)
                        {
                            if (ifcName == ifc.Name)
                            {
                                if (ifc.LeadsToInternet)
                                {
                                    sourceInterfaceLeadsToInternet = true;
                                }
                                else
                                {
                                    string interfaceGroupName = ifcName + "_subnets";
                                    var cpObject = GetCheckPointObjectOrCreateDummy(interfaceGroupName,
                                                                                    "NetworkGroup",
                                                                                    natRule,
                                                                                    "Error creating a NAT rule, missing topology information for Juniper source interface",
                                                                                    "Source interface details: " + ifcName + ".");
                                    cpNetworkGroup.Members.Add(cpObject.Name);

                                    if (cpObject.Name.Contains(AutoGeneratedNameWithError))
                                    {
                                        cpNetworkGroup.ConvertedCommandId = natRule.LineNumber;
                                        cpNetworkGroup.ConversionIncidentType = cpObject.ConversionIncidentType;

                                        _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                                        "Error creating a NAT rule, network group object used as an original source has a member object with an error due to source interface.",
                                                                                        "Network group object details: " + cpNetworkGroup.Name + ", Source interface name: " + ifcName + ".",
                                                                                        cpNetworkGroup.ConversionIncidentType));
                                    }
                                }

                                break;
                            }
                        }

                        if (sourceInterfaceLeadsToInternet)
                        {
                            break;
                        }
                    }

                    if (sourceInterfaceLeadsToInternet)
                    {
                        natSource = _cpObjects.GetObject(CheckPointObject.Any);
                    }
                    else
                    {
                        if (cpNetworkGroup.Members.Count > 1)
                        {
                            AddCheckPointObject(cpNetworkGroup);
                            natSource = cpNetworkGroup;
                        }
                        else
                        {
                            // No need to create a wrapper network group for a single source interface...
                            // Just use the network group associated with a source interface directly.
                            natSource = GetCheckPointObjectOrCreateDummy(natPolicy.SourceInterfaces[0] + "_subnets",
                                                                         "NetworkGroup",
                                                                         natRule,
                                                                         "Error creating a NAT rule, missing topology information for Juniper source interface",
                                                                         "Source interface details: " + natPolicy.SourceInterfaces[0] + ".");
                        }
                    }
                }
            }

            return natSource;
        }

        private CheckPointObject GetNatDestinationFromJuniperNatRule(Juniper_NatPolicy natPolicy, Juniper_NatRule natRule)
        {
            CheckPointObject natDestination = null;

            if (natRule.DestinationAddressNames.Count > 0 || natRule.DestinationAddresses.Count > 0)
            {
                if (natRule.DestinationAddressNames.Count + natRule.DestinationAddresses.Count > 1)
                {
                    // Create a network group object to hold the destination subnets list.
                    var cpNetworkGroup = new CheckPoint_NetworkGroup();
                    cpNetworkGroup.Name = NetworkObjectNameGenerator.AutoGeneratedNetworkGroupName();

                    foreach (var destinationAddressName in natRule.DestinationAddressNames)
                    {
                        var cpObject = GetCheckPointObjectFromJuniperNatAddressName(destinationAddressName, natRule);
                        cpNetworkGroup.Members.Add(cpObject.Name);

                        if (cpObject.Name.Contains(AutoGeneratedNameWithError))
                        {
                            cpNetworkGroup.ConvertedCommandId = natRule.LineNumber;
                            cpNetworkGroup.ConversionIncidentType = cpObject.ConversionIncidentType;

                            _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                            "Error creating a NAT rule, network group object used as an original destination has a member object with an error due to destination address name.",
                                                                            "Network group object details: " + cpNetworkGroup.Name + ", Destination address name: " + destinationAddressName + ".",
                                                                            cpNetworkGroup.ConversionIncidentType));
                        }
                    }

                    foreach (var destinationAddress in natRule.DestinationAddresses)
                    {
                        var cpObject = GetCheckPointObjectFromJuniperNatAddress(destinationAddress);
                        cpNetworkGroup.Members.Add(cpObject.Name);
                    }

                    AddCheckPointObject(cpNetworkGroup);
                    natDestination = cpNetworkGroup;
                }
                else if (natRule.DestinationAddressNames.Count > 0)
                {
                    // Lookup for the name in a global address book.
                    natDestination = GetCheckPointObjectFromJuniperNatAddressName(natRule.DestinationAddressNames[0], natRule);
                }
                else   // DestinationAddress
                {
                    // Create a host/network object as a destination object for NAT rule.
                    natDestination = GetCheckPointObjectFromJuniperNatAddress(natRule.DestinationAddresses[0]);
                }
            }
            else   // no destination addresses...
            {
                if (natPolicy is Juniper_SourceNatPolicy)
                {
                    var sourceNatPolicy = natPolicy as Juniper_SourceNatPolicy;

                    // Use a network group associated with a destination zone/interface.
                    if (sourceNatPolicy.DestinationZones.Count > 0)
                    {
                        bool destinationZoneLeadsToInternet = false;

                        // Create a network group object to hold the network groups associated with a destination zone.
                        var cpNetworkGroup = new CheckPoint_NetworkGroup();
                        cpNetworkGroup.Name = NetworkObjectNameGenerator.AutoGeneratedNetworkGroupName();
                        cpNetworkGroup.CreateAfterGroupsWithExclusion = true;

                        foreach (var zoneName in sourceNatPolicy.DestinationZones)
                        {
                            foreach (Juniper_Zone zone in JuniperZones)
                            {
                                if (zoneName == zone.Name)
                                {
                                    if (zone.LeadsToInternet)
                                    {
                                        destinationZoneLeadsToInternet = true;
                                    }
                                    else
                                    {
                                        string zoneGroupName = "zone_" + zoneName + "_subnets";
                                        var cpObject = GetCheckPointObjectOrCreateDummy(zoneGroupName,
                                                                                        "NetworkGroup",
                                                                                        natRule,
                                                                                        "Error creating a NAT rule, missing interfaces information for Juniper destination zone",
                                                                                        "Destination zone details: " + zoneName + ".");
                                        cpNetworkGroup.Members.Add(cpObject.Name);

                                        if (cpObject.Name.Contains(AutoGeneratedNameWithError))
                                        {
                                            cpNetworkGroup.ConvertedCommandId = natRule.LineNumber;
                                            cpNetworkGroup.ConversionIncidentType = cpObject.ConversionIncidentType;

                                            _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                                            "Error creating a NAT rule, network group object used as an original destination has a member object with an error due to destination zone.",
                                                                                            "Network group object details: " + cpNetworkGroup.Name + ", Destination zone name: " + zoneName + ".",
                                                                                            cpNetworkGroup.ConversionIncidentType));
                                        }
                                    }

                                    break;
                                }
                            }

                            if (destinationZoneLeadsToInternet)
                            {
                                break;
                            }
                        }

                        if (destinationZoneLeadsToInternet)
                        {
                            natDestination = _cpObjects.GetObject(CheckPointObject.Any);
                        }
                        else
                        {
                            if (cpNetworkGroup.Members.Count > 1)
                            {
                                AddCheckPointObject(cpNetworkGroup);
                                natDestination = cpNetworkGroup;
                            }
                            else
                            {
                                // No need to create a wrapper network group for a single destination zone...
                                // Just use the network group associated with a destination zone directly.
                                natDestination = GetCheckPointObjectOrCreateDummy("zone_" + sourceNatPolicy.DestinationZones[0] + "_subnets",
                                                                                  "NetworkGroup",
                                                                                  natRule,
                                                                                  "Error creating a NAT rule, missing interfaces information for Juniper destination zone",
                                                                                  "Destination zone details: " + sourceNatPolicy.DestinationZones[0] + ".");
                            }
                        }
                    }
                    else   // DestinationInterfaces
                    {
                        bool destinationInterfaceLeadsToInternet = false;

                        // Create a network group object to wrap the network groups associated with a destination interfaces.
                        var cpNetworkGroup = new CheckPoint_NetworkGroup();
                        cpNetworkGroup.Name = NetworkObjectNameGenerator.AutoGeneratedNetworkGroupName();

                        foreach (var ifcName in sourceNatPolicy.DestinationInterfaces)
                        {
                            foreach (Juniper_Interface ifc in JuniperInterfaces)
                            {
                                if (ifcName == ifc.Name)
                                {
                                    if (ifc.LeadsToInternet)
                                    {
                                        destinationInterfaceLeadsToInternet = true;
                                    }
                                    else
                                    {
                                        string interfaceGroupName = ifcName + "_subnets";
                                        var cpObject = GetCheckPointObjectOrCreateDummy(interfaceGroupName,
                                                                                        "NetworkGroup",
                                                                                        natRule,
                                                                                        "Error creating a NAT rule, missing topology information for Juniper destination interface",
                                                                                        "Destination interface details: " + ifcName + ".");
                                        cpNetworkGroup.Members.Add(cpObject.Name);

                                        if (cpObject.Name.Contains(AutoGeneratedNameWithError))
                                        {
                                            cpNetworkGroup.ConvertedCommandId = natRule.LineNumber;
                                            cpNetworkGroup.ConversionIncidentType = cpObject.ConversionIncidentType;

                                            _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                                            "Error creating a NAT rule, network group object used as an original destination has a member object with an error due to destination interface.",
                                                                                            "Network group object details: " + cpNetworkGroup.Name + ", Destination interface name: " + ifcName + ".",
                                                                                            cpNetworkGroup.ConversionIncidentType));
                                        }
                                    }

                                    break;
                                }
                            }

                            if (destinationInterfaceLeadsToInternet)
                            {
                                break;
                            }
                        }

                        if (destinationInterfaceLeadsToInternet)
                        {
                            natDestination = _cpObjects.GetObject(CheckPointObject.Any);
                        }
                        else
                        {
                            if (cpNetworkGroup.Members.Count > 1)
                            {
                                AddCheckPointObject(cpNetworkGroup);
                                natDestination = cpNetworkGroup;
                            }
                            else
                            {
                                // No need to create a wrapper network group for a single destination interface...
                                // Just use the network group associated with a destination interface directly.
                                natDestination = GetCheckPointObjectOrCreateDummy(sourceNatPolicy.DestinationInterfaces[0] + "_subnets",
                                                                                  "NetworkGroup",
                                                                                  natRule,
                                                                                  "Error creating a NAT rule, missing topology information for Juniper destination interface",
                                                                                  "Destination interface details: " + sourceNatPolicy.DestinationInterfaces[0] + ".");
                            }
                        }
                    }
                }
                else
                {
                    natRule.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                    _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                    "Error creating a NAT rule, missing information for Juniper destination address",
                                                                    "No destination address was specified.",
                                                                    natRule.ConversionIncidentType));
                }
            }

            return natDestination;
        }

        private CheckPointObject GetNatTranslatedSourceFromJuniperSourceNatPool(IEnumerable<JuniperObject> natPool, Juniper_SourceNatRule natRule, CheckPoint_NAT_Rule cpNatRule)
        {
            if (string.IsNullOrEmpty(natRule.TranslatedSource))
            {
                return GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                        "Host",
                                                        natRule,
                                                        "Error creating a NAT rule, missing information for Juniper NAT pool object",
                                                        "No pool object was specified.");
            }

            CheckPointObject translatedSource = null;

            foreach (Juniper_SourceNatPool pool in natPool)
            {
                if (pool.Name == natRule.TranslatedSource)
                {
                    if (pool.Addresses.Count > 0)
                    {
                        translatedSource = GetCheckPointObjectFromJuniperNatPoolAddress(pool.Addresses[0]);
                        if (translatedSource != null)
                        {
                            translatedSource.Name = pool.Name;
                            CheckObjectNameValidity(translatedSource, pool, false, true);
                            AddCheckPointObject(translatedSource);

                            if (!string.IsNullOrEmpty(pool.HostAddressBase))
                            {
                                // We need to create a new original source object with the same network size
                                // as the translated source object!!!
                                // In addition, the converted NAT rule should be static.
                                CheckPointObject originalSource = null;

                                switch (pool.Addresses[0].AddressType)
                                {
                                    case Juniper_NatPool.PoolAddress.NetworkType.Host:
                                        originalSource = new CheckPoint_Host();
                                        ((CheckPoint_Host)originalSource).IpAddress = pool.HostAddressBase;
                                        originalSource.Name = "host_" + ((CheckPoint_Host)originalSource).IpAddress;
                                        break;

                                    case Juniper_NatPool.PoolAddress.NetworkType.Subnet:
                                        originalSource = new CheckPoint_Range();
                                        ((CheckPoint_Range)originalSource).RangeFrom = pool.HostAddressBase;
                                        ((CheckPoint_Range)originalSource).RangeTo = IPNetwork.Parse(pool.HostAddressBase, pool.Addresses[0].Netmask).Broadcast.ToString();
                                        originalSource.Name = "r_" + ((CheckPoint_Range)originalSource).RangeFrom + "-" + ((CheckPoint_Range)originalSource).RangeTo;
                                        break;

                                    case Juniper_NatPool.PoolAddress.NetworkType.Range:
                                        originalSource = new CheckPoint_Range();
                                        ((CheckPoint_Range)originalSource).RangeFrom = pool.HostAddressBase;
                                        ((CheckPoint_Range)originalSource).RangeTo = IPNetwork.Parse(pool.HostAddressBase, NetworkUtils.NetworkRange2Netmask(pool.Addresses[0].IpAddress, pool.Addresses[0].RangeTo)).Broadcast.ToString();
                                        originalSource.Name = "r_" + ((CheckPoint_Range)originalSource).RangeFrom + "-" + ((CheckPoint_Range)originalSource).RangeTo;
                                        break;
                                }

                                AddCheckPointObject(originalSource);

                                cpNatRule.Source = originalSource;
                                cpNatRule.Method = CheckPoint_NAT_Rule.NatMethod.Static;
                            }
                        }

                        if (pool.Addresses.Count > 1)
                        {
                            natRule.ConversionIncidentType = ConversionIncidentType.Informative;

                            _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                            "Source NAT rule points to a pool with multiple addresses",
                                                                            "Using first address for translated source.",
                                                                            natRule.ConversionIncidentType));
                        }
                    }

                    if (!pool.TranslatePort)
                    {
                        cpNatRule.Method = CheckPoint_NAT_Rule.NatMethod.Static;
                    }

                    break;
                }
            }

            if (translatedSource == null)
            {
                translatedSource = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                                    "Host",
                                                                    natRule,
                                                                    "Error creating a NAT rule, missing information for Juniper NAT pool object",
                                                                    "Pool details: " + natRule.TranslatedSource + ".");
            }
            else
            {
                // The following configuration is NOT supported by Check Point NAT.
                // Instead of a range object, we should use a host object with a first address of a range.
                if (cpNatRule.Method == CheckPoint_NAT_Rule.NatMethod.Hide && translatedSource.GetType().ToString().EndsWith("_Range"))
                {
                    string sIpAddress = ((CheckPoint_Range)translatedSource).RangeFrom;

                    translatedSource = new CheckPoint_Host();
                    ((CheckPoint_Host)translatedSource).IpAddress = sIpAddress;
                    translatedSource.Name = "host_" + sIpAddress;

                    natRule.ConversionIncidentType = ConversionIncidentType.Informative;

                    _conversionIncidents.Add(new ConversionIncident(natRule.LineNumber,
                                                                    "Source NAT rule points to a range object as a translated source for hide-NAT",
                                                                    "Using first address of a range for translated source.",
                                                                    natRule.ConversionIncidentType));
                }
            }

            return translatedSource;
        }

        private CheckPointObject GetNatTranslatedSourceFromJuniperSourceNatInterface(Juniper_SourceNatPolicy natPolicy, Juniper_SourceNatRule natRule, CheckPoint_NAT_Rule cpNatRule)
        {
            CheckPointObject translatedSource = null;
            string destinationInterfaceName = "";

            if (natPolicy.DestinationInterfaces.Count != 0)
            {
                bool ifcFound = false;

                foreach (var ifcName in natPolicy.DestinationInterfaces)
                {
                    foreach (Juniper_Interface ifc in JuniperInterfaces)
                    {
                        if (ifcName == ifc.Name)
                        {
                            if (IsNetworkObjectReachableFromInterface(cpNatRule.Destination, ifc))
                            {
                                translatedSource = GetCheckPointObjectOrCreateDummy(ifcName + "_address",
                                                                                    "Host",
                                                                                    natRule,
                                                                                    "Error creating a NAT rule, missing topology information for Juniper destination interface",
                                                                                    "Destination interface details: " + ifcName + ".");
                            }

                            destinationInterfaceName = ifcName;
                            ifcFound = true;
                            break;
                        }
                    }

                    if (ifcFound)
                    {
                        break;
                    }
                }
            }
            else   // natPolicy.DestinationZones
            {
                bool zoneFound = false;

                foreach (var zoneName in natPolicy.DestinationZones)
                {
                    foreach (Juniper_Zone zone in JuniperZones)
                    {
                        if (zoneName == zone.Name)
                        {
                            bool ifcFound = false;

                            foreach (var ifcName in zone.Interfaces)
                            {
                                foreach (Juniper_Interface ifc in JuniperInterfaces)
                                {
                                    if (ifcName == ifc.Name)
                                    {
                                        if (IsNetworkObjectReachableFromInterface(cpNatRule.Destination, ifc))
                                        {
                                            translatedSource = GetCheckPointObjectOrCreateDummy(ifcName + "_address",
                                                                                                "Host",
                                                                                                natRule,
                                                                                                "Error creating a NAT rule, missing topology information for Juniper destination interface",
                                                                                                "Destination interface details: " + ifcName + ".");
                                        }

                                        destinationInterfaceName = ifcName;
                                        ifcFound = true;
                                        break;
                                    }
                                }

                                if (ifcFound)
                                {
                                    break;
                                }
                            }

                            zoneFound = true;
                            break;
                        }
                    }

                    if (zoneFound)
                    {
                        break;
                    }
                }
            }

            if (translatedSource == null)
            {
                translatedSource = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                                    "Host",
                                                                    natRule,
                                                                    "Error creating a NAT rule, missing topology information for Juniper destination interface",
                                                                    "Destination interface " + destinationInterfaceName + " does not contain appropriate static route to reach " + cpNatRule.Destination.Name + ".");
            }

            return translatedSource;
        }

        private CheckPointObject GetCheckPointObjectFromJuniperNatAddress(Subnet address)
        {
            string addressAutoName = NetworkObjectNameGenerator.AutoGeneratedNetworkName(address);
            CheckPointObject cpObject;

            if (address.IsHost())
            {
                cpObject = new CheckPoint_Host();
                ((CheckPoint_Host)cpObject).IpAddress = address.IpAddress;
            }
            else
            {
                // This is very important, as SRX seems to have such Subnet usages...
                if (address.Netmask == "0.0.0.0")
                {
                    cpObject = new CheckPoint_Range();
                    cpObject.Tag = "ANY_NETWORK";   // !!!
                    ((CheckPoint_Range)cpObject).RangeFrom = "0.0.0.0";
                    ((CheckPoint_Range)cpObject).RangeTo = "255.255.255.255";
                }
                else
                {
                    cpObject = new CheckPoint_Network();
                    ((CheckPoint_Network)cpObject).Subnet = address.IpAddress;
                    ((CheckPoint_Network)cpObject).Netmask = address.Netmask;
                }
            }

            cpObject.Name = addressAutoName;
            AddCheckPointObject(cpObject);

            return cpObject;
        }

        private CheckPointObject GetCheckPointObjectFromJuniperNatPoolAddress(Juniper_NatPool.PoolAddress poolAddress)
        {
            CheckPointObject cpObject = null;

            switch (poolAddress.AddressType)
            {
                case Juniper_NatPool.PoolAddress.NetworkType.Host:
                    cpObject = new CheckPoint_Host();
                    ((CheckPoint_Host)cpObject).IpAddress = poolAddress.IpAddress;
                    break;

                case Juniper_NatPool.PoolAddress.NetworkType.Subnet:
                    cpObject = new CheckPoint_Network();
                    ((CheckPoint_Network)cpObject).Subnet = poolAddress.IpAddress;
                    ((CheckPoint_Network)cpObject).Netmask = poolAddress.Netmask;
                    break;

                case Juniper_NatPool.PoolAddress.NetworkType.Range:
                    cpObject = new CheckPoint_Range();
                    ((CheckPoint_Range)cpObject).RangeFrom = poolAddress.IpAddress;
                    ((CheckPoint_Range)cpObject).RangeTo = poolAddress.RangeTo;
                    break;
            }

            return cpObject;
        }

        private CheckPointObject GetCheckPointObjectFromJuniperNatAddressName(string addressName, JuniperObject natRule)
        {
            if (addressName.Equals(JuniperObject.AnyIPv4, StringComparison.InvariantCultureIgnoreCase))
            {
                addressName = CheckPointObject.Any;
            }

            var cpObject = _cpObjects.GetObject(addressName);
            if (cpObject != null && cpObject.Name == CheckPointObject.Any)
            {
                return cpObject;
            }

            // MUST be from a global address book!!!
            if (cpObject != null && !string.IsNullOrEmpty(cpObject.Tag) && cpObject.Tag == JuniperObject.GlobalZoneName)
            {
                return cpObject;
            }

            return GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                    "Host",
                                                    natRule,
                                                    "Error creating a NAT rule, missing information for Juniper address name object",
                                                    "Address details: " + addressName + ".");
        }

        private CheckPointObject GetCheckPointServiceFromJuniperNatRuleApplication(string application)
        {
            return _cpObjects.GetObject(_juniper2CheckpointServiceDuplicates.ContainsKey(application)
                ? _juniper2CheckpointServiceDuplicates[application]
                : application);
        }

        private IEnumerable<CheckPointObject> GetCheckPointServicesFromJuniperNatRulePort(string sPort)
        {
            var services = new List<CheckPointObject>();

            bool alreadyExists;
            var cpServive = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects, "tcp", sPort, out alreadyExists);
            if (cpServive != null)
            {
                cpServive.Tag = "tcp";   // we need this info during NAT rule creation!!!
                if (!alreadyExists)
                {
                    AddCheckPointObject(cpServive);
                }
                services.Add(cpServive);
            }

            cpServive = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects, "udp", sPort, out alreadyExists);
            if (cpServive != null)
            {
                cpServive.Tag = "udp";   // we need this info during NAT rule creation!!!
                if (!alreadyExists)
                {
                    AddCheckPointObject(cpServive);
                }
                services.Add(cpServive);
            }

            return services;
        }

        private IEnumerable<CheckPointObject> GetCheckPointServicesFromJuniperNatRule(IEnumerable<string> protocols, IEnumerable<string> ports)
        {
            var services = new List<CheckPointObject>();

            foreach (var protocol in protocols)
            {
                switch (protocol)
                {
                    case "tcp":
                    case "udp":
                    case "sctp":
                        // Check the ports...
                        foreach (var port in ports)
                        {
                            bool alreadyExists;
                            var cpServive = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects, protocol, port, out alreadyExists);
                            if (cpServive != null)
                            {
                                if (!alreadyExists)
                                {
                                    AddCheckPointObject(cpServive);
                                }
                                services.Add(cpServive);
                            }
                        }
                        break;

                    case "icmp":
                        services.Add(_cpObjects.GetObject("icmp-proto"));
                        break;

                    default:
                        // General IP protocol name or number:
                        // In this case, the 'Protocol' will always hold the name, and the 'Port' will hold the number.
                        string protocolName;
                        string protocolPort = "";
                        if (JuniperKnownApplications.IsKnownProtocolOrPortName(protocol))
                        {
                            protocolPort = JuniperKnownApplications.ConvertProtocolOrPortNameToNumber(protocol);
                        }
                        else if (JuniperKnownApplications.IsKnownProtocolOrPortNumber(protocol, out protocolName))   // protocol number is used!!!
                        {
                            protocolPort = protocol;
                        }

                        if (!string.IsNullOrEmpty(protocolPort))
                        {
                            bool alreadyExists;
                            var cpServive = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects, "other", protocolPort, out alreadyExists);
                            if (cpServive != null)
                            {
                                if (!alreadyExists)
                                {
                                    AddCheckPointObject(cpServive);
                                }
                                services.Add(cpServive);
                            }
                        }
                        break;
                }
            }

            return services;
        }

        private void CreateNATRulebase()
        {
            var section1 = new List<CheckPoint_NAT_Rule>();
            var section2 = new List<CheckPoint_NAT_Rule>();
            var section3 = new List<CheckPoint_NAT_Rule>();
            var section4 = new List<CheckPoint_NAT_Rule>();
            var section5 = new List<CheckPoint_NAT_Rule>();
            var section6 = new List<CheckPoint_NAT_Rule>();
            var section7 = new List<CheckPoint_NAT_Rule>();

            // Create the NAT sections
            foreach (var cpNatRule in _cpPreorderedNatRules)
            {
                var juniperNatCustomData = ((JuniperNatCustomData)cpNatRule.VendorCustomData);

                switch (juniperNatCustomData.Priority)
                {
                    case JuniperNatCustomData.RulePriority.StaticInterface:
                        section1.Add(cpNatRule);
                        break;

                    case JuniperNatCustomData.RulePriority.StaticZone:
                        section2.Add(cpNatRule);
                        break;

                    case JuniperNatCustomData.RulePriority.DestinationInterface:
                        section3.Add(cpNatRule);
                        break;

                    case JuniperNatCustomData.RulePriority.DestinationZone:
                        section4.Add(cpNatRule);
                        break;

                    case JuniperNatCustomData.RulePriority.SourceInterface2Interface:
                        section5.Add(cpNatRule);
                        break;

                    case JuniperNatCustomData.RulePriority.SourceMixed:
                        section6.Add(cpNatRule);
                        break;

                    case JuniperNatCustomData.RulePriority.SourceZone2Zone:
                        section7.Add(cpNatRule);
                        break;
                }
            }

            // Create the NAT Rulebase
            _cpNatRules.AddRange(section1);
            _cpNatRules.AddRange(section2);
            _cpNatRules.AddRange(section3);
            _cpNatRules.AddRange(section4);
            _cpNatRules.AddRange(section5);
            _cpNatRules.AddRange(section6);
            _cpNatRules.AddRange(section7);
        }

        private void MatchNATRulesIntoFirewallPolicy()
        {
            CheckPoint_Package cpPackage = _cpPackages[0];

            foreach (CheckPoint_NAT_Rule cpNatRule in _cpNatRules)
            {
                var juniperNatCustomData = ((JuniperNatCustomData)cpNatRule.VendorCustomData);

                // Skip source NAT rules
                if (juniperNatCustomData.Priority > JuniperNatCustomData.RulePriority.DestinationZone)
                {
                    continue;
                }

                // Skip NO-NAT destination NAT rules
                if (cpNatRule.TranslatedDestination == null)
                {
                    continue;
                }

                // Skip static NAT mirrored rules
                if (juniperNatCustomData.IsStaticMirrorRule)
                {
                    continue;
                }

                foreach (CheckPoint_Rule cpParentRule in cpPackage.ParentLayer.Rules)
                {
                    if (cpParentRule.Action != CheckPoint_Rule.ActionType.SubPolicy)
                    {
                        continue;
                    }

                    if (cpParentRule.Source[0] is CheckPoint_PredifinedObject && cpParentRule.Source[0].Name.Equals(CheckPointObject.Any))
                    {
                        continue;
                    }
					
                    var parentLayerRuleZone = (CheckPoint_Zone)cpParentRule.Source[0];
                    if (parentLayerRuleZone == null)
                    {
                        continue;
                    }

                    // NAT rule source zone(s)/interface(s) should match on firewall rule source zone
                    if (!IsFirewallRuleSourceZoneMatchedByNATRule(parentLayerRuleZone.Name, juniperNatCustomData))
                    {
                        continue;
                    }

                    // Get into the relevant sub-policy
                    foreach (CheckPoint_Layer subPolicy in cpPackage.SubPolicies)
                    {
                        if (subPolicy.Name != cpParentRule.SubPolicyName)
                        {
                            continue;
                        }

                        for (int ruleNumber = 0; ruleNumber < subPolicy.Rules.Count; ruleNumber++)
                        {
                            var cpRule = subPolicy.Rules[ruleNumber];

                            // Do not match on default action rule
                            if (!string.IsNullOrEmpty(cpRule.Name) && cpRule.Name == Juniper_GlobalPolicyRule.DefaultActionRuleName)
                            {
                                continue;
                            }

                            // Do not match if rule's destination is 'any'
                            if (cpRule.Destination.Count == 1 && cpRule.Destination[0].Name == CheckPointObject.Any)
                            {
                                continue;
                            }

                            bool serviceMatchedToo = false;

                            if (IsFirewallRuleMatchedByNATRule(cpNatRule, cpRule, out serviceMatchedToo))
                            {
                                string natServiceName = (cpNatRule.Service != null) ? cpNatRule.Service.Name : "";

                                var newRule = new CheckPoint_Rule();

                                newRule.Enabled = cpRule.Enabled;
                                newRule.Source.AddRange(cpRule.Source);
                                newRule.Destination.Add(cpNatRule.Destination);
                                if (serviceMatchedToo && !string.IsNullOrEmpty(natServiceName))
                                {
                                    newRule.Service.Add(_cpObjects.GetObject(natServiceName));
                                }
                                else
                                {
                                    newRule.Service.AddRange(cpRule.Service);
                                }
                                newRule.Action = cpRule.Action;
                                newRule.Layer = subPolicy.Name;
                                newRule.ConvertedCommandId = cpNatRule.ConvertedCommandId;
                                newRule.ConversionIncidentType = (cpRule.ConversionIncidentType != ConversionIncidentType.None) ? cpRule.ConversionIncidentType : cpNatRule.ConversionIncidentType;
                                newRule.ConversionComments = string.Format("Matched NAT rule, line {0}", cpNatRule.ConvertedCommandId);

                                // Recall this rule for duplicates lookup.
                                bool similiarRuleExists = false;

                                List<CheckPoint_Rule> matchedRules;
                                if (_natMatchedFirewallRules.TryGetValue(cpRule.ConvertedCommandId, out matchedRules))
                                {
                                    if (matchedRules.Any(matchedRule => matchedRule.CompareTo(newRule)))
                                    {
                                        similiarRuleExists = true;
                                    }

                                    if (!similiarRuleExists)
                                    {
                                        matchedRules.Add(newRule);
                                    }
                                }
                                else
                                {
                                    matchedRules = new List<CheckPoint_Rule> { newRule };
                                    _natMatchedFirewallRules.Add(cpRule.ConvertedCommandId, matchedRules);
                                }

                                if (!similiarRuleExists)
                                {
                                    // Add a new rule ABOVE the matched rule.
                                    subPolicy.Rules.Insert(ruleNumber, newRule);

                                    if (newRule.ConversionIncidentType != ConversionIncidentType.None)
                                    {
                                        cpPackage.ConversionIncidentType = ConversionIncidentType.Informative;
                                    }
                                }

                                // If NAT rule's service is "any" (null), we need to keep matching for all relevant FW rules.
                                if (serviceMatchedToo)
                                {
                                    break;
                                }
                                else if (!similiarRuleExists)
                                {
                                    ++ruleNumber;   // this is because we are changing the collection during iteration!!!
                                }
                            }
                        }
                    }
                }
            }
        }

        private bool IsFirewallRuleSourceZoneMatchedByNATRule(string fwRuleSourceZone, JuniperNatCustomData natCustomData)
        {
            if (natCustomData.Priority == JuniperNatCustomData.RulePriority.StaticZone || natCustomData.Priority == JuniperNatCustomData.RulePriority.DestinationZone)
            {
                return natCustomData.SourceZonesOrInterfaces.Any(sourceZone => sourceZone == fwRuleSourceZone);
            }

            foreach (var sourceInterface in natCustomData.SourceZonesOrInterfaces)
            {
                foreach (Juniper_Zone zone in JuniperZones)
                {
                    if (zone.Interfaces.Any(ifcName => sourceInterface == ifcName))
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        private bool IsFirewallRuleMatchedByNATRule(CheckPoint_NAT_Rule natRule, CheckPoint_Rule fwRule, out bool serviceMatchedToo)
        {
            serviceMatchedToo = false;

            var natSourceRanges = (natRule.Source != null) ? GetRanges(natRule.Source) : IPRanges.Any();
            var natTranslatedDestRanges = (natRule.TranslatedDestination != null) ? GetRanges(natRule.TranslatedDestination) : IPRanges.Any();
            var fwRuleSourceRanges = (fwRule.Source.Count > 0) ? GetRanges(fwRule.Source[0]) : IPRanges.Any();
            var fwRuleDestRanges = (fwRule.Destination.Count > 0) ? GetRanges(fwRule.Destination[0]) : IPRanges.Any();

            if (fwRuleSourceRanges.Overlaps(natSourceRanges) && fwRuleDestRanges.Overlaps(natTranslatedDestRanges))
            {
                // Match on service too...
                if (natRule.TranslatedService == null)
                {
                    // No NAT service at all
                    return true;
                }

                if (fwRule.Service.Count == 0){}
                else if (fwRule.Service.Count == 1 && fwRule.Service[0].Name == CheckPointObject.Any)
                {
                    // There is only one service in FW rule and it is "any", no matter what NAT rule service is...
                    serviceMatchedToo = true;
                    return true;
                }
                else if (fwRule.Service.Any(fwService => natRule.TranslatedService.Name == fwService.Name))
                {
                    // Service names match - NAT rule service appears in the list of FW rule's services
                    serviceMatchedToo = true;
                    return true;
                }
            }

            return false;
        }

        private IPRanges GetRanges(CheckPointObject cpObject)
        {
            if (cpObject == null || cpObject.Name == CheckPointObject.Any)
            {
                return new IPRanges(new IPRange(IPRange.Any));
            }

            if (cpObject.GetType().ToString().EndsWith("_NetworkGroup"))
            {
                return GetGroupRanges((CheckPoint_NetworkGroup)cpObject);
            }

            if (cpObject.GetType().ToString().EndsWith("_Host"))
            {
                return ((CheckPoint_Host)cpObject).GetIPRanges();
            }

            if (cpObject.GetType().ToString().EndsWith("_Network"))
            {
                return ((CheckPoint_Network)cpObject).GetIPRanges();
            }

            if (cpObject.GetType().ToString().EndsWith("_Range"))
            {
                return ((CheckPoint_Range)cpObject).GetIPRanges();
            }

            return new IPRanges();
        }

        private void ApplyConversionIncidentOnCheckPointObject(CheckPointObject cpObject, JuniperObject juniperObject)
        {
            cpObject.ConvertedCommandId = juniperObject.LineNumber;

            if (juniperObject.ConversionIncidentType != ConversionIncidentType.None)
            {
                cpObject.ConversionIncidentType = juniperObject.ConversionIncidentType;

                if (!string.IsNullOrEmpty(juniperObject.ConversionIncidentMessage))
                {
                    int pos = juniperObject.GetType().ToString().IndexOf("_");
                    string errorDesc = juniperObject.GetType().ToString().Substring(pos + 1) + " details: " + juniperObject.Name + ".";

                    _conversionIncidents.Add(new ConversionIncident(juniperObject.LineNumber,
                                                                    juniperObject.ConversionIncidentMessage,
                                                                    errorDesc,
                                                                    juniperObject.ConversionIncidentType));
                }
            }
        }

        private bool DoesJuniperApplicationMatchCheckpointPredefinedService(Juniper_Application application, string serviceName)
        {
            bool matchFound;
            serviceName = _cpObjects.GetKnownServiceName(serviceName, out matchFound);

            if (matchFound)
            {
                if (serviceName != application.Name)
                {
                    try
                    {
                        _juniper2CheckpointServiceDuplicates.Add(application.Name, serviceName);
                    }
                    catch (Exception e) {}

                    application.ConversionIncidentType = ConversionIncidentType.Informative;

                    string errorDescription = string.Format("Juniper application name: {0}. Check Point service name: {1}", application.Name, serviceName);
                    _conversionIncidents.Add(new ConversionIncident(application.IsJunosDefault ? 0 : application.LineNumber,
                                                                    "Juniper application has an equivalent Check Point service. Using a Check Point service instead.",
                                                                    errorDescription,
                                                                    application.ConversionIncidentType));
                }

                return true;
            }

            return false;
        }

        private bool IsNetworkObjectReachableFromInterface(CheckPointObject cpObject, Juniper_Interface juniperInterface)
        {
            if (cpObject.Name == CheckPointObject.Any || cpObject.Tag == "ANY_NETWORK")   // !!!
            {
                return true;
            }

            var interfaceTopology = GetJuniperInterfaceTopology(juniperInterface);
            if (interfaceTopology != null && interfaceTopology.Any() && IsNetworkObjectContainedInInterfaceTopology(cpObject, interfaceTopology))
            {
                return true;
            }

            return false;
        }

        private bool IsNetworkObjectContainedInMultipleZones(CheckPointObject cpObject, JuniperObject juniperObject)
        {
            if ((cpObject.Tag != JuniperObject.GlobalZoneName) && _juniperParser.IsNetworkObjectContainedInMultipleZones(cpObject.Name))
            {
                _cpNetworkObjectsInMultipleZones.Add(cpObject);

                juniperObject.ConversionIncidentType = ConversionIncidentType.Informative;
                cpObject.ConversionIncidentType = ConversionIncidentType.Informative;   // report on converted object as well!!!

                string modifiedName = (cpObject.Name != cpObject.SafeName()) ? cpObject.SafeName() : cpObject.Name;

                string errorDescription = string.Format("Object name: {0}, attached zone: {1}. Modified name: {0}_{1}", modifiedName, cpObject.Tag);
                _conversionIncidents.Add(new ConversionIncident(juniperObject.LineNumber,
                                                                "Juniper object with the same name is attached to different zones. Applying zone name to object name for Check Point name uniqueness.",
                                                                errorDescription,
                                                                juniperObject.ConversionIncidentType));
                return true;
            }

            return false;
        }

        private bool AreNetworkAndZoneNamesDuplicated(string networkName)
        {
            foreach (Juniper_Zone zone in JuniperZones)
            {
                if (networkName.Equals(zone.Name, StringComparison.InvariantCultureIgnoreCase))
                {
                    return true;
                }
            }

            return false;
        }

        private bool IsNetworkObjectContainedInInterfaceTopology(CheckPointObject cpObject, IEnumerable<IPNetwork> interfaceTopology)
        {
            if (cpObject == null || cpObject.Name.Contains(AutoGeneratedNameWithError))
            {
                return false;
            }

            var cpNetworkGroup = cpObject as CheckPoint_NetworkGroup;
            if (cpNetworkGroup != null)
            {
                foreach (var memberName in cpNetworkGroup.Members)
                {
                    var member = _cpObjects.GetObject(memberName);
                    if (IsNetworkObjectContainedInInterfaceTopology(member, interfaceTopology))
                    {
                        return true;
                    }
                }

                return false;
            }

            var cpNetwork = cpObject as CheckPoint_Network;
            if (cpNetwork != null)
            {
                IPNetwork network;
                if (IPNetwork.TryParse(cpNetwork.Subnet, cpNetwork.Netmask, out network))
                {
                    return interfaceTopology.Any(topology => IPNetwork.Contains(topology, network));
                }

                return false;
            }

            var cpRange = cpObject as CheckPoint_Range;
            if (cpRange != null)
            {
                IPNetwork network = IPNetwork.WideSubnet(cpRange.RangeFrom, cpRange.RangeTo);
                return interfaceTopology.Any(topology => IPNetwork.Contains(topology, network));
            }

            var cpHost = cpObject as CheckPoint_Host;
            if (cpHost != null)
            {
                IPNetwork network;
                if (IPNetwork.TryParse(cpHost.IpAddress, 32, out network))
                {
                    return interfaceTopology.Any(topology => IPNetwork.Contains(topology, network));
                }
            }

            return false;
        }

        private List<IPNetwork> GetJuniperInterfaceTopology(Juniper_Interface ifc)
        {
            List<IPNetwork> interfaceTopology = null;

            if (ifc.Topology.Count > 0 && !_juniperInterfacesTopology.TryGetValue(ifc.Name, out interfaceTopology))
            {
                interfaceTopology = new List<IPNetwork>();

                foreach (var topology in ifc.Topology)
                {
                    IPNetwork ipNetwork;
                    if (IPNetwork.TryParse(topology.IpAddress, topology.Netmask, out ipNetwork))
                    {
                        interfaceTopology.Add(ipNetwork);
                    }
                }

                if (interfaceTopology.Count > 0)
                {
                    _juniperInterfacesTopology.Add(ifc.Name, interfaceTopology);
                }
            }

            return interfaceTopology;
        }

        private void CheckObjectNameValidity(CheckPointObject cpObject, JuniperObject juniperObject, bool inMultipleZones = false, bool safeNameOnly = false)
        {
            string originalName = cpObject.Name;

            if (originalName != cpObject.SafeName())
            {
                string unsafeName = inMultipleZones ? (originalName + "_" + cpObject.Tag) : originalName;   // this is important!!!
                _cpUnsafeNames.Add(unsafeName);
            }

            if (safeNameOnly)
            {
                return;
            }

            if (cpObject.GetType().ToString().EndsWith("_TcpService") || cpObject.GetType().ToString().EndsWith("_UdpService"))
            {
                // TCP/UDP service name must start with a letter!!!
                if (!Char.IsLetter(originalName[0]))
                {
                    _cpServiceInvalidNames.Add(originalName);

                    juniperObject.ConversionIncidentType = ConversionIncidentType.Informative;
                    cpObject.ConversionIncidentType = ConversionIncidentType.Informative;   // report on converted object as well!!!

                    string errorDescription = string.Format("Service original name: {0}. Modified name: {1}", originalName, InvalidServiceNamePrefix + originalName);
                    _conversionIncidents.Add(new ConversionIncident(juniperObject.LineNumber,
                                                                    "TCP/UDP service object name must start with a letter. Modifying the original name to a Check Point valid name.",
                                                                    errorDescription,
                                                                    juniperObject.ConversionIncidentType));
                }
            }

            DuplicateNameInfo duplicateNameInfo;
            if (_duplicateNamesLookup.TryGetValue(originalName, out duplicateNameInfo))
            {
                if (inMultipleZones)
                {
                    if (!duplicateNameInfo.Zones.Contains(cpObject.Tag))
                    {
                        duplicateNameInfo.Zones.Add(cpObject.Tag);
                        _duplicateNamesLookup[originalName] = duplicateNameInfo;
                        return;
                    }
                }

                if (duplicateNameInfo.IsJuniperApplicationFromTerm && juniperObject.GetType().ToString().EndsWith("_Application"))
                {
                    var juniperApplication = (Juniper_Application)juniperObject;
                    if (juniperApplication.IsFromTerm)
                    {
                        // This is not a real duplicate...
                        return;
                    }
                }

                juniperObject.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                string errorTitle = duplicateNameInfo.IsCPPredefinedName
                                        ? "Detected an object with a same name in Check Point's predefined service objects repository."
                                        : "Detected an object with a non unique name. Check Point names should be case insensitive.";
                errorTitle += " Please review for further possible modifications to object configuration before the final migration.";

                string errorDescription = string.Format("Object details: {0} [{1}].", originalName, juniperObject.GetType().ToString().Split('_')[1]);

                _conversionIncidents.Add(new ConversionIncident(juniperObject.LineNumber, errorTitle, errorDescription, juniperObject.ConversionIncidentType));
            }
            else
            {
                duplicateNameInfo = new DuplicateNameInfo(false);
                if (inMultipleZones)
                {
                    duplicateNameInfo.Zones.Add(cpObject.Tag);
                }
                if (juniperObject.GetType().ToString().EndsWith("_Application"))
                {
                    var juniperApplication = (Juniper_Application)juniperObject;
                    if (juniperApplication.IsFromTerm)
                    {
                        // In this case there may be several applications with the same name...
                        duplicateNameInfo.IsJuniperApplicationFromTerm = true;
                    }
                }

                _duplicateNamesLookup.Add(originalName, duplicateNameInfo);
            }
        }

        private void AlertOnDomainNameModification(Juniper_Fqdn fqdn, bool inMultipleZones)
        {
            fqdn.ConversionIncidentType = ConversionIncidentType.Informative;

            string errorDescription = inMultipleZones
                ? string.Format("Juniper name: {0}, attached to zone {1}. New name: .{2}", fqdn.Name, fqdn.ZoneName, fqdn.DnsName)
                : string.Format("Juniper name: {0}. New name: .{1}", fqdn.Name, fqdn.DnsName);

            _conversionIncidents.Add(new ConversionIncident(fqdn.LineNumber,
                                                            "Juniper Domain object is converted to Check Point Domain object using dns-name prefixed with a dot as converted object name.",
                                                            errorDescription,
                                                            fqdn.ConversionIncidentType));
        }

        private void EnforceObjectNameValidity()
        {
            // Fix juniper dns names to be valid check point domain names
            foreach (var domain in _cpDomains)
            {
                string originalName = domain.Name;
                string validName = "." + domain.Fqdn;
                domain.Name = validName;
                domain.ConversionIncidentType = ConversionIncidentType.Informative;

                // Search references in network groups
                foreach (var networkGroup in _cpNetworkGroups)
                {
                    if (domain.Tag == networkGroup.Tag)   // search in the same zone only...
                    {
                        int pos = networkGroup.Members.IndexOf(originalName);
                        if (pos != -1)
                        {
                            networkGroup.Members[pos] = validName;
                        }
                    }
                }
            }

            // Fix invalid TCP/UDP service names
            foreach (var invalidName in _cpServiceInvalidNames)
            {
                bool found = false;
                string validName = InvalidServiceNamePrefix + invalidName;

                // Search in TCP services
                foreach (var tcpService in _cpTcpServices)
                {
                    if (invalidName == tcpService.Name)
                    {
                        tcpService.Name = validName;
                        found = true;
                        break;
                    }
                }

                // Otherwise, search in UDP services
                if (!found)
                {
                    foreach (var udpService in _cpUdpServices)
                    {
                        if (invalidName == udpService.Name)
                        {
                            udpService.Name = validName;
                            break;
                        }
                    }
                }

                // Finally, search references in service groups
                foreach (var serviceGroup in _cpServiceGroups)
                {
                    int pos = serviceGroup.Members.IndexOf(invalidName);
                    if (pos != -1)
                    {
                        serviceGroup.Members[pos] = validName;
                    }
                }
            }

            // Fix unsafe names
            foreach (var unsafeName in _cpUnsafeNames)
            {
                CheckPointObject cpObject = _cpObjects.GetObject(unsafeName);
                if (cpObject != null)
                {
                    cpObject.Name = cpObject.SafeName();

                    // Search references in service groups
                    foreach (var serviceGroup in _cpServiceGroups)
                    {
                        int pos = serviceGroup.Members.IndexOf(unsafeName);
                        if (pos != -1)
                        {
                            serviceGroup.Members[pos] = cpObject.Name;
                        }
                    }

                    // Search references in network groups
                    foreach (var networkGroup in _cpNetworkGroups)
                    {
                        int pos = networkGroup.Members.IndexOf(unsafeName);
                        if (pos != -1)
                        {
                            networkGroup.Members[pos] = cpObject.Name;
                        }
                    }

                    // Search references in network groups with exclusion
                    foreach (var networkGroup in _cpGroupsWithExclusion)
                    {
                        if (networkGroup.Include == unsafeName)
                        {
                            networkGroup.Include = cpObject.Name;
                        }
                        if (networkGroup.Except == unsafeName)
                        {
                            networkGroup.Except = cpObject.Name;
                        }
                    }
                }
            }
        }

        private void ReplaceJuniperApplicationsWithEquivalentCheckpointServices()
        {
            foreach (var serviceDuplicate in _juniper2CheckpointServiceDuplicates)
            {
                // Search references in service groups
                foreach (var serviceGroup in _cpServiceGroups)
                {
                    int pos = serviceGroup.Members.IndexOf(serviceDuplicate.Key);
                    if (pos != -1)
                    {
                        serviceGroup.Members[pos] = serviceDuplicate.Value;
                    }
                }
            }
        }

        private void ReplaceJuniperInvalidApplicationsReferences()
        {
            foreach (var invalidApplication in _juniperInvalidApplicationsReferences)
            {
                // Search references in service groups
                foreach (var serviceGroup in _cpServiceGroups)
                {
                    int pos = serviceGroup.Members.IndexOf(invalidApplication.Key);
                    if (pos != -1)
                    {
                        serviceGroup.Members[pos] = invalidApplication.Value;
                    }
                }
            }
        }

        private CheckPointObject GetCheckPointObjectOrCreateDummy(string cpObjectName, string dummyObjectType, JuniperObject juniperObject, string errorTitle, string errorDescription, bool createDummy = true)
        {
            if (cpObjectName.Equals(JuniperObject.AnyIPv4, StringComparison.InvariantCultureIgnoreCase))
            {
                cpObjectName = CheckPointObject.Any;
            }

            var cpObject = _cpObjects.GetObject(cpObjectName);
            if (cpObject != null || !createDummy)
            {
                return cpObject;
            }

            CheckPointObject cpDummyObject = null;

            switch (dummyObjectType)
            {
                case "Host":
                    cpDummyObject = new CheckPoint_Host { Name = "_Err_in_network-line_" + juniperObject.LineNumber, IpAddress = "1.1.1.1" };
                    break;

                case "NetworkGroup":
                    cpDummyObject = new CheckPoint_NetworkGroup { Name = "_Err_in_topology-line_" + juniperObject.LineNumber };
                    break;

                case "ServiceGroup":
                    string cpServiceName;
                    if (_juniper2CheckpointServiceDuplicates.TryGetValue(cpObjectName, out cpServiceName))
                    {
                        cpObject = _cpObjects.GetObject(cpServiceName);
                        if (cpObject != null)
                        {
                            return cpObject;
                        }
                    }

                    cpDummyObject = new CheckPoint_ServiceGroup { Name = "_Err_in_service-line_" + juniperObject.LineNumber };
                    break;
                case "Time":
                    cpDummyObject = new CheckPoint_Time { Name = cpObjectName};
                    break;
            }

            if (cpDummyObject != null)
            {
                cpDummyObject.ConvertedCommandId = juniperObject.LineNumber;
                cpDummyObject.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                AddCheckPointObject(cpDummyObject);

                juniperObject.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                errorDescription = string.Format("{0} Using dummy object: {1}.", errorDescription, cpDummyObject.Name);
                _conversionIncidents.Add(new ConversionIncident(juniperObject.LineNumber, errorTitle, errorDescription, juniperObject.ConversionIncidentType));
            }

            return cpDummyObject;
        }

        public void CreateErrorsReport(string vDomName)
        {
            _errorsList.AddRange(_conversionIncidents.Where(i => i.IncidentType == ConversionIncidentType.ManualActionRequired).Select(i => i.ToString()));

            if (_errorsList.Count > 0)
            {
                _errorsList = Helper.RemoveDuplicates(_errorsList);

                string filename = _targetFolder + "\\" + vDomName + "_errors.html";

                using (var file = new StreamWriter(filename, false))
                {
                    file.WriteLine("<html>");
                    file.WriteLine("<head>");
                    file.WriteLine("</head>");
                    file.WriteLine("<body>");
                    file.WriteLine("<h1>List of " + vDomName + " Errors</h1>");
                    file.WriteLine("<table border='1' style='border-collapse: collapse;'>");
                    for (int i = 0; i < _errorsList.Count; i++)
                    {
                        file.WriteLine("<tr>");
                        file.WriteLine("<td>");
                        file.WriteLine(i);
                        file.WriteLine("</td>");
                        file.WriteLine("<td>");
                        file.WriteLine(_errorsList[i]);
                        file.WriteLine("</td>");
                        file.WriteLine("</tr>");
                    }
                    file.WriteLine("</table>");
                    file.WriteLine("</body>");
                    file.WriteLine("</html>");
                }
            }
        }

        //report about Warnings
        public void CreateWarningsReport(string vDomName)
        {
            _warningsList.AddRange(_conversionIncidents.Where(i => i.IncidentType == ConversionIncidentType.None || i.IncidentType == ConversionIncidentType.Informative).Select(i => i.ToString()));

            if (_warningsList.Count > 0)
            {
                _warningsList = Helper.RemoveDuplicates(_warningsList);

                string filename = _targetFolder + "\\" + vDomName + "_warnings.html";

                using (var file = new StreamWriter(filename, false))
                {
                    file.WriteLine("<html>");
                    file.WriteLine("<head>");
                    file.WriteLine("</head>");
                    file.WriteLine("<body>");
                    file.WriteLine("<h1>List of " + vDomName + " Warnings</h1>");
                    file.WriteLine("<table border='1' style='border-collapse: collapse;'>");
                    for (int i = 0; i < _warningsList.Count; i++)
                    {
                        file.WriteLine("<tr>");
                        file.WriteLine("<td>");
                        file.WriteLine(i);
                        file.WriteLine("</td>");
                        file.WriteLine("<td>");
                        file.WriteLine(_warningsList[i]);
                        file.WriteLine("</td>");
                        file.WriteLine("</tr>");
                    }
                    file.WriteLine("</table>");
                    file.WriteLine("</body>");
                    file.WriteLine("</html>");
                }
            }
        }

        public int WarningsInConvertedPackage()
        {
            return _warningsList.Count;
        }

        public int ErrorsInConvertedPackage()
        {
            return _errorsList.Count;
        }

        protected override string GetVendorName()
        {
            return Vendor.JuniperJunosOS.ToString();
        }
        #endregion

        #region Public Methods

        public NewAnalizStatistic NewJunoAnalizStatistic = new NewAnalizStatistic(0, 0);


        public override void Initialize(VendorParser vendorParser, string vendorFilePath, string toolVersion, string targetFolder, string domainName, string outputFormat = "json")
        {
            _juniperParser = (JuniperParser)vendorParser;
            if (_juniperParser == null)
            {
                throw new InvalidDataException("Unexpected!!!");
            }
            _outputFormat = outputFormat;

            base.Initialize(vendorParser, vendorFilePath, toolVersion, targetFolder, domainName, outputFormat);
        }

        public override Dictionary<string, int> Convert(bool convertNat)
        {
            if (IsConsoleRunning)
                Progress = new ProgressBar();

            if (IsConsoleRunning)
            {
                Console.WriteLine("Converting objects ...");
                Progress.SetProgress(20);
                Thread.Sleep(1000);
            }
            RaiseConversionProgress(20, "Converting objects ...");
            _cpObjects.Initialize();   // must be first!!!

            foreach (var cpObject in _cpObjects.GetPredefinedObjects())
            {
                _duplicateNamesLookup.Add(cpObject.Name, new DuplicateNameInfo(true));
            }
            Add_Schedulers();
            Add_NetworkObjects();
            Add_InterfacesAndRoutes();
            Add_or_Modify_InterfaceNetworkGroups();
            Add_Zones();   // must be called AFTER handling all network stuff!!!
            Add_ServiceObjects();

            if (IsConsoleRunning)
            {
                Console.WriteLine("Converting rules ...");
                Progress.SetProgress(30);
                Thread.Sleep(1000);
            }
            RaiseConversionProgress(30, "Converting rules ...");
            Add_Package(); 

            if (_cpPackages.Count > 0)
            {
                Add_Optimized_Package();
            }

            if (convertNat)
            {
                if (IsConsoleRunning)
                {
                    Console.WriteLine("Converting NAT rules ...");
                    Progress.SetProgress(40);
                    Thread.Sleep(1000);
                }
                RaiseConversionProgress(40, "Converting NAT rules ...");
                Add_Static_NAT();
                Add_Destination_NAT();
                Add_Source_NAT();

                if (IsConsoleRunning)
                {
                    Console.WriteLine("Creating NAT rulebase ...");
                    Progress.SetProgress(50);
                    Thread.Sleep(1000);
                }
                RaiseConversionProgress(50, "Creating NAT rulebase ...");
                CreateNATRulebase();

                if (IsConsoleRunning)
                {
                    Console.WriteLine("Creating Firewall rulebase ...");
                    Progress.SetProgress(60);
                    Thread.Sleep(1000);
                }
                RaiseConversionProgress(60, "Creating Firewall rulebase ...");
                MatchNATRulesIntoFirewallPolicy();
            }

            // This should be done here, after all objects are converted!!!
            if (IsConsoleRunning)
            {
                Console.WriteLine("Validating converted objects ...");
                Progress.SetProgress(70);
                Thread.Sleep(1000);
            }
            RaiseConversionProgress(70, "Validating converted objects ...");
            EnforceObjectNameValidity();
            ReplaceJuniperApplicationsWithEquivalentCheckpointServices();
            ReplaceJuniperInvalidApplicationsReferences();

            if (SkipUnusedObjects)
            {
                if (IsConsoleRunning)
                {
                    Console.WriteLine("Analyzing using of objects ...");
                    Progress.SetProgress(75);
                    Thread.Sleep(1000);
                }
                RaiseConversionProgress(75, "Analyzing using of objects ...");
                BuildListOfUsedObjects(convertNat);
            }

            if (SkipUnusedObjects)
            {
                if (IsConsoleRunning)
                {
                    Console.WriteLine("Optimizing objects ...");
                    Progress.SetProgress(80);
                    Thread.Sleep(1000);
                }
                RaiseConversionProgress(80, "Optimizing objects ...");
                CollectOnlyUsedObjects();
            }

            if (IsConsoleRunning)
            {
                Console.WriteLine("Generating CLI scripts ...");
                Progress.SetProgress(85);
                Thread.Sleep(1000);
            }
            RaiseConversionProgress(85, "Generating CLI scripts ...");
            if (!_isOverMaxLengthPackageName)
            {
                CreateObjectsScript();
                CreatePackagesScript();
            }
            CreateObjectsHtml();


            WarningsHtmlFile = _targetFolder + "\\" + _vendorFileName + "_warnings.html";
            ErrorsHtmlFile = _targetFolder + "\\" + _vendorFileName + "_errors.html";

            CreateErrorsReport(_vendorFileName);
            CreateWarningsReport(_vendorFileName);

            // This data container is important, and is used during html reports generation for incidents lookup!!!
            var incidentsGroupedByLineNumber = _conversionIncidents.GroupBy(error => error.LineNumber);
            _conversionIncidentsByLineNumber = incidentsGroupedByLineNumber.ToDictionary(error => error.Key, error => error.Distinct().ToList());

            // Resolve the conversion categories/lines count to report to the user.
            ConversionIncidentCategoriesCount = _conversionIncidents.GroupBy(error => error.Title).Count();
            ConversionIncidentsCommandsCount = _conversionIncidents.GroupBy(error => error.LineNumber).Count();
            
            if (!_isOverMaxLengthPackageName)
            {
                CreateSmartConnector(true, false);
                CreateSmartConnector(true, true);
            }

            if (IsConsoleRunning)
            {
                Progress.SetProgress(100);
                Progress.Dispose();
            }
            return new Dictionary<string, int>() { { "warnings", ConversionIncidentCategoriesCount } };
        }

        public override float Analyze()
        {
            if (IsConsoleRunning)
                Progress = new ProgressBar();

            if (IsConsoleRunning)
            {
                Console.WriteLine("Analyzing objects ...");
                Progress.SetProgress(20);
                Thread.Sleep(1000);
            }
            RaiseConversionProgress(20, "Analyzing objects ...");
            _cpObjects.Initialize();   // must be first!!!

            foreach (var cpObject in _cpObjects.GetPredefinedObjects())
            {
                _duplicateNamesLookup.Add(cpObject.Name, new DuplicateNameInfo(true));
            }
            Add_Schedulers();
            Add_NetworkObjects();
            Add_InterfacesAndRoutes();
            Add_or_Modify_InterfaceNetworkGroups();
            Add_Zones();   // must be called AFTER handling all network stuff!!!
            Add_ServiceObjects();

            if (IsConsoleRunning)
            {
                Console.WriteLine("Analyzing rules ...");
                Progress.SetProgress(30);
                Thread.Sleep(1000);
            }
            RaiseConversionProgress(30, "Analyzing rules ...");
            NewJunoAnalizStatistic._Package = Add_Package();

            if (_cpPackages.Count > 0)
            {
                Add_Optimized_Package();
            }

            if (IsConsoleRunning)
            {
                Console.WriteLine("Analyzing NAT rules ...");
                Progress.SetProgress(40);
                Thread.Sleep(1000);
            }
            RaiseConversionProgress(40, "Analyzing NAT rules ...");
            Add_Static_NAT();
            Add_Destination_NAT();
            Add_Source_NAT();

            if (IsConsoleRunning)
            {
                Console.WriteLine("Creating NAT rulebase ...");
                Progress.SetProgress(50);
                Thread.Sleep(1000);
            }
            RaiseConversionProgress(50, "Creating NAT rulebase ...");
            CreateNATRulebase();

            if (IsConsoleRunning)
            {
                Console.WriteLine("Creating Firewall rulebase ...");
                Progress.SetProgress(60);
                Thread.Sleep(1000);
            }
            RaiseConversionProgress(60, "Creating Firewall rulebase ...");
            MatchNATRulesIntoFirewallPolicy();

            // This should be done here, after all objects are converted!!!
            if (IsConsoleRunning)
            {
                Console.WriteLine("Validating analyzed objects ...");
                Progress.SetProgress(70);
                Thread.Sleep(1000);
            }
            RaiseConversionProgress(70, "Validating analyzed objects ...");
            EnforceObjectNameValidity();
            ReplaceJuniperApplicationsWithEquivalentCheckpointServices();
            ReplaceJuniperInvalidApplicationsReferences();


            ExportManagmentReport(false);

            if (IsConsoleRunning)
            {
                Console.WriteLine("Analyzing using of objects ...");
                Progress.SetProgress(75);
                Thread.Sleep(1000);
            }
            RaiseConversionProgress(75, "Analyzing using of objects ...");
            BuildListOfUsedObjects(true);

            if (IsConsoleRunning)
            {
                Console.WriteLine("Optimizing objects ...");
                Progress.SetProgress(80);
                Thread.Sleep(1000);
            }
            RaiseConversionProgress(80, "Optimizing objects ...");
            CollectOnlyUsedObjects();


            ExportManagmentReport(true);

            if (IsConsoleRunning)
            {
                Progress.SetProgress(100);
                Progress.Dispose();
            }
            return 0;
        }
        public override int RulesInConvertedPackage()
        {
            return _cpPackages[0].TotalRules();
        }

        public override int RulesInConvertedOptimizedPackage()
        {
            if (_cpPackages.Count > 1)
                return _cpPackages[1].TotalRules();
            else return 0;
        }

        public override int RulesInNatLayer()
        {
            return _cpNatRules.Count;
        }

        public void ExportManagmentReport(bool optimazed)
        {
            NewJunoAnalizStatistic._unusedNetworkObjectsCount += _cpNetworks.Count * (optimazed ? -1 : 1);
            NewJunoAnalizStatistic._unusedNetworkObjectsCount += _cpNetworkGroups.Count * (optimazed ? -1 : 1);
            NewJunoAnalizStatistic._unusedNetworkObjectsCount += _cpRanges.Count * (optimazed ? -1 : 1);
            NewJunoAnalizStatistic._unusedNetworkObjectsCount += _cpHosts.Count * (optimazed ? -1 : 1);

            NewJunoAnalizStatistic._unusedServicesObjectsCount += _cpTcpServices.Count * (optimazed ? -1 : 1);
            NewJunoAnalizStatistic._unusedServicesObjectsCount += _cpUdpServices.Count * (optimazed ? -1 : 1);
            NewJunoAnalizStatistic._unusedServicesObjectsCount += _cpSctpServices.Count * (optimazed ? -1 : 1);
            NewJunoAnalizStatistic._unusedServicesObjectsCount += _cpIcmpServices.Count * (optimazed ? -1 : 1);
            NewJunoAnalizStatistic._unusedServicesObjectsCount += _cpDceRpcServices.Count * (optimazed ? -1 : 1);
            NewJunoAnalizStatistic._unusedServicesObjectsCount += _cpOtherServices.Count * (optimazed ? -1 : 1);
            NewJunoAnalizStatistic._unusedServicesObjectsCount += _cpServiceGroups.Count * (optimazed ? -1 : 1);
            NewJunoAnalizStatistic._unusedServicesObjectsCount += _cpRpcServices.Count * (optimazed ? -1 : 1);

            optimazed = !optimazed;
            if (optimazed)
            {
                int dis = 0;
                int all = 0;
                int so_count = 0;
                int se_count = 0;
                int de_count = 0;
                int time_count = 0;
                foreach (var layer in NewJunoAnalizStatistic._Package.SubPolicies)
                {
                    foreach (var policy in layer.Rules)
                    {
                        bool any_fl = true;
                        if(policy.Time.Count > 0)
                        {
                            time_count++;
                        }
                        if (!policy.Enabled)
                        {
                            dis += 1;
                        }
                        if (policy.Comments == null || policy.Comments == "")
                        {
                            NewJunoAnalizStatistic._uncommentedServicesRulesCount++;
                        }
                        if (policy.Destination.Count > 0 && policy.Destination.First().Name.Equals("Any"))
                        {
                            de_count++;
                            if (any_fl)
                            {
                                all++;
                                any_fl = false;
                            }

                        }
                        if (policy.Source.Count > 0 && policy.Source.First().Name.Equals("Any"))
                        {
                            so_count++;
                            if (any_fl)
                            {
                                all++;
                                any_fl = false;
                            }

                        }
                        if (policy.Service.Count > 0 && policy.Service.First().Name.Equals("Any"))
                        {
                            se_count++;
                            if (any_fl)
                            {
                                all++;
                                any_fl = false;
                            }

                        }
                    }
                }
                foreach (var policy in NewJunoAnalizStatistic._Package.ParentLayer.Rules)
                {
                    bool any_fl = true;
                    if (policy.Time.Count > 0)
                    {
                        time_count++;
                    }
                    if (!policy.Enabled)
                    {
                        dis += 1;
                    }
                    if (policy.Comments == null || policy.Comments == "")
                    {
                        NewJunoAnalizStatistic._uncommentedServicesRulesCount++;
                    }
                    if (policy.Destination.Count > 0 && policy.Destination.First().Name.Equals("Any"))
                    {
                        de_count++;
                        if (any_fl)
                        {
                            all++;
                            any_fl = false;
                        }

                    }
                    if (policy.Source.Count > 0 && policy.Source.First().Name.Equals("Any"))
                    {
                        so_count++;
                        if (any_fl)
                        {
                            all++;
                            any_fl = false;
                        }

                    }
                    if (policy.Service.Count > 0 && policy.Service.First().Name.Equals("Any"))
                    {
                        se_count++;
                        if (any_fl)
                        {
                            all++;
                            any_fl = false;
                        }

                    }
                }
                NewJunoAnalizStatistic._rulesServicesutilizingServicesAnyDestinationCount = de_count;
                NewJunoAnalizStatistic._rulesServicesutilizingServicesAnyServiceCount = se_count;
                NewJunoAnalizStatistic._rulesServicesutilizingServicesAnySourceCount = so_count;
                NewJunoAnalizStatistic._rulesServicesutilizingServicesAnyCount = all;
                NewJunoAnalizStatistic._disabledServicesRulesCount = dis;
                NewJunoAnalizStatistic._timesServicesRulesCount = time_count;
                NewJunoAnalizStatistic.CalculateCorrectAll(_cpNetworks, _cpNetworkGroups, _cpHosts, _cpRanges, _cpTcpServices, _cpUdpServices, _cpSctpServices, _cpIcmpServices, _cpDceRpcServices, _cpOtherServices, _cpServiceGroups, _cpRpcServices);
            }
            else
            {
                if (_cpPackages.Count > 0)
                {
                    this.OptimizationPotential = RulesInConvertedPackage() > 0 ? ((RulesInConvertedPackage() - RulesInConvertedOptimizedPackage()) * 100 / (float)RulesInConvertedPackage()) : 0;

                    ExportManagmentReport();
                }

            }
        }

        public override void ExportManagmentReport()
        {
            TotalRules = RulesInConvertedPackage();
            NewJunoAnalizStatistic._totalServicesRulesCount = RulesInConvertedPackage();
            NewJunoAnalizStatistic._totalServicesRulesOptCount = RulesInConvertedOptimizedPackage();

            NewJunoAnalizStatistic._totalFileRules += NewJunoAnalizStatistic._totalServicesRulesCount;
            NewJunoAnalizStatistic._totalFileRulesOpt += NewJunoAnalizStatistic._totalServicesRulesOptCount;
            var potentialCount = NewJunoAnalizStatistic._totalServicesRulesCount - NewJunoAnalizStatistic._totalServicesRulesOptCount;
            var potentialPersent = NewJunoAnalizStatistic._totalServicesRulesCount > 0 ? (potentialCount * 100 / (float)NewJunoAnalizStatistic._totalServicesRulesCount) : 0;
            NewJunoAnalizStatistic._fullrullPackageCount += NewJunoAnalizStatistic._fullrullPackcount;
            NewJunoAnalizStatistic._totalrullPackageCount += NewJunoAnalizStatistic._totalServicesRulesCount;
            using (var file = new StreamWriter(VendorManagmentReportHtmlFile))
            {
                file.WriteLine("<html>");
                file.WriteLine("<head>");
                file.WriteLine("<style>");
                file.WriteLine("  body { font-family: Arial; }");
                file.WriteLine("  .report_table { border-collapse: separate;border-spacing: 0px; font-family: Lucida Console;}");
                file.WriteLine("  td {padding: 5px; vertical-align: top}");
                file.WriteLine("  .line_number {background: lightgray;}");
                file.WriteLine("  .unhandeled {color: Fuchsia;}");
                file.WriteLine("  .notimportant {color: Gray;}");
                file.WriteLine("  .converterr {color: Red;}");
                file.WriteLine("  .convertinfo {color: Blue;}");
                file.WriteLine("  .err_title {color: Red;}");
                file.WriteLine("  .info_title {color: Blue;}");
                file.WriteLine("</style>");
                file.WriteLine("</head>");

                file.WriteLine("<body>");
                file.WriteLine("<h2>Juniper managment report file</h2>");
                file.WriteLine("<h3>OBJECTS DATABASE</h3>");

                file.WriteLine("<table style='margin-bottom: 30px; background: rgb(250,250,250);'>");
                file.WriteLine($"   <tr><td style='font-size: 14px;'></td> <td style='font-size: 14px;'>STATUS</td> <td style='font-size: 14px;'>COUNT</td> <td style='font-size: 14px;'>PERCENT</td> <td style='font-size: 14px;'>REMEDIATION</td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Total Network Objects</td> <td style='font-size: 14px;'>{ChoosePict(NewJunoAnalizStatistic.TotalNetworkObjectsPercent, 100, 100)}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic._totalNetworkObjectsCount}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic.TotalNetworkObjectsPercent}%</td> <td style='font-size: 14px;'></td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Unused Network Objects</td> <td style='font-size: 14px;'>{ChoosePict(NewJunoAnalizStatistic.UnusedNetworkObjectsPercent, 5, 25)}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic._unusedNetworkObjectsCount}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic.UnusedNetworkObjectsPercent.ToString("F")}%</td> <td style='font-size: 14px;'>{(NewJunoAnalizStatistic._unusedNetworkObjectsCount > 0 ? "Consider deleting these objects." : "")}</td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Duplicate Network Objects</td> <td style='font-size: 14px;'>{ChoosePict(NewJunoAnalizStatistic.DuplicateNetworkObjectsPercent, 5, 25)}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic._duplicateNetworkObjectsCount}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic.DuplicateNetworkObjectsPercent.ToString("F")}%</td> <td style='font-size: 14px;'></td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Nested Network Groups</td> <td style='font-size: 14px;'>{ChoosePict(NewJunoAnalizStatistic.NestedNetworkGroupsPercent, 5, 25)}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic._nestedNetworkGroupsCount}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic.NestedNetworkGroupsPercent.ToString("F")}%</td> <td style='font-size: 14px;'></td></tr>");
                file.WriteLine("</table>");

                file.WriteLine("<h3>SERVICES DATABASE</h3>");
                file.WriteLine("<table style='margin-bottom: 30px; background: rgb(250,250,250);'>");
                file.WriteLine($"   <tr><td style='font-size: 14px;'></td> <td style='font-size: 14px;'>STATUS</td> <td style='font-size: 14px;'>COUNT</td> <td style='font-size: 14px;'>PERCENT</td> <td style='font-size: 14px;'>REMEDIATION</td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Total Services Objects</td> <td style='font-size: 14px;'>{ChoosePict(NewJunoAnalizStatistic.TotalServicesObjectsPercent, 100, 100)}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic._totalServicesObjectsCount}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic.TotalServicesObjectsPercent}%</td> <td style='font-size: 14px;'></td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Unused Services Objects</td> <td style='font-size: 14px;'>{ChoosePict(NewJunoAnalizStatistic.UnusedServicesObjectsPercent, 5, 25)}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic._unusedServicesObjectsCount}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic.UnusedServicesObjectsPercent.ToString("F")}%</td> <td style='font-size: 14px;'>{(NewJunoAnalizStatistic._unusedServicesObjectsCount > 0 ? "Consider deleting these objects." : "")}</td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Duplicate Services Objects</td> <td style='font-size: 14px;'>{ChoosePict(NewJunoAnalizStatistic.DuplicateServicesObjectsPercent, 5, 25)}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic._duplicateServicesObjectsCount}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic.DuplicateServicesObjectsPercent.ToString("F")}%</td> <td style='font-size: 14px;'></td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Nested Services Groups</td> <td style='font-size: 14px;'>{ChoosePict(NewJunoAnalizStatistic.NestedServicesGroupsPercent, 5, 25)}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic._nestedServicesGroupsCount}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic.NestedServicesGroupsPercent.ToString("F")}%</td> <td style='font-size: 14px;'></td></tr>");
                file.WriteLine("</table>");

                file.WriteLine("<h3>POLICY ANALYSIS</h3>");
                file.WriteLine("<table style='margin-bottom: 30px; background: rgb(250,250,250);'>");
                file.WriteLine($"   <tr><td style='font-size: 14px;'></td> <td style='font-size: 14px;'>STATUS</td> <td style='font-size: 14px;'>COUNT</td> <td style='font-size: 14px;'>PERCENT</td> <td style='font-size: 14px;'>REMEDIATION</td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Total Rules</td> <td style='font-size: 14px;'>{ChoosePict(NewJunoAnalizStatistic.TotalServicesRulesPercent, 100, 100)}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic._totalServicesRulesCount}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic.TotalServicesRulesPercent}%</td> <td style='font-size: 14px;'></td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Rules utilizing \"Any\"</td> <td style='font-size: 14px;'>{ChoosePict(NewJunoAnalizStatistic.RulesServicesutilizingServicesAnyPercent, 5, 15)}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic._unrulesServicesutilizingServicesAnyCount}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic.RulesServicesutilizingServicesAnyPercent.ToString("F")}%</td> <td style='font-size: 14px;'>- ANY in Source: {NewJunoAnalizStatistic._unrulesServicesutilizingServicesAnySourceCount}</td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'></td> <td style='font-size: 14px;'></td> <td style='font-size: 14px;'></td> <td style='font-size: 14px;'></td> <td style='font-size: 14px;'>- ANY in Destination: {NewJunoAnalizStatistic._unrulesServicesutilizingServicesAnyDestinationCount} </td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'></td> <td style='font-size: 14px;'></td> <td style='font-size: 14px;'></td> <td style='font-size: 14px;'></td> <td style='font-size: 14px;'>- ANY in Service: {NewJunoAnalizStatistic._unrulesServicesutilizingServicesAnyServiceCount}</td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Disabled Rules</td> <td style='font-size: 14px;'>{ChoosePict(NewJunoAnalizStatistic.DisabledServicesRulesPercent, 5, 25)}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic._undisabledServicesRulesCount}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic.DisabledServicesRulesPercent.ToString("F")}%</td> <td style='font-size: 14px;'></td> {(NewJunoAnalizStatistic._disabledServicesRulesCount > 0 ? "Check if rules are required." : "")}</tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Times Rules</td> <td style='font-size: 14px;'>{ChoosePict(NewJunoAnalizStatistic.TimesServicesRulesPercent, 5, 25)}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic._untimesServicesRulesCount}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic.TimesServicesRulesPercent.ToString("F")}%</td> <td style='font-size: 14px;'></td></tr>");
                //file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Non Logging Rules</td> <td style='font-size: 14px;'>{ChoosePict(NewJunoAnalizStatistic.NonServicesLoggingServicesRulesPercent, 5, 25)}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic._nonServicesLoggingServicesRulesCount}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic.NonServicesLoggingServicesRulesPercent.ToString("F")}%</td> <td style='font-size: 14px;'> {(NewJunoAnalizStatistic._nonServicesLoggingServicesRulesCount > 0 ? "Enable logging for these rules for better tracking and change management." : "")}</td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Cleanup Rule</td> <td style='font-size: 14px;'>{(NewJunoAnalizStatistic._cleanupServicesRuleCount > 0 ? HtmlGoodImageTagManagerReport : HtmlSeriosImageTagManagerReport)}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic._cleanupServicesRuleCount}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic.CleanupServicesRulePercent.ToString("F")}%</td> <td style='font-size: 14px;'>{(NewJunoAnalizStatistic._cleanupServicesRuleCount > 0 ? "Found" : "")}</td></tr>");
                //file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Uncommented Rules</td> <td style='font-size: 14px;'>{ChoosePict(NewJunoAnalizStatistic.UncommentedServicesRulesPercent, 25, 100)}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic._uncommentedServicesRulesCount}</td> <td style='font-size: 14px;'>{NewJunoAnalizStatistic.UncommentedServicesRulesPercent.ToString("F")}%</td> <td style='font-size: 14px;'>{(NewJunoAnalizStatistic._uncommentedServicesRulesCount > 0 ? "Comment rules for better tracking and change management compliance." : "")}</td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Optimization Potential</td> <td style='font-size: 14px;'>{(potentialCount > 0 ? HtmlGoodImageTagManagerReport : HtmlAttentionImageTagManagerReport)}</td> <td style='font-size: 14px;'>{potentialCount}</td> <td style='font-size: 14px;'>{(potentialCount > 0 ? potentialPersent : 0).ToString("F")}%</td> <td style='font-size: 14px;'>{GetOptPhraze(potentialCount > 0 ? (int)potentialPersent : 0)}</td></tr>");
                file.WriteLine("</table>");
                file.WriteLine("</body>");
                file.WriteLine("</html>");
            }
        }

        public override void ExportConfigurationAsHtml()
        {
            using (var file = new StreamWriter(VendorHtmlFile))
            {
                file.WriteLine("<html>");
                file.WriteLine("<head>");
                file.WriteLine("<style>");
                file.WriteLine("  body { font-family: Arial; }");
                file.WriteLine("  .report_table { border-collapse: separate; border-spacing: 0px; font-family: Lucida Console; white-space: pre; }");
                file.WriteLine("  td {padding: 5px; vertical-align: top}");
                file.WriteLine("  .line_number {background: lightgray;}");
                file.WriteLine("  .converterr {color: Red;}");
                file.WriteLine("  .convertinfo {color: Blue;}");
                file.WriteLine("  .err_title {color: Red;}");
                file.WriteLine("  .info_title {color: Blue;}");
                file.WriteLine("</style>");
                file.WriteLine("</head>");

                file.WriteLine("<body>");
                file.WriteLine("<h2>Juniper config file</h2>");

                file.WriteLine("<table style='margin-bottom: 20px; background: rgb(250,250,250);'>");
                file.WriteLine("   <tr><td style='font-size: 14px; text-decoration: underline;'>Colors Legend</td></tr>");
                file.WriteLine("   <tr><td style='font-size: 12px; color: Red;'>Commands with conversion error</td></tr>");
                file.WriteLine("   <tr><td style='font-size: 12px; color: Blue;'>Commands with conversion notification</td></tr>");
                file.WriteLine("</table>");

                file.WriteLine("<div style='margin-bottom: 20px; font-size: 14px; color: Blue;'>");
                file.WriteLine("   <span style='vertical-align: middle; font-size: 14px;'>" + HtmlAlertImageTag);
                file.WriteLine("      <a> Valid Check Point object name consists of the following characters only - \"A-Za-z0-9_.-\". Any invalid character will be replaced with a \"_\" character.</a>");
                file.WriteLine("   </span>");
                file.WriteLine("</div>");

                if (_conversionIncidents.Count > 0)
                {
                    file.WriteLine("<div style='margin-bottom: 20px;'>");
                    file.WriteLine("   <span style='vertical-align: middle; font-size: 14px;'>" + HtmlAlertImageTag);
                    file.WriteLine("      <a href='#ConversionIncidents'>Found " + ConversionIncidentCategoriesCount + " conversion issues in " + ConversionIncidentsCommandsCount + " configuration lines</a>");
                    file.WriteLine("   </span>");
                    file.WriteLine("</div>");
                }

                file.WriteLine("<table class=\"report_table\">");

                string[] lines = File.ReadAllLines(_vendorFilePath);
                int lineNumber = 0;

                _juniperParser.ParsedLines = lines.Count();

                foreach (string line in lines)
                {
                    ++lineNumber;

                    ConversionIncidentType highestIncidentType;
                    string incidentFlag = BuildConversionIncidentInfo(lineNumber, out highestIncidentType);

                    string lineStyle = "";

                    switch (highestIncidentType)
                    {
                        case ConversionIncidentType.Informative:
                            lineStyle = " class=\"convertinfo\" ";
                            break;
                        case ConversionIncidentType.ManualActionRequired:
                            lineStyle = " class=\"converterr\" ";
                            break;
                    }

                    file.WriteLine("<tr>");
                    file.WriteLine("  <td id=\"line_" + lineNumber + "\" class=\"line_number\" style=\"text-align: right;\">" + incidentFlag + lineNumber + "</td>" + "<td " + lineStyle + " >" + WebUtility.HtmlEncode(line) + "</td>");
                    file.WriteLine("</tr>");
                }

                file.WriteLine("</table>");

                if (_conversionIncidents.Count > 0)
                {
                    file.WriteLine("<hr/>");
                    file.WriteLine("<h2 id=\"ConversionIncidents\">Conversion Issues</h2>");

                    bool first = true;
                    ConversionIncident prevErr = null;

                    foreach (ConversionIncident err in _conversionIncidents.OrderByDescending(item => item.IncidentType).ThenBy(item => item.Title).ThenBy(item => item.LineNumber).ToList())
                    {
                        if (first)
                        {
                            if (err.IncidentType == ConversionIncidentType.ManualActionRequired)
                            {
                                file.WriteLine("<h4 class=\"err_title\">" + err.Title + "</h4>");
                            }
                            else
                            {
                                file.WriteLine("<h4 class=\"info_title\">" + err.Title + "</h4>");
                            }
                            file.WriteLine("<table class=\"report_table\">");
                        }

                        if (!first && prevErr.Title != err.Title)
                        {
                            file.WriteLine("</table>");

                            if (err.IncidentType == ConversionIncidentType.ManualActionRequired)
                            {
                                file.WriteLine("<h4 class=\"err_title\">" + err.Title + "</h4>");
                            }
                            else
                            {
                                file.WriteLine("<h4 class=\"info_title\">" + err.Title + "</h4>");
                            }
                            file.WriteLine("<table class=\"report_table\">");
                        }

                        // Do not display the same description for the same line...
                        if (prevErr == null || prevErr.LineNumber != err.LineNumber || prevErr.Description != err.Description)
                        {
                            file.WriteLine("  <tr>");
                            file.WriteLine("    <td class=\"line_number\" style=\"text-align: right;\"> <a href=\"#line_" + err.LineNumber + "\">" + err.LineNumber + "</a></td>");
                            file.WriteLine("    <td>" + err.Description + "</td>");
                            file.WriteLine("  </tr>");
                        }

                        first = false;
                        prevErr = err;
                    }
                }

                file.WriteLine("</body>");
                file.WriteLine("</html>");
            }
        }

        public override void ExportPolicyPackagesAsHtml()
        {
            foreach (CheckPoint_Package package in _cpPackages)
                ExportPackageAsHtml(package);
        }

        #endregion
    }

    public class NewAnalizStatistic
    {
        public CheckPoint_Package _Package;
        public int _optPackageCount = 0;
        public int _fullrullPackcount = 0;
        public int _fullrullPackageCount = 0;
        public int _totalrullPackageCount = 0;
        public int _totalNetworkObjectsCount = 0;
        public int _unusedNetworkObjectsCount = 0;
        public int _duplicateNetworkObjectsCount = 0;
        public int _nestedNetworkGroupsCount = 0;
        public int _nestedNetworkGroupsCountAll = 0;

        public int _totalServicesObjectsCount = 0;
        public int _unusedServicesObjectsCount = 0;
        public int _duplicateServicesObjectsCount = 0;
        public int _nestedServicesGroupsCount = 0;
        public int _nestedServicesGroupsCountAll = 0;

        public int _totalServicesRulesCount = 0;
        public int _totalServicesRulesOptCount = 0;
        public int _rulesServicesutilizingServicesAnyCount = 0;
        public int _rulesServicesutilizingServicesAnySourceCount = 0;
        public int _rulesServicesutilizingServicesAnyDestinationCount = 0;
        public int _rulesServicesutilizingServicesAnyServiceCount = 0;
        public int _unrulesServicesutilizingServicesAnyCount = 0;
        public int _unrulesServicesutilizingServicesAnySourceCount = 0;
        public int _unrulesServicesutilizingServicesAnyDestinationCount = 0;
        public int _unrulesServicesutilizingServicesAnyServiceCount = 0;
        public int _disabledServicesRulesCount = 0;
        public int _undisabledServicesRulesCount = 0;
        public int _unnamedServicesRulesCount = 0;
        public int _timesServicesRulesCount = 0;
        public int _untimesServicesRulesCount = 0;
        public int _nonServicesLoggingServicesRulesCount = 0;
        public int _stealthServicesRuleCount = 0;
        public int _cleanupServicesRuleCount = 0;
        public int _uncommentedServicesRulesCount = 0;

        public int _totalFileRules = 0;
        public int _totalFileRulesOpt = 0;


        public int TotalNetworkObjectsPercent { get { return 100; } }
        public float UnusedNetworkObjectsPercent { get { return _totalNetworkObjectsCount > 0 ? ((float)_unusedNetworkObjectsCount / (float)_totalNetworkObjectsCount) * 100 : 0; } }
        public float DuplicateNetworkObjectsPercent { get { return _totalNetworkObjectsCount > 0 ? ((float)_duplicateNetworkObjectsCount / (float)_totalNetworkObjectsCount) * 100 : 0; } }
        public float NestedNetworkGroupsPercent { get { return _nestedNetworkGroupsCountAll > 0 ? ((float)_nestedNetworkGroupsCount / (float)_nestedNetworkGroupsCountAll) * 100 : 0; } }

        public float TotalServicesObjectsPercent { get { return 100; } }
        public float UnusedServicesObjectsPercent { get { return _totalServicesObjectsCount > 0 ? ((float)_unusedServicesObjectsCount / (float)_totalServicesObjectsCount) * 100 : 0; } }
        public float DuplicateServicesObjectsPercent { get { return _totalServicesObjectsCount > 0 ? ((float)_duplicateServicesObjectsCount / (float)_totalServicesObjectsCount) * 100 : 0; } }
        public float NestedServicesGroupsPercent { get { return _nestedServicesGroupsCountAll > 0 ? ((float)_nestedServicesGroupsCount / (float)_nestedServicesGroupsCountAll) * 100 : 0; } }

        public float TotalServicesRulesPercent { get { return 100; } }
        public float RulesServicesutilizingServicesAnyPercent { get { return _totalServicesRulesCount > 0 ? ((float)_unrulesServicesutilizingServicesAnyCount / (float)_totalServicesRulesCount) * 100 : 0; } }
        public float DisabledServicesRulesPercent { get { return _totalServicesRulesCount > 0 ? ((float)_undisabledServicesRulesCount / (float)_totalServicesRulesCount) * 100 : 0; } }
        public float UnnamedServicesRulesPercent { get { return _totalServicesRulesCount > 0 ? ((float)_unnamedServicesRulesCount / (float)_totalServicesRulesCount) * 100 : 0; } }
        public float TimesServicesRulesPercent { get { return _totalServicesRulesCount > 0 ? ((float)_untimesServicesRulesCount / (float)_totalServicesRulesCount) * 100 : 0; } }
        public float NonServicesLoggingServicesRulesPercent { get { return _totalServicesRulesCount > 0 ? ((float)_nonServicesLoggingServicesRulesCount / (float)_totalServicesRulesCount) * 100 : 0; } }
        public float StealthServicesRulePercent { get { return _totalServicesRulesCount > 0 ? ((float)_stealthServicesRuleCount / (float)_totalServicesRulesCount) * 100 : 0; } }
        public float CleanupServicesRulePercent { get { return _totalServicesRulesCount > 0 ? ((float)_cleanupServicesRuleCount / (float)_totalServicesRulesCount) * 100 : 0; } }
        public float UncommentedServicesRulesPercent { get { return _totalServicesRulesCount > 0 ? ((float)_uncommentedServicesRulesCount / (float)_totalServicesRulesCount) * 100 : 0; } }

        public NewAnalizStatistic(int fullpackcount, int totalpack)
        {
            _fullrullPackageCount = fullpackcount;
            _totalrullPackageCount = totalpack;
        }

        public void Flush()
        {
            _fullrullPackcount = 0;
            _totalServicesRulesCount = 0;
            _rulesServicesutilizingServicesAnyCount = 0;
            _rulesServicesutilizingServicesAnySourceCount = 0;
            _rulesServicesutilizingServicesAnyDestinationCount = 0;
            _rulesServicesutilizingServicesAnyServiceCount = 0;
            _disabledServicesRulesCount = 0;
            _unnamedServicesRulesCount = 0;
            _timesServicesRulesCount = 0;
            _nonServicesLoggingServicesRulesCount = 0;
            _stealthServicesRuleCount = 0;
            _cleanupServicesRuleCount = 0;
            _uncommentedServicesRulesCount = 0;
        }

        public void CalculateCorrectAll(List<CheckPoint_Network> _cpNetworks,
                                                   List<CheckPoint_NetworkGroup> _cpNetworkGroups,
                                                   List<CheckPoint_Host> _cpHosts,
                                                   List<CheckPoint_Range> _cpRanges,
                                                   List<CheckPoint_TcpService> _cpTcpServices,
                                                   List<CheckPoint_UdpService> _cpUdpServices,
                                                   List<CheckPoint_SctpService> _cpSctpServices,
                                                   List<CheckPoint_IcmpService> _cpIcmpServices,
                                                   List<CheckPoint_DceRpcService> _cpDceRpcServices,
                                                   List<CheckPoint_OtherService> _cpOtherServices,
                                                   List<CheckPoint_ServiceGroup> _cpServiceGroups,
                                                   List<CheckPoint_RpcService> _cpRpcServices)
        {
            _unusedNetworkObjectsCount = _unusedNetworkObjectsCount >= 0 ? _unusedNetworkObjectsCount : 0;
            _unusedServicesObjectsCount = _unusedServicesObjectsCount >= 0 ? _unusedServicesObjectsCount : 0;
            _undisabledServicesRulesCount = _disabledServicesRulesCount;
            _unrulesServicesutilizingServicesAnyCount = _rulesServicesutilizingServicesAnyCount;
            _unrulesServicesutilizingServicesAnySourceCount = _rulesServicesutilizingServicesAnySourceCount;
            _unrulesServicesutilizingServicesAnyDestinationCount = _rulesServicesutilizingServicesAnyDestinationCount;
            _unrulesServicesutilizingServicesAnyServiceCount = _rulesServicesutilizingServicesAnyServiceCount;
            _untimesServicesRulesCount = _timesServicesRulesCount;
            _totalNetworkObjectsCount = _cpNetworks.Count + _cpHosts.Count + _cpNetworkGroups.Count + _cpRanges.Count;

            //DUPLICATE CALCULATION
            foreach (var item in _cpNetworks)
            {
                if (_cpNetworks.Where(nt => nt.Netmask == item.Netmask & nt.Subnet == nt.Subnet).Count() > 1) { _duplicateNetworkObjectsCount++; }
            }
            foreach (var item in _cpHosts)
            {
                if (_cpHosts.Where(nt => nt.IpAddress == item.IpAddress).Count() > 1) { _duplicateNetworkObjectsCount++; }
            }
            foreach (var item in _cpRanges)
            {
                if (_cpRanges.Where(nt => nt.RangeFrom == item.RangeFrom & nt.RangeTo == nt.RangeTo).Count() > 1) { _duplicateNetworkObjectsCount++; }
            }
            //
            List<string> vs = new List<string>();
            foreach (var item in _cpNetworkGroups) { vs.AddRange(item.Members); }
            var count = _nestedNetworkGroupsCountAll = vs.Count;
            _nestedNetworkGroupsCount = count - vs.Distinct().Count();
            /////////////////////////////////
            _totalServicesObjectsCount = _cpTcpServices.Count + _cpUdpServices.Count + _cpSctpServices.Count + _cpIcmpServices.Count + _cpDceRpcServices.Count + _cpOtherServices.Count + _cpServiceGroups.Count + _cpRpcServices.Count;
            //
            List<string> allServiceNames = new List<string>();
            _duplicateServicesObjectsCount += _cpTcpServices.Count - _cpTcpServices.Select(n => n.Port).Distinct().Count();
            _duplicateServicesObjectsCount += _cpUdpServices.Count - _cpUdpServices.Select(n => n.Port).Distinct().Count();
            //
            vs = new List<string>();
            foreach (var item in _cpServiceGroups) { vs.AddRange(item.Members); }
            count = _nestedServicesGroupsCountAll = vs.Count;
            _nestedServicesGroupsCount = count - vs.Distinct().Count();
        }
    }

}
