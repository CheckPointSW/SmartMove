/********************************************************************
Copyright (c) 2017, Check Point Software Technologies Ltd.
All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
********************************************************************/

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using CommonUtils;
using CheckPointObjects;
using MigrationBase;
using System.Globalization;
using System.Runtime.InteropServices;
using System.Threading;
using CiscoMigration.CiscoMigration;
using static CheckPointObjects.CheckPoint_Rule;

namespace CiscoMigration
{
    /// <summary>
    /// Converts Cisco ASA commands repository into Check Point objects repository.
    /// Generates conversion reports for objects and policy packages.
    /// </summary>
    public class CiscoConverter : VendorConverter
    {
        //if we are using cisco code for fire power vendor we need set this flag to true value
        public bool isUsingForFirePower { get; set; } = false;

        public NewAnalizStatistic NewCiscoAnalizStatistic = new NewAnalizStatistic(0, 0);

        private List<string> _errorsList = new List<string>(); //conversion errors for config
        private List<string> _warningsList = new List<string>(); //conversion warnings for config

        #region GUI params

        public bool SkipUnusedObjects { get; set; } //check if Optimized configuration is requested
        
        #endregion

        #region Helper Classes

        private class DuplicateNameInfo
        {
            public int DuplicatesCount { get; set; }
            public bool IsCPPredefinedName { get; private set; }

            public DuplicateNameInfo(bool isCPPredefinedName)
            {
                DuplicatesCount = 0;
                IsCPPredefinedName = isCPPredefinedName;
            }
        }

        private class CiscoNetwork
        {
            public int CiscoCommandId { get; private set; }
            public string IpAddress { get; private set; }
            public string NetMask { get; private set; }
            public string MaskPrefix { get; set; }

            public CiscoNetwork(int ciscoCommandId, string sIp) : this(ciscoCommandId, sIp, "") { }
            public CiscoNetwork(int ciscoCommandId, string sIp, string sMask) : this(ciscoCommandId, sIp, sMask, "") { }
            public CiscoNetwork(int ciscoCommandId, string sIp, string sMask, string sMaskPrefix)
            {
                CiscoCommandId = ciscoCommandId;
                IpAddress = sIp;
                NetMask = string.IsNullOrEmpty(sMask) && string.IsNullOrEmpty(sMaskPrefix) ? "255.255.255.255" : sMask;
                MaskPrefix = sMaskPrefix;
            }

            public bool IsHost()
            {
                return NetworkUtils.IsValidIpv4(IpAddress) && (NetworkUtils.GetMaskLength(NetMask) == 32) || NetworkUtils.IsValidIpv6(IpAddress) && string.IsNullOrEmpty(MaskPrefix);
            }

            public bool IsNetwork()
            {
                return NetworkUtils.IsValidIpv4(IpAddress) && NetworkUtils.IsValidNetmaskv4(NetMask) && (NetworkUtils.GetMaskLength(NetMask) < 32) ||
                NetworkUtils.IsValidIpv6(IpAddress) && !string.IsNullOrEmpty(MaskPrefix);
            }

            public string AutoGeneratedName()
            {
                if (IsHost())
                {
                    return "host_" + IpAddress;
                }

                if (IsNetwork())
                {
                    if (!string.IsNullOrEmpty(NetMask))
                        return "network_" + IpAddress + "_" + NetworkUtils.GetMaskLength(NetMask);
                    else
                        return "network_" + IpAddress + "_" + MaskPrefix;
                }

                return "_Err_in_network-line_" + CiscoCommandId;
            }

            public string AutoGeneratedNetworkName()
            {
                if (IsNetwork())
                {
                    if (!string.IsNullOrEmpty(NetMask))
                        return "network_" + IpAddress + "_" + NetworkUtils.GetMaskLength(NetMask);
                    else
                        return "network_" + IpAddress + "_" + MaskPrefix;
                }

                return "_Err_in_network-line_" + CiscoCommandId;
            }

            public override bool Equals(object obj)
            {
                if (obj == null || GetType() != obj.GetType())
                {
                    return false;
                }

                var other = obj as CiscoNetwork;
                if (other == null)
                {
                    return false;
                }

                return (other.IpAddress == IpAddress && other.NetMask == NetMask && other.MaskPrefix == MaskPrefix);
            }

            public override int GetHashCode()
            {
                string hash = IpAddress + "," + NetMask + "," + MaskPrefix;
                return hash.GetHashCode();
            }
        }

        private class CiscoNatCustomData
        {
            public string Interface1 { get; set; }
            public string Interface2 { get; set; }
            public bool IsStaticMirrorRule { get; set; }
            public bool IsObjectNatRule { get; set; }
            public bool IsNonNatRule { get; set; }
            public bool IsAutoAfterSectionRule { get; set; }
            public bool IsNonNatSectionRule { get; set; }
        }

        private static class CheckPointServiceObjectsFactory
        {
            public static ProtocolType ProtocolStringToProtocolType(ref string sProtocol)
            {
                var protocol = ProtocolType.NA;

                switch (sProtocol)
                {
                    case "tcp":
                        protocol = ProtocolType.Tcp;
                        break;

                    case "udp":
                        protocol = ProtocolType.Udp;
                        break;

                    case "icmp":
                        protocol = ProtocolType.Icmp;
                        break;

                    case "icmp6":
                        protocol = ProtocolType.Icmp6;
                        break;

                    case "ip":
                        protocol = ProtocolType.Ip;
                        break;

                    default:
                        string serviceName;
                        if (CiscoKnownServices.IsKnownService(sProtocol))
                        {
                            protocol = ProtocolType.KnownOtherIpProtocol;
                        }
                        else if (CiscoKnownServices.IsKnownServiceNumber(sProtocol, out serviceName))   // protocol number is used!!!
                        {
                            protocol = ProtocolType.KnownOtherIpProtocol;
                            sProtocol = serviceName;
                        }
                        break;
                }

                return protocol;
            }

            public static string AutoGeneratedName(CheckPointObjectsRepository cpObjects, string sProtocol, string sPortOperator, string sPort, ServiceDirection where, int ciscoCommandId)
            {
                var protocol = ProtocolStringToProtocolType(ref sProtocol);
                if (protocol == ProtocolType.KnownOtherIpProtocol)
                {
                    sPort = sProtocol;
                }

                var portOperator = TcpUdpPortOperatorType.All;

                switch (sPortOperator)
                {
                    case "all":   // avoid error reporting...
                        break;

                    case "eq":
                        portOperator = TcpUdpPortOperatorType.Eq;
                        break;

                    case "gt":
                        portOperator = TcpUdpPortOperatorType.Gt;
                        break;

                    case "lt":
                        portOperator = TcpUdpPortOperatorType.Lt;
                        break;

                    default:
                        break;
                }

                return AutoGeneratedName(cpObjects, protocol, portOperator, sPort, where, ciscoCommandId);
            }

            public static string AutoGeneratedName(CheckPointObjectsRepository cpObjects, ProtocolType protocol, TcpUdpPortOperatorType portOperator, string sPort, ServiceDirection where, int ciscoCommandId)
            {
                string name = "";
                bool serviceFound = false;

                switch (protocol)
                {
                    case ProtocolType.Tcp:
                        name = "TCP_";
                        if (portOperator == TcpUdpPortOperatorType.Gt)
                        {
                            portOperator = TcpUdpPortOperatorType.Range;
                            sPort = (int.Parse(sPort) + 1).ToString() + "-65535";
                        }
                        if (portOperator == TcpUdpPortOperatorType.Lt)
                        {
                            portOperator = TcpUdpPortOperatorType.Range;
                            sPort = "1-" + (int.Parse(sPort) - 1).ToString();
                        }
                        if (portOperator == TcpUdpPortOperatorType.Eq || portOperator == TcpUdpPortOperatorType.Range)
                        {
                            name = name + sPort;
                        }
                        if (portOperator == TcpUdpPortOperatorType.All)
                        {
                            name = name + "All";
                        }
                        if (portOperator == TcpUdpPortOperatorType.ReferenceObject)
                        {
                            name = sPort;
                        }
                        break;

                    case ProtocolType.Udp:
                        name = "UDP_";
                        if (portOperator == TcpUdpPortOperatorType.Gt)
                        {
                            portOperator = TcpUdpPortOperatorType.Range;
                            sPort = (int.Parse(sPort) + 1).ToString() + "-65535";
                        }
                        if (portOperator == TcpUdpPortOperatorType.Lt)
                        {
                            portOperator = TcpUdpPortOperatorType.Range;
                            sPort = "1-" + (int.Parse(sPort) - 1).ToString();
                        }
                        if (portOperator == TcpUdpPortOperatorType.Eq || portOperator == TcpUdpPortOperatorType.Range)
                        {
                            name = name + sPort;
                        }
                        if (portOperator == TcpUdpPortOperatorType.All)
                        {
                            name = name + "All";
                        }
                        if (portOperator == TcpUdpPortOperatorType.ReferenceObject)
                        {
                            name = sPort;
                        }
                        break;

                    case ProtocolType.Icmp:
                        name = "ICMP_" + CiscoKnownServices.ConvertIcmpServiceToType(sPort);
                        name = cpObjects.GetKnownServiceName(name, out serviceFound);
                        return serviceFound ? name : "icmp-proto";

                    case ProtocolType.Icmp6:
                        name = "ICMP_" + CiscoKnownServices.ConvertIcmpServiceToType(sPort);
                        name = cpObjects.GetKnownServiceName(name, out serviceFound);
                        return serviceFound ? name : "IPv6-ICMP";

                    case ProtocolType.Ip:
                        if (portOperator == TcpUdpPortOperatorType.All)
                        {
                            name = CheckPointObject.Any;
                        }
                        else
                        {
                            name = "_Err_in_service-line_" + ciscoCommandId;
                        }
                        return name;

                    case ProtocolType.KnownOtherIpProtocol:
                        name = "OTHER_" + CiscoKnownServices.ConvertServiceToPort(sPort);
                        name = cpObjects.GetKnownServiceName(name, out serviceFound);
                        return serviceFound ? name : sPort;

                    case ProtocolType.NA:
                        return "_Err_in_service-line_" + ciscoCommandId;
                }

                if (where == ServiceDirection.Source)
                {
                    name = name + "_SourcePort";
                }

                return cpObjects.GetKnownServiceName(name, out serviceFound);
            }

            public static CheckPointObject CreateServiceObj(CheckPointObjectsRepository cpObjects, ProtocolType protocol, TcpUdpPortOperatorType portOperator, string sPort, ServiceDirection where, int ciscoCommandId)
            {
                CheckPointObject serviceObj = null;

                switch (protocol)
                {
                    case ProtocolType.Tcp:
                        if (portOperator == TcpUdpPortOperatorType.ReferenceObject)
                        {
                            // Skip, the referenced object will be created on its own!!!
                            return null;
                        }

                        var tcp = new CheckPoint_TcpService();

                        if (portOperator == TcpUdpPortOperatorType.Eq ||
                            portOperator == TcpUdpPortOperatorType.Range ||
                            portOperator == TcpUdpPortOperatorType.All ||
                            portOperator == TcpUdpPortOperatorType.Gt ||
                            portOperator == TcpUdpPortOperatorType.Lt)
                        {
                            string objName = AutoGeneratedName(cpObjects, protocol, portOperator, sPort, where, ciscoCommandId);

                            if (portOperator == TcpUdpPortOperatorType.All)
                            {
                                sPort = "1-65535";
                            }
                            if (portOperator == TcpUdpPortOperatorType.Gt)
                            {
                                sPort = (int.Parse(sPort) + 1).ToString() + "-65535";
                            }
                            if (portOperator == TcpUdpPortOperatorType.Lt)
                            {
                                sPort = "1-" + (int.Parse(sPort) - 1).ToString();
                            }
                            if (where == ServiceDirection.Destination)
                            {
                                tcp.Port = sPort;
                            }
                            if (where == ServiceDirection.Source)
                            {
                                tcp.SourcePort = sPort;
                                tcp.Port = "1-65535";
                            }
                            tcp.Name = objName;
                            serviceObj = tcp;
                        }
                        break;

                    case ProtocolType.Udp:
                        if (portOperator == TcpUdpPortOperatorType.ReferenceObject)
                        {
                            // Skip, the referenced object will be created on its own!!!
                            return null;
                        }

                        var udp = new CheckPoint_UdpService();

                        if (portOperator == TcpUdpPortOperatorType.Eq ||
                            portOperator == TcpUdpPortOperatorType.Range ||
                            portOperator == TcpUdpPortOperatorType.All ||
                            portOperator == TcpUdpPortOperatorType.Gt ||
                            portOperator == TcpUdpPortOperatorType.Lt)
                        {
                            string objName = AutoGeneratedName(cpObjects, protocol, portOperator, sPort, where, ciscoCommandId);

                            if (portOperator == TcpUdpPortOperatorType.All)
                            {
                                sPort = "1-65535";
                            }
                            if (portOperator == TcpUdpPortOperatorType.Gt)
                            {
                                sPort = (int.Parse(sPort) + 1).ToString() + "-65535";
                            }
                            if (portOperator == TcpUdpPortOperatorType.Lt)
                            {
                                sPort = "1-" + (int.Parse(sPort) - 1).ToString();
                            }
                            if (where == ServiceDirection.Destination)
                            {
                                udp.Port = sPort;
                            }
                            if (where == ServiceDirection.Source)
                            {
                                udp.SourcePort = sPort;
                                udp.Port = "1-65535";
                            }
                            udp.Name = objName;
                            serviceObj = udp;
                        }
                        break;

                    case ProtocolType.Icmp:
                        // Skip, a predefined "icmp" object is used!!!
                        break;

                    case ProtocolType.Ip:
                        // Skip, a predefined "any" object is used!!!
                        break;

                    case ProtocolType.KnownOtherIpProtocol:
                        {
                            string objName = AutoGeneratedName(cpObjects, protocol, portOperator, sPort, where, ciscoCommandId);
                            if (!string.IsNullOrEmpty(objName))
                            {
                                var other = new CheckPoint_OtherService();
                                other.Name = objName;
                                other.IpProtocol = CiscoKnownServices.ConvertServiceToPort(sPort);
                                serviceObj = other;
                            }
                        }
                        break;

                    case ProtocolType.NA:
                        break;
                }

                return serviceObj;
            }

            public static bool CheckServicesPortRangesOverlapping(CheckPointObject subsetService, CheckPointObject supersetService)
            {
                int subsetTcpPortFrom, subsetTcpPortTo;
                int supersetTcpPortFrom, supersetTcpPortTo;

                if (subsetService.GetType() == typeof(CheckPoint_TcpService) && supersetService.GetType() == typeof(CheckPoint_TcpService))
                {
                    var subsetTcp = (CheckPoint_TcpService)subsetService;
                    var supersetTcp = (CheckPoint_TcpService)supersetService;

                    GetServicePortRanges(subsetTcp.Port, out subsetTcpPortFrom, out subsetTcpPortTo);
                    GetServicePortRanges(supersetTcp.Port, out supersetTcpPortFrom, out supersetTcpPortTo);
                }
                else if (subsetService.GetType() == typeof(CheckPoint_UdpService) && supersetService.GetType() == typeof(CheckPoint_UdpService))
                {
                    var subsetUdp = (CheckPoint_UdpService)subsetService;
                    var supersetUdp = (CheckPoint_UdpService)supersetService;

                    GetServicePortRanges(subsetUdp.Port, out subsetTcpPortFrom, out subsetTcpPortTo);
                    GetServicePortRanges(supersetUdp.Port, out supersetTcpPortFrom, out supersetTcpPortTo);
                }
                else
                {
                    return false;
                }

                if (subsetTcpPortFrom >= supersetTcpPortFrom && subsetTcpPortTo <= supersetTcpPortTo)
                {
                    return true;
                }

                return false;
            }

            private static void GetServicePortRanges(string servicePort, out int from, out int to)
            {
                if (servicePort.Contains("-"))
                {
                    string[] ranges = servicePort.Split('-');
                    int.TryParse(ranges[0], out from);
                    int.TryParse(ranges[1], out to);
                }
                else   // no range
                {
                    int.TryParse(servicePort, out from);
                    int.TryParse(servicePort, out to);
                }
            }
        }

        #endregion

        #region Private Members

        private CiscoParser _ciscoParser;
        private HashSet<CiscoNetwork> _ciscoNetworkObjects;
        private IEnumerable<CiscoCommand> _ciscoAllCommands;
        private IEnumerable<CiscoCommand> _ciscoObjectCommands;
        private IEnumerable<CiscoCommand> _ciscoObjectGroupCommands;
        private IEnumerable<CiscoCommand> _ciscoAclCommands;
        private IEnumerable<CiscoCommand> _ciscoAccessGroupCommands;
        private IEnumerable<CiscoCommand> _ciscoInterfaceCommands;
        private IEnumerable<CiscoCommand> _ciscoTimeRangeCommands;
        private IEnumerable<CiscoCommand> _ciscoClassMapCommands;
        private IList<CiscoCommand> _ciscoSshCommands;
        private Cisco_Hostname _ciscoHostnameCommand;
        private List<Cisco_AccessList> _ciscoGlobalAclCommands = new List<Cisco_AccessList>();
#pragma warning disable CS0108 // 'CiscoConverter._outputFormat' hides inherited member 'VendorConverter._outputFormat'. Use the new keyword if hiding was intended.
        private string _outputFormat;
#pragma warning restore CS0108 // 'CiscoConverter._outputFormat' hides inherited member 'VendorConverter._outputFormat'. Use the new keyword if hiding was intended.

        private List<CheckPoint_NAT_Rule> _cpPreorderedNatRules = new List<CheckPoint_NAT_Rule>();

        private Dictionary<string, CheckPointObject> _usedNetObjects = new Dictionary<string, CheckPointObject>();
        private Dictionary<string, HashSet<string>> _usedObjects = new Dictionary<string, HashSet<string>>(); //<type, [names of objects]>

        private Dictionary<string, DuplicateNameInfo> _duplicateNamesLookup = new Dictionary<string, DuplicateNameInfo>(StringComparer.InvariantCultureIgnoreCase);
        private List<string> _ciscoServiceInvalidNames = new List<string>();
        private List<string> _ciscoFqdnInvalidNames = new List<string>();
        private List<string> _cpUnsafeNames = new List<string>();

        private bool _isInterInterfaceTrafficAllowed = false;
        private bool _isIntraInterfaceTrafficAllowed = false;

        private Dictionary<string, List<string>> _ciscoTimeNamesToCpTimeNamesDict = new Dictionary<string, List<string>>();

        private enum CheckPointDummyObjectType { Host, NetworkGroup, ServiceGroup, OtherService, TimeGroup };

        private IEnumerable<CiscoCommand> CiscoAllCommands
        {
            get
            {
                return _ciscoAllCommands ?? (_ciscoAllCommands = _ciscoParser.Flatten());
            }
        }

        private IEnumerable<CiscoCommand> CiscoObjectCommands
        {
            get
            {
                return _ciscoObjectCommands ?? (_ciscoObjectCommands = _ciscoParser.Filter("object"));
            }
        }

        private IEnumerable<CiscoCommand> CiscoObjectGroupCommands
        {
            get
            {
                return _ciscoObjectGroupCommands ?? (_ciscoObjectGroupCommands = _ciscoParser.Filter("object-group"));
            }
        }

        private IEnumerable<CiscoCommand> CiscoAclCommands
        {
            get
            {
                return _ciscoAclCommands ?? (_ciscoAclCommands = _ciscoParser.Filter("access-list"));
            }
        }

        private IEnumerable<CiscoCommand> CiscoAccessGroupCommands
        {
            get
            {
                return _ciscoAccessGroupCommands ?? (_ciscoAccessGroupCommands = _ciscoParser.Filter("access-group"));
            }
        }

        private IEnumerable<CiscoCommand> CiscoInterfaceCommands
        {
            get
            {
                return _ciscoInterfaceCommands ?? (_ciscoInterfaceCommands = _ciscoParser.Filter("interface"));
            }
        }

        private IEnumerable<CiscoCommand> CisciTimeRangeCommands
        {
            get
            {
                return _ciscoTimeRangeCommands ?? (_ciscoTimeRangeCommands = _ciscoParser.Filter("time-range"));
            }
        }

        private IEnumerable<CiscoCommand> CiscoClassMapCommands
        {
            get
            {
                return _ciscoClassMapCommands ?? (_ciscoClassMapCommands = _ciscoParser.Filter("class-map"));
            }
        }

        private IList<CiscoCommand> CiscoSshCommands
        {
            get
            {
                if (_ciscoSshCommands == null)
                {
                    _ciscoSshCommands = new List<CiscoCommand>();
                    var sshCommands = _ciscoParser.Filter("ssh");

                    foreach (var sshCommand in sshCommands)
                    {
                        if (sshCommand.ConversionIncidentType == ConversionIncidentType.None)
                        {
                            _ciscoSshCommands.Add(sshCommand);
                        }
                    }
                }

                return _ciscoSshCommands;
            }
        }

        private Cisco_Hostname CiscoHostnameCommand
        {
            get
            {
                return _ciscoHostnameCommand ?? (_ciscoHostnameCommand = _ciscoParser.Filter("hostname").FirstOrDefault() as Cisco_Hostname);
            }
        }

        #endregion

        #region Private Methods

        protected override bool AddCheckPointObject(CheckPointObject cpObject)
        {
            if (base.AddCheckPointObject(cpObject))
            {
                string vendor;
                if (isUsingForFirePower)
                    vendor = Vendor.FirePower.ToString();
                else
                    vendor = Vendor.CiscoASA.ToString();
                if (!cpObject.Tags.Contains(vendor))
                {
                    cpObject.Tags.Add(vendor);
                }
            }

            return false;
        }

        private void ApplyConversionIncidentOnCheckPointObject(CheckPointObject cpObject, CiscoCommand ciscoCommand)
        {
            cpObject.ConvertedCommandId = ciscoCommand.Id;

            if (ciscoCommand.ConversionIncidentType != ConversionIncidentType.None)
            {
                cpObject.ConversionIncidentType = ciscoCommand.ConversionIncidentType;

                if (!string.IsNullOrEmpty(ciscoCommand.ConversionIncidentMessage))
                {
                    string ciscoObject = string.IsNullOrEmpty(ciscoCommand.CiscoId) ? ciscoCommand.Text : ciscoCommand.CiscoId;
                    string errorDesc = ciscoCommand.Name() + " details: " + ciscoObject + ".";

                    _conversionIncidents.Add(new ConversionIncident(ciscoCommand.Id,
                                                                    ciscoCommand.ConversionIncidentMessage,
                                                                    errorDesc,
                                                                    ciscoCommand.ConversionIncidentType));
                }
            }
        }

        private void CheckObjectNameValidity(CheckPointObject cpObject, CiscoCommand ciscoCommand)
        {
            string originalName = cpObject.Name;

            if (string.IsNullOrEmpty(originalName))
            {
                ciscoCommand.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                string errorDescription = string.Format("Cisco command: {0}.", ciscoCommand.Text);
                _conversionIncidents.Add(new ConversionIncident(ciscoCommand.Id,
                                                                "Object name cannot be empty. Please review for further possible modifications to objects before migration.",
                                                                errorDescription,
                                                                ciscoCommand.ConversionIncidentType));

                return;
            }

            if (originalName != cpObject.SafeName())
            {
                _cpUnsafeNames.Add(originalName);
            }

            if (cpObject.GetType().ToString().EndsWith("_TcpService") || cpObject.GetType().ToString().EndsWith("_UdpService"))
            {
                // TCP/UDP service name must start with a letter!!!
                if (!Char.IsLetter(originalName[0]))
                {
                    _ciscoServiceInvalidNames.Add(originalName);

                    ciscoCommand.ConversionIncidentType = ConversionIncidentType.Informative;
                    cpObject.ConversionIncidentType = ConversionIncidentType.Informative;   // report on converted object as well!!!

                    string errorDescription = string.Format("Service original name: {0}. Modified name: {1}", originalName, InvalidServiceNamePrefix + originalName);
                    _conversionIncidents.Add(new ConversionIncident(ciscoCommand.Id,
                                                                    "TCP/UDP service object name must start with a letter. Modifying the original name to a Check Point valid name.",
                                                                    errorDescription,
                                                                    ciscoCommand.ConversionIncidentType));
                }
            }

            if (cpObject.GetType().ToString().EndsWith("_Domain"))
            {
                bool isFqdn = true;

                // Check for domain name and fqdn name
                var cpDomain = (CheckPoint_Domain)cpObject;
                if (originalName != cpDomain.Fqdn)
                {
                    isFqdn = false;
                    _ciscoFqdnInvalidNames.Add(originalName);

                    ciscoCommand.ConversionIncidentType = ConversionIncidentType.Informative;
                    cpObject.ConversionIncidentType = ConversionIncidentType.Informative;   // report on converted object as well!!!

                    string errorDescription = string.Format("Domain object name: {0}. FQDN name: {1}", originalName, cpDomain.Fqdn);
                    _conversionIncidents.Add(new ConversionIncident(ciscoCommand.Id,
                                                                    "Cisco Domain object name differs from FQDN name. Using FQDN name as converted Domain object name.",
                                                                    errorDescription,
                                                                    ciscoCommand.ConversionIncidentType));
                }

                // Fqdn name must start with a dot!!!
                if ((isFqdn && !originalName.StartsWith(".")) || !cpDomain.Fqdn.StartsWith("."))
                {
                    if (isFqdn)   // do not add twice...
                    {
                        _ciscoFqdnInvalidNames.Add(originalName);
                    }

                    ciscoCommand.ConversionIncidentType = ConversionIncidentType.Informative;
                    cpObject.ConversionIncidentType = ConversionIncidentType.Informative;   // report on converted object as well!!!

                    string errorDescription = string.Format("Domain original FQDN name: {0}. Modified name: {1}", isFqdn ? originalName : cpDomain.Fqdn, "." + cpDomain.Fqdn);
                    _conversionIncidents.Add(new ConversionIncident(ciscoCommand.Id,
                                                                    "Domain FQDN name must start with a dot. Modifying the original name to a Check Point valid name.",
                                                                    errorDescription,
                                                                    ciscoCommand.ConversionIncidentType));
                }
            }

            DuplicateNameInfo duplicateNameInfo;
            if (_duplicateNamesLookup.TryGetValue(originalName, out duplicateNameInfo))
            {
                ++duplicateNameInfo.DuplicatesCount;
                _duplicateNamesLookup[originalName] = duplicateNameInfo;

                string uniqueName = string.Format("{0}_{1}", originalName, duplicateNameInfo.DuplicatesCount);
                cpObject.Name = uniqueName;

                ciscoCommand.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                string errorTitle = duplicateNameInfo.IsCPPredefinedName
                                        ? "Detected an object with a same name in Check Point's predefined service objects repository."
                                        : "Detected an object with a non unique name. Check Point names should be case insensitive.";
                errorTitle += " Please review for further possible modifications to objects before migration.";
                string errorDescription = string.Format("Original name: {0}. Possible unique name: {1}.", originalName, uniqueName);

                _conversionIncidents.Add(new ConversionIncident(ciscoCommand.Id, errorTitle, errorDescription, ConversionIncidentType.Informative));

                return;
            }

            _duplicateNamesLookup.Add(originalName, new DuplicateNameInfo(false));
        }

        private void EnforceObjectNameValidity()
        {
            // Fix invalid TCP/UDP service names
            foreach (var invalidName in _ciscoServiceInvalidNames)
            {
                bool found = false;
                string validName = InvalidServiceNamePrefix + invalidName;

                // Search in TCP services
                foreach (var tcpService in _cpTcpServices)
                {
                    if (invalidName == tcpService.Name)
                    {
                        tcpService.Name = validName;
                        found = true;
                        break;
                    }
                }

                // Otherwise, search in UDP services
                if (!found)
                {
                    foreach (var udpService in _cpUdpServices)
                    {
                        if (invalidName == udpService.Name)
                        {
                            udpService.Name = validName;
                            break;
                        }
                    }
                }

                // Finally, search references in service groups
                foreach (var serviceGroup in _cpServiceGroups)
                {
                    int pos = serviceGroup.Members.IndexOf(invalidName);
                    if (pos != -1)
                    {
                        serviceGroup.Members[pos] = validName;
                    }
                }
            }

            // Fix invalid domain names
            foreach (var invalidName in _ciscoFqdnInvalidNames)
            {
                string validName = "";

                foreach (var domain in _cpDomains)
                {
                    if (invalidName == domain.Name)
                    {
                        validName = "." + domain.Fqdn;
                        domain.Name = validName;
                        break;
                    }
                }

                // Finally, search references in network groups
                foreach (var networkGroup in _cpNetworkGroups)
                {
                    int pos = networkGroup.Members.IndexOf(invalidName);
                    if (pos != -1)
                    {
                        networkGroup.Members[pos] = validName;
                    }
                }
            }

            // Fix unsafe names
            foreach (var unsafeName in _cpUnsafeNames)
            {
                CheckPointObject cpObject = _cpObjects.GetObject(unsafeName);
                if (cpObject != null)
                {
                    cpObject.Name = cpObject.SafeName();

                    // Search references in service groups
                    foreach (var serviceGroup in _cpServiceGroups)
                    {
                        int pos = serviceGroup.Members.IndexOf(unsafeName);
                        if (pos != -1)
                        {
                            serviceGroup.Members[pos] = cpObject.Name;
                        }
                    }

                    // Search references in network groups
                    foreach (var networkGroup in _cpNetworkGroups)
                    {
                        int pos = networkGroup.Members.IndexOf(unsafeName);
                        if (pos != -1)
                        {
                            networkGroup.Members[pos] = cpObject.Name;
                        }
                    }

                    // Search references in network groups with exclusion
                    foreach (var networkGroup in _cpGroupsWithExclusion)
                    {
                        if (networkGroup.Include == unsafeName)
                        {
                            networkGroup.Include = cpObject.Name;
                        }
                        if (networkGroup.Except == unsafeName)
                        {
                            networkGroup.Except = cpObject.Name;
                        }
                    }
                }
            }
        }

        private CheckPointObject GetCheckPointObjectOrCreateDummy(string cpObjectName, CheckPointDummyObjectType dummyObjectType, CiscoCommand ciscoCommand, string errorTitle, string errorDescription)
        {
            var cpObject = _cpObjects.GetObject(cpObjectName);
            if (cpObject != null)
            {
                return cpObject;
            }

            CheckPointObject cpDummyObject = null;

            switch (dummyObjectType)
            {
                case CheckPointDummyObjectType.Host:
                    cpDummyObject = new CheckPoint_Host { Name = "_Err_in_network-line_" + ciscoCommand.Id, IpAddress = "1.1.1.1" };
                    break;

                case CheckPointDummyObjectType.NetworkGroup:
                    cpDummyObject = new CheckPoint_NetworkGroup { Name = "_Err_in_topology-line_" + ciscoCommand.Id };
                    break;

                case CheckPointDummyObjectType.ServiceGroup:
                    cpDummyObject = new CheckPoint_ServiceGroup { Name = "_Err_in_service-line_" + ciscoCommand.Id };
                    break;

                case CheckPointDummyObjectType.TimeGroup:
                    cpDummyObject = new CheckPoint_TimeGroup { Name = "_Err_L" + ciscoCommand.Id };   // time object name is limited to 11 characters!!!
                    break;

                case CheckPointDummyObjectType.OtherService:
                    if (!string.IsNullOrEmpty(cpObjectName))
                    {
                        cpDummyObject = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects,
                                                                                         ProtocolType.KnownOtherIpProtocol,
                                                                                         TcpUdpPortOperatorType.NA,
                                                                                         cpObjectName,
                                                                                         ServiceDirection.Destination,
                                                                                         ciscoCommand.Id);
                        if (cpDummyObject != null && cpDummyObject.GetType() == typeof(CheckPoint_OtherService))
                        {
                            cpDummyObject.ConvertedCommandId = ciscoCommand.Id;
                            AddCheckPointObject(cpDummyObject);
                            return cpDummyObject;
                        }
                    }

                    cpDummyObject = new CheckPoint_ServiceGroup { Name = "_Err_in_service-line_" + ciscoCommand.Id };
                    break;
            }

            if (cpDummyObject != null)
            {
                cpDummyObject.ConvertedCommandId = ciscoCommand.Id;
                cpDummyObject.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                AddCheckPointObject(cpDummyObject);

                ciscoCommand.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                errorDescription = string.Format("{0} Using dummy object: {1}.", errorDescription, cpDummyObject.Name);
                _conversionIncidents.Add(new ConversionIncident(ciscoCommand.Id, errorTitle, errorDescription, ciscoCommand.ConversionIncidentType));
            }

            return cpDummyObject;
        }

        private CheckPointObject GetCheckPointObjectOrCreateDummyFromNetworkGroupWithSingleMember(CheckPoint_NetworkGroup networkGroup, CiscoCommand ciscoCommand, bool createDummy = true)
        {
            if (networkGroup.Members.Count == 1)
            {
                var cpObject = _cpObjects.GetObject(networkGroup.Members[0]);
                if (cpObject != null)
                {
                    return cpObject;
                }
            }

            if (createDummy)
            {
                return GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                        CheckPointDummyObjectType.Host,
                                                        ciscoCommand,
                                                        "Error creating a NAT rule, group object cannot be used as a translated object",
                                                        "Group object details: " + networkGroup.Name + ".");
            }

            return networkGroup;
        }

        private void PopulateCiscoNetworkObjects()
        {
            _ciscoNetworkObjects = new HashSet<CiscoNetwork>();

            foreach (CiscoCommand command in CiscoAllCommands)
            {
                if (command.Name() == "network-object")
                {
                    var ciscoNetwork = (Cisco_NetworkObject)command;

                    // The referenced object will be created on its own!!!
                    if (string.IsNullOrEmpty(ciscoNetwork.ReferencedObject) && !ciscoNetwork.Text.Contains("255.255.255.255"))
                    {
                        var network = new CiscoNetwork(command.Id, ciscoNetwork.IpAddress, ciscoNetwork.Netmask, ciscoNetwork.MaskPrefix);
                        _ciscoNetworkObjects.Add(network);
                    }
                }
            }

            foreach (CiscoCommand command in CiscoAclCommands)
            {
                var ciscoAcl = (Cisco_AccessList)command;
                if (ciscoAcl.IsRemark)
                {
                    continue;
                }

                //if there is icmp6 service we need to create an 'other service' with name IPv6-ICMP. At this place checks if we have requirements for this service and create his if yes
                CheckIcmp6Service(ciscoAcl);

                CiscoNetwork source;
                CiscoNetwork dest;

                if (ciscoAcl.Source.Subnet == "user" && ciscoAcl.Protocol == ProtocolType.Tcp)
                {
                    _conversionIncidents.Add(new ConversionIncident(ciscoAcl.Id, "Ignoring user, Using access-list without user", RemoveUserParameter(ciscoAcl.Text), ConversionIncidentType.Informative));
                }


                if (ciscoAcl.Source.Type == Cisco_AccessList.SourceDest.SourceDestType.Host)
                {
                    source = new CiscoNetwork(ciscoAcl.Id, ciscoAcl.Source.HostIp);
                    _ciscoNetworkObjects.Add(source);
                }

                if (ciscoAcl.Source.Type == Cisco_AccessList.SourceDest.SourceDestType.SubnetAndMask)
                {
                    source = new CiscoNetwork(ciscoAcl.Id, ciscoAcl.Source.Subnet, ciscoAcl.Source.Netmask);
                    _ciscoNetworkObjects.Add(source);
                }

                if (ciscoAcl.Destination.Type == Cisco_AccessList.SourceDest.SourceDestType.Host)
                {
                    dest = new CiscoNetwork(ciscoAcl.Id, ciscoAcl.Destination.HostIp);
                    _ciscoNetworkObjects.Add(dest);
                }

                if (ciscoAcl.Destination.Type == Cisco_AccessList.SourceDest.SourceDestType.SubnetAndMask)
                {
                    dest = new CiscoNetwork(ciscoAcl.Id, ciscoAcl.Destination.Subnet, ciscoAcl.Destination.Netmask);
                    _ciscoNetworkObjects.Add(dest);
                }
            }
        }

        private string RemoveUserParameter(string originalString)
        {
            string[] words = originalString.Split(' ');
            StringBuilder outString = new StringBuilder();

            outString.Append(words[0]);

            for (int i = 1; i < words.Length; i++)
            {
                if (words[i] != "user" && words[i - 1] != "user")
                {
                    outString.Append(" " + words[i]);
                }
            }

            return outString.ToString();
        }

        private void CheckIcmp6Service(Cisco_AccessList accesslist)
        {
            if (accesslist.Protocol == ProtocolType.Icmp6)
            {
                CheckPoint_OtherService icmp6 = new CheckPoint_OtherService("IPv6-ICMP", "58", "", new List<string>());
                if (_cpOtherServices.Count > 0)
                {
                    foreach (CheckPoint_OtherService service in _cpOtherServices)
                    {
                        if (service.Name.Equals(icmp6.Name))
                            return;
                    }
                    _cpOtherServices.Add(icmp6);
                }
                else
                {
                    _cpOtherServices.Add(icmp6);
                }
                return;
            }
        }

        private void CheckCiscoInterfacesTraffic()
        {
            var ciscoInterfacesTraffic = _ciscoParser.Filter("same-security-traffic");

            foreach (var ciscoCommand in ciscoInterfacesTraffic)
            {
                var ciscoInterfaceTraffic = (Cisco_SameSecurityTraffic)ciscoCommand;

                if (ciscoInterfaceTraffic.TrafficType == Cisco_SameSecurityTraffic.InterfaceTrafficType.Inter)
                {
                    _isInterInterfaceTrafficAllowed = true;
                }

                if (ciscoInterfaceTraffic.TrafficType == Cisco_SameSecurityTraffic.InterfaceTrafficType.Intra)
                {
                    _isIntraInterfaceTrafficAllowed = true;
                }
            }
        }

        private void CheckCiscoInterfacesAntiSpoofing()
        {
            var ciscoAntiSpoofingCommands = _ciscoParser.Filter("ip verify reverse-path interface");

            foreach (var ciscoCommand in ciscoAntiSpoofingCommands)
            {
                var ciscoAntiSpoofing = (Cisco_AntiSpoofing)ciscoCommand;

                if (!string.IsNullOrEmpty(ciscoAntiSpoofing.InterfaceName))
                {
                    ciscoCommand.ConversionIncidentType = ConversionIncidentType.Informative;

                    _conversionIncidents.Add(new ConversionIncident(ciscoAntiSpoofing.Id,
                                                                    "Interface Anti-Spoofing settings should be manually fixed after migration",
                                                                    "Interface name: " + ciscoAntiSpoofing.InterfaceName,
                                                                    ConversionIncidentType.Informative));
                }
            }
        }

        private void BuildListOfUsedObjects(bool convertNat)
        {
            CheckPoint_Package package = Add_Package(true);

            //parent_layer
            PopulateUsedNetObjectsFromRules(package.ParentLayer.Rules);

            //sub policies
            foreach (CheckPoint_Layer layer in package.SubPolicies)
            {
                PopulateUsedNetObjectsFromRules(layer.Rules);
            }

            //NAT
            if (convertNat)
            {
                PopulateUsedNetObjectsFromNatRules();
            }

            //we may add groups with nested objects. need to add them as used recoursive, because groups can contain groups and etc.
            foreach (string key in _usedNetObjects.Keys)
            {
                BuildUsedNetObjectsRecoursive(_usedNetObjects[key].Name);
            }

        }

        private void PopulateUsedNetObjectsFromNatRules()
        {
            foreach (CheckPoint_NAT_Rule rule in _cpNatRules)
            {
                //Orig-Destination
                if (rule.Destination != null)
                {
                    if (rule.Destination.GetType() != typeof(CheckPoint_PredifinedObject))
                    {
                        if (!rule.Destination.Name.Contains("Err_in_"))
                            _usedNetObjects[rule.Destination.SafeName()] = rule.Destination;
                    }
                }

                //Orig-Service
                if (rule.Service != null)
                {
                    if (rule.Service.GetType() != typeof(CheckPoint_PredifinedObject))
                    {
                        if (!rule.Service.Name.Contains("Err_in_"))
                            _usedNetObjects[rule.Service.SafeName()] = rule.Service;
                    }
                }

                //Orig-Source
                if (rule.Source != null)
                {
                    if (rule.Source.GetType() != typeof(CheckPoint_PredifinedObject))
                    {
                        if (!rule.Source.Name.Contains("Err_in_"))
                            _usedNetObjects[rule.Source.SafeName()] = rule.Source;
                    }
                }

                //Translated-Destination
                if (rule.TranslatedDestination != null)
                {
                    if (rule.TranslatedDestination.GetType() != typeof(CheckPoint_PredifinedObject))
                    {
                        if (!rule.TranslatedDestination.Name.Contains("Err_in_"))
                            _usedNetObjects[rule.TranslatedDestination.SafeName()] = rule.TranslatedDestination;
                    }
                }

                //Translated-Service
                if (rule.TranslatedService != null)
                {
                    if (rule.TranslatedService.GetType() != typeof(CheckPoint_PredifinedObject))
                    {
                        if (!rule.TranslatedService.Name.Contains("Err_in_"))
                            _usedNetObjects[rule.TranslatedService.SafeName()] = rule.TranslatedService;
                    }
                }

                //Translated-Source
                if (rule.TranslatedSource != null)
                {
                    if (rule.TranslatedSource.GetType() != typeof(CheckPoint_PredifinedObject))
                    {
                        if (!rule.TranslatedSource.Name.Contains("Err_in_"))
                            _usedNetObjects[rule.TranslatedSource.SafeName()] = rule.TranslatedSource;
                    }
                }
            }
        }

        private void PopulateUsedNetObjectsFromRules(List<CheckPoint_Rule> rules)
        {
            foreach (CheckPoint_Rule rule in rules)
            {
                foreach (var dest in rule.Destination)
                {
                    if (dest.GetType() == typeof(CheckPoint_PredifinedObject))
                        continue;
                    else
                    {
                        if (!dest.Name.Contains("Err_in_"))
                            _usedNetObjects[dest.SafeName()] = dest;
                    }
                }

                foreach (var src in rule.Source)
                {
                    if (src.Name.StartsWith("bsr-sep-02") || src.Name.StartsWith("bsr-02.bbs"))
                    {
                        int i = 1;
                        i += 1;
                    }
                    if (src.GetType() == typeof(CheckPoint_PredifinedObject))
                        continue;
                    else
                    {
                        if (!src.Name.Contains("Err_in_"))
                            _usedNetObjects[src.SafeName()] = src;
                    }
                }

                foreach (var src in rule.Service)
                {
                    if (_usedNetObjects.Keys.Contains(src.Name))
                        continue;
                    else
                    {
                        if (!src.Name.Contains("Err_in_"))
                            _usedNetObjects[src.SafeName()] = src;
                    }
                }
            }
        }

        private void BuildUsedNetObjectsRecoursive(string checkName)
        {
            //host
            foreach (CheckPoint_Host host in _cpHosts)
            {
                //if checked name is host
                if (host.Name == checkName)
                {
                    AddUsedObject<CheckPoint_Host>(host.Name);
                    return;
                }
            }

            //network
            foreach (CheckPoint_Network net in _cpNetworks)
            {
                //if checked name is network
                if (net.Name == checkName)
                {
                    AddUsedObject<CheckPoint_Network>(checkName);
                    return;
                }
            }

            //checking on address range name
            foreach (CheckPoint_Range range in _cpRanges)
            {
                //if checked name is address range
                if (range.Name == checkName)
                {
                    AddUsedObject<CheckPoint_Range>(checkName);
                    return;
                }
            }


            //checking on net group
            foreach (CheckPoint_NetworkGroup gr in _cpNetworkGroups)
            {
                if (gr.Name == checkName)
                {
                    AddUsedObject<CheckPoint_NetworkGroup>(gr.Name);
                    //if has members
                    if (gr.Members.Count > 0)
                    {
                        foreach (string member in gr.Members)
                        {
                            BuildUsedNetObjectsRecoursive(member);
                        }
                    }
                }
            }

            //checking on address net group with exclusions
            foreach (CheckPoint_GroupWithExclusion gr in _cpGroupsWithExclusion)
            {
                if (gr.Name == checkName)
                {
                    AddUsedObject<CheckPoint_GroupWithExclusion>(gr.Name);

                    if (!string.IsNullOrEmpty(gr.Include))
                        AddUsedObject<CheckPoint_NetworkGroup>(gr.Include);
                    if (!string.IsNullOrEmpty(gr.Except))
                        AddUsedObject<CheckPoint_NetworkGroup>(gr.Except);
                    return;
                }
            }

            //checking on zone
            foreach (CheckPoint_Zone zone in _cpZones)
            {
                //if checked name is zone
                if (zone.Name == checkName)
                {
                    AddUsedObject<CheckPoint_Zone>(checkName);
                    return;
                }
            }

            //checking on TcpService
            foreach (CheckPoint_TcpService tcp in _cpTcpServices)
            {
                if (tcp.Name == checkName)
                {
                    AddUsedObject<CheckPoint_TcpService>(checkName);
                    return;
                }
            }

            //checking on UdpService
            foreach (CheckPoint_UdpService udp in _cpUdpServices)
            {
                if (udp.Name == checkName)
                {
                    AddUsedObject<CheckPoint_UdpService>(checkName);
                    return;
                }
            }

            //checking on Sctp
            foreach (CheckPoint_SctpService sctp in _cpSctpServices)
            {
                if (sctp.Name == checkName)
                {
                    AddUsedObject<CheckPoint_SctpService>(checkName);
                    return;
                }
            }

            //checking on Icmp
            foreach (CheckPoint_IcmpService icmp in _cpIcmpServices)
            {
                if (icmp.Name == checkName)
                {
                    AddUsedObject<CheckPoint_IcmpService>(checkName);
                    return;
                }
            }

            //checking on Rpc
            foreach (CheckPoint_RpcService rpc in _cpRpcServices)
            {
                if (rpc.Name == checkName)
                {
                    AddUsedObject<CheckPoint_RpcService>(checkName);
                    return;
                }
            }

            //checking on DceRpc
            foreach (CheckPoint_DceRpcService rpc in _cpDceRpcServices)
            {
                if (rpc.Name == checkName)
                {
                    AddUsedObject<CheckPoint_DceRpcService>(checkName);
                    return;
                }
            }

            //checking on Other services
            foreach (CheckPoint_OtherService os in _cpOtherServices)
            {
                if (os.Name == checkName)
                {
                    AddUsedObject<CheckPoint_OtherService>(checkName);
                    return;
                }
            }

            //checking on service group
            foreach (CheckPoint_ServiceGroup os in _cpServiceGroups)
            {
                if (os.Name == checkName)
                {
                    AddUsedObject<CheckPoint_ServiceGroup>(os.Name);
                    //if has members
                    if (os.Members.Count > 0)
                    {
                        foreach (string member in os.Members)
                        {
                            BuildUsedNetObjectsRecoursive(member);
                        }
                    }
                }
            }

            //checking on time obj
            foreach (CheckPoint_Time os in _cpTimes)
            {
                if (os.Name == checkName)
                {
                    AddUsedObject<CheckPoint_Time>(checkName);
                    return;
                }
            }

            //checking on time group
            foreach (CheckPoint_TimeGroup os in _cpTimeGroups)
            {
                if (os.Name == checkName)
                {
                    //if has members
                    if (os.Members.Count > 0)
                    {
                        foreach (string member in os.Members)
                        {
                            BuildUsedNetObjectsRecoursive(member);
                        }
                    }
                }
            }
        }

        private void CollectOnlyUsedObjects()
        {
            #region temp lists
            List<CheckPoint_Host> newHostList = new List<CheckPoint_Host>();
            List<CheckPoint_Network> newNetList = new List<CheckPoint_Network>();
            List<CheckPoint_Range> newRangeList = new List<CheckPoint_Range>();
            List<CheckPoint_NetworkGroup> newNetworkGroups = new List<CheckPoint_NetworkGroup>();
            List<CheckPoint_GroupWithExclusion> newNetworkGroupsWI = new List<CheckPoint_GroupWithExclusion>();
            List<CheckPoint_Zone> newZoneList = new List<CheckPoint_Zone>();
            List<CheckPoint_DceRpcService> newDceList = new List<CheckPoint_DceRpcService>();
            List<CheckPoint_RpcService> newRpcList = new List<CheckPoint_RpcService>();
            List<CheckPoint_IcmpService> newIcmpList = new List<CheckPoint_IcmpService>();
            List<CheckPoint_SctpService> newSctpList = new List<CheckPoint_SctpService>();
            List<CheckPoint_UdpService> newUDPList = new List<CheckPoint_UdpService>();
            List<CheckPoint_TcpService> newTCPList = new List<CheckPoint_TcpService>();
            List<CheckPoint_OtherService> newOSList = new List<CheckPoint_OtherService>();
            List<CheckPoint_Time> newTimeList = new List<CheckPoint_Time>();
            List<CheckPoint_TimeGroup> newTimeGList = new List<CheckPoint_TimeGroup>();
            #endregion

            foreach (string typeName in _usedObjects.Keys)
            {
                switch (typeName)
                {
                    case "CheckPoint_Host":
                        foreach (var host in _cpHosts)
                        {
                            if (_usedObjects[typeName].Contains(host.Name))
                                newHostList.Add(host);
                        }
                        break;

                    case "CheckPoint_Network":
                        foreach (var network in _cpNetworks)
                        {
                            if (_usedObjects[typeName].Contains(network.Name))
                                newNetList.Add(network);
                        }
                        break;

                    case "CheckPoint_Range":
                        foreach (var range in _cpRanges)
                        {
                            if (_usedObjects[typeName].Contains(range.Name))
                                newRangeList.Add(range);
                        }
                        break;

                    case "CheckPoint_NetworkGroup":
                        foreach (var gr in _cpNetworkGroups)
                        {
                            if (_usedObjects[typeName].Contains(gr.Name))
                                newNetworkGroups.Add(gr);
                        }
                        break;

                    case "CheckPoint_GroupWithExclusion":
                        foreach (var gr in _cpGroupsWithExclusion)
                        {
                            if (_usedObjects[typeName].Contains(gr.Name))
                                newNetworkGroupsWI.Add(gr);
                        }
                        break;

                    case "CheckPoint_Zone":
                        foreach (var zone in _cpZones)
                        {
                            if (_usedObjects[typeName].Contains(zone.Name))
                                newZoneList.Add(zone);
                        }
                        break;

                    case "CheckPoint_DceRpcService":
                        foreach (var dce in _cpDceRpcServices)
                        {
                            if (_usedObjects[typeName].Contains(dce.Name))
                                newDceList.Add(dce);
                        }
                        break;

                    case "CheckPoint_RpcService":
                        foreach (var rpc in _cpRpcServices)
                        {
                            if (_usedObjects[typeName].Contains(rpc.Name))
                                newRpcList.Add(rpc);
                        }
                        break;

                    case "CheckPoint_IcmpService":
                        foreach (var icmp in _cpIcmpServices)
                        {
                            if (_usedObjects[typeName].Contains(icmp.Name))
                                newIcmpList.Add(icmp);
                        }
                        break;

                    case "CheckPoint_SctpService":
                        foreach (var sctp in _cpSctpServices)
                        {
                            if (_usedObjects[typeName].Contains(sctp.Name))
                                newSctpList.Add(sctp);
                        }
                        break;

                    case "CheckPoint_UdpService":
                        foreach (var udp in _cpUdpServices)
                        {
                            if (_usedObjects[typeName].Contains(udp.Name))
                                newUDPList.Add(udp);
                        }
                        break;

                    case "CheckPoint_TcpService":
                        foreach (var os in _cpTcpServices)
                        {
                            if (_usedObjects[typeName].Contains(os.Name))
                                newTCPList.Add(os);
                        }
                        break;

                    case "CheckPoint_OtherService":
                        foreach (var os in _cpOtherServices)
                        {
                            if (_usedObjects[typeName].Contains(os.Name))
                                newOSList.Add(os);
                        }
                        break;

                    case "CheckPoint_Time":
                        foreach (var time in _cpTimes)
                        {
                            if (_usedObjects[typeName].Contains(time.Name))
                                newTimeList.Add(time);
                        }
                        break;

                    case "CheckPoint_TimeGroup":
                        foreach (var time in _cpTimeGroups)
                        {
                            if (_usedObjects[typeName].Contains(time.Name))
                                newTimeGList.Add(time);
                        }
                        break;
                }

            }

            _cpHosts = newHostList;
            _cpNetworks = newNetList;
            _cpRanges = newRangeList;
            _cpNetworkGroups = newNetworkGroups;
            _cpGroupsWithExclusion = newNetworkGroupsWI;
            _cpZones = newZoneList;
            _cpDceRpcServices = newDceList;
            _cpRpcServices = newRpcList;
            _cpIcmpServices = newIcmpList;
            _cpSctpServices = newSctpList;
            _cpUdpServices = newUDPList;
            _cpTcpServices = newTCPList;
            _cpOtherServices = newOSList;
            _cpServiceGroups = new List<CheckPoint_ServiceGroup>();
            _cpTimes = newTimeList;
            _cpTimeGroups = newTimeGList;
        }

        private void AddUsedObject<T>(string name)
        {
            if (!_usedObjects.Keys.Contains(typeof(T).ToString().Split('.').Last()))
                _usedObjects[typeof(T).ToString().Split('.').Last()] = new HashSet<string>();
            _usedObjects[typeof(T).ToString().Split('.').Last()].Add(Validators.ChangeNameAccordingToRules(name));
        }

        private void Add_Networks()
        {
            foreach (CiscoNetwork network in _ciscoNetworkObjects)
            {
                if (network.IsHost())
                {
                    var cpHost = new CheckPoint_Host();
                    cpHost.Name = network.AutoGeneratedName();
                    cpHost.Name = cpHost.SafeName();
                    cpHost.IpAddress = network.IpAddress;
                    cpHost.ConvertedCommandId = network.CiscoCommandId;
                    AddCheckPointObject(cpHost);
                }
                else if (network.IsNetwork())
                {
                    var cpNetwork = new CheckPoint_Network();
                    cpNetwork.Name = network.AutoGeneratedName();
                    cpNetwork.Name = cpNetwork.SafeName();
                    cpNetwork.Subnet = network.IpAddress;
                    cpNetwork.Netmask = network.NetMask;
                    cpNetwork.MaskLength = network.MaskPrefix != null ? network.MaskPrefix : "";
                    cpNetwork.ConvertedCommandId = network.CiscoCommandId;
                    AddCheckPointObject(cpNetwork);
                }
            }
        }

        private void Add_Objects()
        {
            foreach (CiscoCommand command in CiscoObjectCommands)
            {
                var ciscoObject = (Cisco_Object)command;

                switch (ciscoObject.ObjectType)
                {
                    case Cisco_Object.ObjectTypes.Fqdn:
                        var cpDomain = new CheckPoint_Domain();
                        cpDomain.Name = ciscoObject.CiscoId;
                        cpDomain.Comments = ciscoObject.Description;
                        cpDomain.Fqdn = ciscoObject.Fqdn;
                        ApplyConversionIncidentOnCheckPointObject(cpDomain, ciscoObject);
                        CheckObjectNameValidity(cpDomain, ciscoObject);
                        AddCheckPointObject(cpDomain);
                        break;

                    case Cisco_Object.ObjectTypes.Host:
                        var cpHost = new CheckPoint_Host();
                        cpHost.Name = ciscoObject.CiscoId;
                        cpHost.Name = cpHost.SafeName();
                        cpHost.Comments = ciscoObject.Description;
                        cpHost.IpAddress = ciscoObject.HostAddress;
                        ApplyConversionIncidentOnCheckPointObject(cpHost, ciscoObject);
                        CheckObjectNameValidity(cpHost, ciscoObject);
                        AddCheckPointObject(cpHost);
                        break;

                    case Cisco_Object.ObjectTypes.Network:
                        var cpNetwork = new CheckPoint_Network();
                        cpNetwork.Name = ciscoObject.CiscoId;
                        cpNetwork.Name = cpNetwork.SafeName();
                        cpNetwork.Comments = ciscoObject.Description;
                        cpNetwork.Subnet = ciscoObject.Network;
                        cpNetwork.Netmask = ciscoObject.Netmask;
                        cpNetwork.MaskLength = ciscoObject.MaskPrefix != null ? ciscoObject.MaskPrefix : "";
                        ApplyConversionIncidentOnCheckPointObject(cpNetwork, ciscoObject);
                        CheckObjectNameValidity(cpNetwork, ciscoObject);
                        AddCheckPointObject(cpNetwork);
                        break;

                    case Cisco_Object.ObjectTypes.Range:
                        var cpRange = new CheckPoint_Range();
                        cpRange.Name = ciscoObject.CiscoId;
                        cpRange.Name = cpRange.SafeName();
                        cpRange.Comments = ciscoObject.Description;
                        cpRange.RangeFrom = ciscoObject.RangeFrom;
                        cpRange.RangeTo = ciscoObject.RangeTo;
                        ApplyConversionIncidentOnCheckPointObject(cpRange, ciscoObject);
                        CheckObjectNameValidity(cpRange, ciscoObject);
                        AddCheckPointObject(cpRange);
                        break;

                    case Cisco_Object.ObjectTypes.TcpService:
                        var cpTcp = new CheckPoint_TcpService();
                        cpTcp.Name = ciscoObject.CiscoId;
                        cpTcp.Name = cpTcp.SafeName();
                        cpTcp.Comments = ciscoObject.Description;
                        cpTcp.Port = ciscoObject.ServicePort;
                        ApplyConversionIncidentOnCheckPointObject(cpTcp, ciscoObject);
                        CheckObjectNameValidity(cpTcp, ciscoObject);
                        AddCheckPointObject(cpTcp);
                        break;

                    case Cisco_Object.ObjectTypes.UdpService:
                        var cpUdp = new CheckPoint_UdpService();
                        cpUdp.Name = ciscoObject.CiscoId;
                        cpUdp.Name = cpUdp.SafeName();
                        cpUdp.Comments = ciscoObject.Description;
                        cpUdp.Port = ciscoObject.ServicePort;
                        ApplyConversionIncidentOnCheckPointObject(cpUdp, ciscoObject);
                        CheckObjectNameValidity(cpUdp, ciscoObject);
                        AddCheckPointObject(cpUdp);
                        break;

                    case Cisco_Object.ObjectTypes.KnownOtherService:
                        var cpOtherService = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects,
                                                                                              ProtocolType.KnownOtherIpProtocol,
                                                                                              TcpUdpPortOperatorType.NA,
                                                                                              ciscoObject.ServiceProtocol,
                                                                                              ServiceDirection.Destination,
                                                                                              ciscoObject.Id);
                        if (cpOtherService != null && cpOtherService.GetType() == typeof(CheckPoint_OtherService))
                        {
                            cpOtherService.Comments = ciscoObject.Description;
                            ApplyConversionIncidentOnCheckPointObject(cpOtherService, ciscoObject);
                            AddCheckPointObject(cpOtherService);
                        }
                        break;

                    case Cisco_Object.ObjectTypes.IcmpService:
                    case Cisco_Object.ObjectTypes.Icmp6Service:
                        // Predefined "icmp" object. No special handling...
                        break;
                }
            }
        }

        private void Add_NetworkGroups()
        {
            foreach (CiscoCommand command in CiscoObjectGroupCommands)
            {
                var ciscoGroup = (Cisco_GroupObject)command;

                var isHost = false;
                foreach (var child in ciscoGroup.Children)
                {
                    if (child.FirstWord.Contains("network-object"))
                    {
                        var ciscoNetwork = (Cisco_NetworkObject)child;

                        if (ciscoNetwork.Text.Contains("255.255.255.255"))
                        {
                            isHost = true;
                            var cpHost = new CheckPoint_Host();
                            cpHost.Name = ciscoGroup.CiscoId;
                            cpHost.Name = cpHost.SafeName();
                            cpHost.Comments = ciscoGroup.Description;
                            cpHost.IpAddress = ciscoNetwork.IpAddress;
                            ApplyConversionIncidentOnCheckPointObject(cpHost, ciscoGroup);
                            CheckObjectNameValidity(cpHost, ciscoGroup);
                            AddCheckPointObject(cpHost);
                        }
                    }
                }

                if (ciscoGroup.GroupType == Cisco_GroupObject.Group_Type.Network && !isHost)
                {
                    var cpNetworkGroup = new CheckPoint_NetworkGroup();
                    cpNetworkGroup.Name = ciscoGroup.CiscoId;
                    cpNetworkGroup.Name = cpNetworkGroup.SafeName();
                    cpNetworkGroup.Comments = ciscoGroup.Description;
                    ApplyConversionIncidentOnCheckPointObject(cpNetworkGroup, ciscoGroup);
                    CheckObjectNameValidity(cpNetworkGroup, ciscoGroup);

                    foreach (string groupName in ciscoGroup.MembersGroupNames)
                    {
                        cpNetworkGroup.Members.Add(groupName);
                    }

                    foreach (Cisco_NetworkObject ciscoMember in ciscoGroup.MemberObjects)
                    {
                        if (!string.IsNullOrEmpty(ciscoMember.ReferencedObject))
                        {
                            cpNetworkGroup.Members.Add(ciscoMember.ReferencedObject);
                        }
                        else
                        {
                            string memberName = (new CiscoNetwork(ciscoMember.Id, ciscoMember.IpAddress, ciscoMember.Netmask, ciscoMember.MaskPrefix)).AutoGeneratedName();
                            if (memberName.Contains(AutoGeneratedNameWithError))
                            {
                                ciscoMember.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                ciscoMember.ConversionIncidentMessage = "Unrecognized network details: " + ciscoMember.IpAddress + " " + ciscoMember.Netmask + ".";
                            }

                            ApplyConversionIncidentOnCheckPointObject(cpNetworkGroup, ciscoMember);
                            cpNetworkGroup.Members.Add(memberName);
                        }
                    }

                    AddCheckPointObject(cpNetworkGroup);
                }
            }
        }

        private void Add_InterfacesAndRoutes()
        {
            // This interface is for the TOP rule for the Non-NAT rules section!!!
            var allInternal = new CheckPoint_NetworkGroup();
            allInternal.Name = AllInternalNetwotkGroupName;

            int ciscoCommandIdWithIncident = 0;

            foreach (CiscoCommand command in CiscoInterfaceCommands)
            {
                var ciscoInterface = (Cisco_Interface)command;
                if (string.IsNullOrEmpty(ciscoInterface.CiscoId) || !ciscoInterface.HasValidIpAddress())
                {
                    // must be interface with a name and IP address!!!
                    continue;
                }

                if (!ciscoInterface.LeadsToInternet)
                {
                    var cpNetworkGroup = new CheckPoint_NetworkGroup();
                    cpNetworkGroup.Name = ciscoInterface.CiscoId + "_subnets";
                    cpNetworkGroup.Name = cpNetworkGroup.SafeName();

                    foreach (Cisco_Interface.Subnet subnet in ciscoInterface.Topology)
                    {


                        // Note, that a subnet can be a host in Cisco, but we want to always convert to network in CP!!!
                        string networkName = (new CiscoNetwork(ciscoInterface.Id, subnet.Network, subnet.Netmask)).AutoGeneratedNetworkName();
                        if (networkName.Contains(AutoGeneratedNameWithError))
                        {
                            ciscoInterface.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                            ciscoInterface.ConversionIncidentMessage = "Unrecognized topology details.";


                            ciscoCommandIdWithIncident = ciscoInterface.Id;
                        }
                        if (subnet.Netmask == "255.255.255.255")
                        {

                            //string errorDesc = ciscoCommand.Name() + " details: " + ciscoObject + ".";
                            string conversionIncidentMessage = "Unrecognized topology details: " + subnet.Network + " " + subnet.Netmask + ".";
                            _conversionIncidents.Add(new ConversionIncident(subnet.LineId,
                                                                            conversionIncidentMessage,
                                                                            "cannot create network objects",
                                                                            ConversionIncidentType.ManualActionRequired));
                            string networkErrorName = (new CiscoNetwork(subnet.LineId, subnet.Network, subnet.Netmask)).AutoGeneratedNetworkName();
                            foreach (CiscoCommand ciscoCommand in CiscoAllCommands)
                            {
                                if (ciscoCommand.Id == subnet.LineId)
                                {
                                    ciscoCommand.ConversionIncidentMessage = conversionIncidentMessage;
                                    ciscoCommand.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                }
                            }

                            var cpNetworkError = new CheckPoint_Network();
                            cpNetworkError.Name = networkErrorName;
                            cpNetworkError.Name = cpNetworkError.SafeName();
                            cpNetworkError.Subnet = subnet.Network;
                            cpNetworkError.Netmask = subnet.Netmask;
                            AddCheckPointObject(cpNetworkError);
                            //continue;
                        }
                        else
                        {

                            var cpNetwork = new CheckPoint_Network();
                            cpNetwork.Name = networkName;
                            cpNetwork.Name = cpNetwork.SafeName();
                            cpNetwork.Subnet = subnet.Network;
                            cpNetwork.Netmask = subnet.Netmask;
                            AddCheckPointObject(cpNetwork);

                            cpNetworkGroup.Members.Add(cpNetwork.Name);
                        }


                    }
                    ApplyConversionIncidentOnCheckPointObject(cpNetworkGroup, ciscoInterface);
                    AddCheckPointObject(cpNetworkGroup);

                    allInternal.Members.Add(cpNetworkGroup.Name);
                }

                // create host object for the interface's IP address
                var cpHost = new CheckPoint_Host();
                cpHost.Name = ciscoInterface.CiscoId + "_address";
                cpHost.IpAddress = ciscoInterface.IpAddress;
                ApplyConversionIncidentOnCheckPointObject(cpHost, ciscoInterface);
                AddCheckPointObject(cpHost);
            }

            if (ciscoCommandIdWithIncident > 0)
            {
                allInternal.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                allInternal.ConvertedCommandId = ciscoCommandIdWithIncident;
            }

            AddCheckPointObject(allInternal);
        }

        private void Add_Zones()
        {
            var aclNames = new List<string>();

            foreach (CiscoCommand command in CiscoAccessGroupCommands)
            {
                var ciscoAccessGroup = (Cisco_AccessGroup)command;
                if (ciscoAccessGroup.Direction == Cisco_AccessGroup.DirectionType.Inbound)
                {
                    if (aclNames.Contains(ciscoAccessGroup.AccessListName))
                    {
                        continue;
                    }
                    aclNames.Add(ciscoAccessGroup.AccessListName);

                    var cpZone = new CheckPoint_Zone();
                    cpZone.Name = CiscoCommand.InterfacePrefix + ciscoAccessGroup.InterfaceName;
                    cpZone.Name = cpZone.SafeName();
                    ApplyConversionIncidentOnCheckPointObject(cpZone, ciscoAccessGroup);
                    AddCheckPointObject(cpZone);
                }
            }

            foreach (CiscoCommand command in CiscoInterfaceCommands)
            {
                var ciscoInterface = (Cisco_Interface)command;
                if (!string.IsNullOrEmpty(ciscoInterface.CiscoId))   // must be interface with a name!!!
                {
                    var cpZone = new CheckPoint_Zone();
                    cpZone.Name = ciscoInterface.CiscoId;
                    cpZone.Name = cpZone.SafeName();
                    cpZone.Comments = "Zone without access-group";
                    ApplyConversionIncidentOnCheckPointObject(cpZone, ciscoInterface);
                    AddCheckPointObject(cpZone);
                }
            }
        }

        private void Add_or_Modify_InterfaceNetworkGroups()
        {
            var interfaceGroupObjects = new List<CheckPoint_NetworkGroup>();

            foreach (CiscoCommand command in CiscoInterfaceCommands)
            {
                var ciscoInterface = (Cisco_Interface)command;
                string interfaceGroupName = ciscoInterface.CiscoId + "_subnets";
                var cpObject = _cpObjects.GetObject(interfaceGroupName);
                if (cpObject != null)
                {
                    interfaceGroupObjects.Add((CheckPoint_NetworkGroup)cpObject);
                }
            }

            var modifiedNetworkGroups = Add_or_Modify_InterfaceNetworkGroups(interfaceGroupObjects);

            // Apply object name verification.
            foreach (var modifiedNetworkGroup in modifiedNetworkGroups)
            {
                if (_cpUnsafeNames.Contains(modifiedNetworkGroup))
                {
                    _cpUnsafeNames.Add(modifiedNetworkGroup + "_include");
                    _cpUnsafeNames.Add(modifiedNetworkGroup + "_exclude");
                }
            }
        }

        private void Add_ServicesAndServiceGroups()
        {
            foreach (CiscoCommand command in CiscoObjectGroupCommands)
            {
                var ciscoGroup = (Cisco_GroupObject)command;

                if (ciscoGroup.GroupType == Cisco_GroupObject.Group_Type.Service)
                {
                    var cpServiceGroup = new CheckPoint_ServiceGroup();
                    cpServiceGroup.Name = ciscoGroup.CiscoId;
                    cpServiceGroup.Name = cpServiceGroup.SafeName();
                    cpServiceGroup.Comments = ciscoGroup.Description;

                    foreach (string groupName in ciscoGroup.MembersGroupNames)
                    {
                        cpServiceGroup.Members.Add(groupName);
                    }

                    foreach (CiscoCommand ciscoMember in ciscoGroup.MemberObjects)
                    {
                        string cpName;

                        if (ciscoMember.Name() == "service-object")
                        {
                            var ciscoService = (Cisco_ServiceObject)ciscoMember;

                            // Check for the case where we are referencing a service object by its name
                            if (!string.IsNullOrEmpty(ciscoService.RefObjectName))
                            {
                                var ciscoReferencedService = _ciscoParser.GetCommandByCiscoId(ciscoService.RefObjectName);
                                if (ciscoReferencedService != null && _cpObjects.HasObject(ciscoReferencedService.CiscoId))
                                {
                                    cpServiceGroup.Members.Add(ciscoReferencedService.CiscoId);
                                }

                                continue;
                            }

                            switch (ciscoService.Protocol)
                            {
                                case "tcp":
                                    {
                                        cpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                   ciscoService.Protocol,
                                                                                                   ciscoService.Operator,
                                                                                                   ciscoService.Port,
                                                                                                   ServiceDirection.Destination,
                                                                                                   ciscoService.Id);
                                        if (cpName.Contains(AutoGeneratedNameWithError))
                                        {
                                            ciscoService.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                            ciscoService.ConversionIncidentMessage = "Unrecognized service details: " + ciscoService.Protocol + " " + ciscoService.Operator + " " + ciscoService.Port + ".";
                                        }

                                        var cpTcp = new CheckPoint_TcpService();
                                        cpTcp.Name = cpName;
                                        cpTcp.Port = ciscoService.Port;
                                        ApplyConversionIncidentOnCheckPointObject(cpTcp, ciscoService);
                                        AddCheckPointObject(cpTcp);

                                        cpServiceGroup.Members.Add(cpName);
                                    }
                                    break;

                                case "udp":
                                    {
                                        cpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                   ciscoService.Protocol,
                                                                                                   ciscoService.Operator,
                                                                                                   ciscoService.Port,
                                                                                                   ServiceDirection.Destination,
                                                                                                   ciscoService.Id);
                                        if (cpName.Contains(AutoGeneratedNameWithError))
                                        {
                                            ciscoService.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                            ciscoService.ConversionIncidentMessage = "Unrecognized service details: " + ciscoService.Protocol + " " + ciscoService.Operator + " " + ciscoService.Port + ".";
                                        }

                                        var cpUdp = new CheckPoint_UdpService();
                                        cpUdp.Name = cpName;
                                        cpUdp.Port = ciscoService.Port;
                                        ApplyConversionIncidentOnCheckPointObject(cpUdp, ciscoService);
                                        AddCheckPointObject(cpUdp);

                                        cpServiceGroup.Members.Add(cpName);
                                    }
                                    break;

                                case "tcp-udp":
                                    {
                                        cpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                   ProtocolType.Tcp,
                                                                                                   TcpUdpPortOperatorType.Eq,
                                                                                                   ciscoService.Port,
                                                                                                   ServiceDirection.Destination,
                                                                                                   ciscoService.Id);
                                        if (cpName.Contains(AutoGeneratedNameWithError))
                                        {
                                            ciscoService.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                            ciscoService.ConversionIncidentMessage = "Unrecognized service details: tcp eq " + ciscoService.Port + ".";
                                        }

                                        var cpTcp = new CheckPoint_TcpService();
                                        cpTcp.Name = cpName;
                                        cpTcp.Port = ciscoService.Port;
                                        ApplyConversionIncidentOnCheckPointObject(cpTcp, ciscoService);
                                        AddCheckPointObject(cpTcp);

                                        cpServiceGroup.Members.Add(cpName);

                                        cpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                   ProtocolType.Udp,
                                                                                                   TcpUdpPortOperatorType.Eq,
                                                                                                   ciscoService.Port,
                                                                                                   ServiceDirection.Destination,
                                                                                                   ciscoService.Id);
                                        if (cpName.Contains(AutoGeneratedNameWithError))
                                        {
                                            ciscoService.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                            ciscoService.ConversionIncidentMessage = "Unrecognized service details: udp eq " + ciscoService.Port + ".";
                                        }

                                        var cpUdp = new CheckPoint_UdpService();
                                        cpUdp.Name = cpName;
                                        cpUdp.Port = ciscoService.Port;
                                        ApplyConversionIncidentOnCheckPointObject(cpUdp, ciscoService);
                                        AddCheckPointObject(cpUdp);

                                        cpServiceGroup.Members.Add(cpName);
                                    }
                                    break;

                                case "icmp":
                                    cpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                               ProtocolType.Icmp,
                                                                                               TcpUdpPortOperatorType.Eq,
                                                                                               ciscoService.Port,
                                                                                               ServiceDirection.Destination,
                                                                                               ciscoService.Id);
                                    cpServiceGroup.Members.Add(cpName);

                                    if (cpName == "icmp-proto" && !string.IsNullOrEmpty(ciscoService.Port))
                                    {
                                        ciscoService.ConversionIncidentType = ConversionIncidentType.Informative;
                                        ciscoGroup.ConversionIncidentType = ConversionIncidentType.Informative;
                                        ciscoGroup.ConversionIncidentMessage = "Unrecognized ICMP service type: " + ciscoService.Port + ". Using generic icmp-proto service";
                                    }
                                    break;

                                case "icmp6":
                                    cpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                               ProtocolType.Icmp6,
                                                                                               TcpUdpPortOperatorType.Eq,
                                                                                               ciscoService.Port,
                                                                                               ServiceDirection.Destination,
                                                                                               ciscoService.Id);
                                    cpServiceGroup.Members.Add(cpName);

                                    if (cpName == "IPv6-ICMP" && !string.IsNullOrEmpty(ciscoService.Port))
                                    {
                                        ciscoService.ConversionIncidentType = ConversionIncidentType.Informative;
                                        ciscoGroup.ConversionIncidentType = ConversionIncidentType.Informative;
                                        ciscoGroup.ConversionIncidentMessage = "Unrecognized ICMP6 service type: " + ciscoService.Port + ". Using generic IPv6-ICMP service";
                                    }
                                    break;

                                case "ip":
                                    if (ciscoGroup.MemberObjects.Count > 1)
                                    {
                                        ciscoService.ConversionIncidentType = ConversionIncidentType.Informative;
                                        ciscoGroup.ConversionIncidentType = ConversionIncidentType.Informative;
                                        ciscoGroup.ConversionIncidentMessage = "Ignoring service group member: generic IP protocol service.";
                                    }
                                    break;

                                default:
                                    // No need to check also for CiscoKnownServices.IsKnownServiceNumber here,
                                    // because it is already done in Cisco_ServiceObject class!!!
                                    if (CiscoKnownServices.IsKnownService(ciscoService.Protocol))
                                    {
                                        var cpOtherService = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects,
                                                                                                              ProtocolType.KnownOtherIpProtocol,
                                                                                                              TcpUdpPortOperatorType.NA,
                                                                                                              ciscoService.Protocol,
                                                                                                              ServiceDirection.Destination,
                                                                                                              ciscoService.Id);
                                        if (cpOtherService != null && cpOtherService.GetType() == typeof(CheckPoint_OtherService))
                                        {
                                            ApplyConversionIncidentOnCheckPointObject(cpOtherService, ciscoService);
                                            AddCheckPointObject(cpOtherService);

                                            cpServiceGroup.Members.Add(cpOtherService.Name);
                                        }
                                    }
                                    else
                                    {
                                        ciscoService.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                        ciscoGroup.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                        ciscoGroup.ConversionIncidentMessage = "Error in member service: Unrecognized service protocol (" + ciscoService.Protocol + ")";
                                    }
                                    break;
                            }
                        }

                        if (ciscoMember.Name() == "port-object")
                        {
                            var ciscoPort = (Cisco_PortObject)ciscoMember;

                            switch (ciscoGroup.ServiceProtocol)
                            {
                                case "tcp":
                                    {
                                        cpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                   ProtocolType.Tcp,
                                                                                                   TcpUdpPortOperatorType.Eq,
                                                                                                   ciscoPort.Port,
                                                                                                   ServiceDirection.Destination,
                                                                                                   ciscoPort.Id);
                                        if (cpName.Contains(AutoGeneratedNameWithError))
                                        {
                                            ciscoPort.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                            ciscoPort.ConversionIncidentMessage = "Unrecognized service details: " + ciscoGroup.ServiceProtocol + " eq " + ciscoPort.Port + ".";
                                        }

                                        var cpTcp = new CheckPoint_TcpService();
                                        cpTcp.Name = cpName;
                                        cpTcp.Port = CiscoKnownServices.ConvertServiceToPort(ciscoPort.Port);
                                        ApplyConversionIncidentOnCheckPointObject(cpTcp, ciscoPort);
                                        AddCheckPointObject(cpTcp);

                                        cpServiceGroup.Members.Add(cpName);
                                    }
                                    break;

                                case "udp":
                                    {
                                        cpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                   ProtocolType.Udp,
                                                                                                   TcpUdpPortOperatorType.Eq,
                                                                                                   ciscoPort.Port,
                                                                                                   ServiceDirection.Destination,
                                                                                                   ciscoPort.Id);
                                        if (cpName.Contains(AutoGeneratedNameWithError))
                                        {
                                            ciscoPort.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                            ciscoPort.ConversionIncidentMessage = "Unrecognized service details: " + ciscoGroup.ServiceProtocol + " eq " + ciscoPort.Port + ".";
                                        }

                                        var cpUdp = new CheckPoint_UdpService();
                                        cpUdp.Name = cpName;
                                        cpUdp.Port = CiscoKnownServices.ConvertServiceToPort(ciscoPort.Port);
                                        ApplyConversionIncidentOnCheckPointObject(cpUdp, ciscoPort);
                                        AddCheckPointObject(cpUdp);

                                        cpServiceGroup.Members.Add(cpName);
                                    }
                                    break;

                                case "tcp-udp":
                                    {
                                        cpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                   ProtocolType.Tcp,
                                                                                                   TcpUdpPortOperatorType.Eq,
                                                                                                   ciscoPort.Port,
                                                                                                   ServiceDirection.Destination,
                                                                                                   ciscoPort.Id);
                                        if (cpName.Contains(AutoGeneratedNameWithError))
                                        {
                                            ciscoPort.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                            ciscoPort.ConversionIncidentMessage = "Unrecognized service details: tcp eq " + ciscoPort.Port + ".";
                                        }

                                        var cpTcp = new CheckPoint_TcpService();
                                        cpTcp.Name = cpName;
                                        cpTcp.Port = CiscoKnownServices.ConvertServiceToPort(ciscoPort.Port);
                                        ApplyConversionIncidentOnCheckPointObject(cpTcp, ciscoPort);
                                        AddCheckPointObject(cpTcp);

                                        cpServiceGroup.Members.Add(cpName);

                                        cpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                   ProtocolType.Udp,
                                                                                                   TcpUdpPortOperatorType.Eq,
                                                                                                   ciscoPort.Port,
                                                                                                   ServiceDirection.Destination,
                                                                                                   ciscoPort.Id);
                                        if (cpName.Contains(AutoGeneratedNameWithError))
                                        {
                                            ciscoPort.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                            ciscoPort.ConversionIncidentMessage = "Unrecognized service details: udp eq " + ciscoPort.Port + ".";
                                        }

                                        var cpUdp = new CheckPoint_UdpService();
                                        cpUdp.Name = cpName;
                                        cpUdp.Port = CiscoKnownServices.ConvertServiceToPort(ciscoPort.Port);
                                        ApplyConversionIncidentOnCheckPointObject(cpUdp, ciscoPort);
                                        AddCheckPointObject(cpUdp);

                                        cpServiceGroup.Members.Add(cpName);
                                    }
                                    break;
                            }
                        }
                    }

                    ApplyConversionIncidentOnCheckPointObject(cpServiceGroup, ciscoGroup);
                    CheckObjectNameValidity(cpServiceGroup, ciscoGroup);
                    AddCheckPointObject(cpServiceGroup);
                }
            }

            foreach (CiscoCommand command in CiscoAclCommands)
            {
                var ciscoAcl = (Cisco_AccessList)command;
                if (ciscoAcl.IsRemark)
                {
                    continue;
                }

                if (ciscoAcl.SourceProperties != null)
                {
                    CheckPointObject cpSourceService = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects,
                                                                                                        ciscoAcl.SourceProperties.Protocol,
                                                                                                        ciscoAcl.SourceProperties.TcpUdpPortOperator,
                                                                                                        ciscoAcl.SourceProperties.TcpUdpPortValue,
                                                                                                        ServiceDirection.Source,
                                                                                                        ciscoAcl.Id);
                    if (cpSourceService != null &&
                        (cpSourceService.GetType() == typeof(CheckPoint_TcpService) || cpSourceService.GetType() == typeof(CheckPoint_UdpService) || cpSourceService.GetType() == typeof(CheckPoint_OtherService)))
                    {
                        ApplyConversionIncidentOnCheckPointObject(cpSourceService, ciscoAcl);
                        AddCheckPointObject(cpSourceService);
                    }
                }

                if (ciscoAcl.DestinationProperties != null)
                {
                    CheckPointObject cpDestService = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects,
                                                                                                      ciscoAcl.DestinationProperties.Protocol,
                                                                                                      ciscoAcl.DestinationProperties.TcpUdpPortOperator,
                                                                                                      ciscoAcl.DestinationProperties.TcpUdpPortValue,
                                                                                                      ServiceDirection.Destination,
                                                                                                      ciscoAcl.Id);
                    if (cpDestService != null &&
                        (cpDestService.GetType() == typeof(CheckPoint_TcpService) || cpDestService.GetType() == typeof(CheckPoint_UdpService) || cpDestService.GetType() == typeof(CheckPoint_OtherService)))
                    {
                        ApplyConversionIncidentOnCheckPointObject(cpDestService, ciscoAcl);
                        AddCheckPointObject(cpDestService);
                    }
                }
            }
        }

        private void Add_TimeRanges()
        {
            IEnumerable<CiscoCommand> caTimesList = CisciTimeRangeCommands;

            const int cpTimeRangeNameLength = 11;

            List<string> cpTimeRangesNamesUniq = new List<string>();
            int cpTimeNamePostfixInt = 1;

            foreach (CiscoCommand command in caTimesList)
            {
                if (command.GetType() == typeof(Cisco_TimeRange))
                {
                    Cisco_TimeRange caTime = (Cisco_TimeRange)command;

                    string cpTimeRangeNameSrc = caTime.TimeRangeName;

                    if (caTime.PeriodicsList != null && caTime.PeriodicsList.Count > 1)
                    {
                        int postfixIndex = 1;
                        bool isRenamed = false;
                        foreach (string periodic in caTime.PeriodicsList)
                        {
                            string postfixString = "_" + postfixIndex++;
                            string cpTimeRangeName = cpTimeRangeNameSrc + postfixString;

                            while (cpTimeRangeName.Length > cpTimeRangeNameLength || cpTimeRangesNamesUniq.Contains(cpTimeRangeName))
                            {
                                string cpTimeNamePostfixStr = "_" + cpTimeNamePostfixInt;
                                cpTimeRangeName = cpTimeRangeNameSrc.Substring(0, cpTimeRangeNameLength - cpTimeNamePostfixStr.Length - postfixString.Length);
                                cpTimeRangeName = cpTimeRangeName + cpTimeNamePostfixStr + postfixString;
                                isRenamed = true;
                            }

                            Add_TimeRange(caTime.Id, caTime.TimeRangeName, cpTimeRangeName, caTime.StartDateTime, caTime.EndDateTime, periodic);
                            cpTimeRangesNamesUniq.Add(cpTimeRangeName);
                        }

                        if (isRenamed)
                            cpTimeNamePostfixInt += 1;
                    }
                    else
                    {
                        while (cpTimeRangeNameSrc.Length > cpTimeRangeNameLength || cpTimeRangesNamesUniq.Contains(cpTimeRangeNameSrc))
                        {
                            string cpTimeNamePostfixStr = "_" + cpTimeNamePostfixInt;
                            cpTimeRangeNameSrc = cpTimeRangeNameSrc.Substring(0, cpTimeRangeNameLength - cpTimeNamePostfixStr.Length);
                            cpTimeRangeNameSrc = cpTimeRangeNameSrc + cpTimeNamePostfixStr;
                            cpTimeNamePostfixInt += 1;
                        }

                        string periodic = null;
                        if (caTime.PeriodicsList.Count == 1)
                        {
                            periodic = caTime.PeriodicsList[0];
                        }
                        Add_TimeRange(caTime.Id, caTime.TimeRangeName, cpTimeRangeNameSrc, caTime.StartDateTime, caTime.EndDateTime, periodic);
                        cpTimeRangesNamesUniq.Add(cpTimeRangeNameSrc);
                    }
                }
            }
        }

        private void Add_TimeRange(int caTimeId, string caTimeRangeName, string cpTimeRangeName, string cpStartDateTime, string cpEndDateTime, string period = null)
        {
            if (!caTimeRangeName.Equals(cpTimeRangeName))
            {
                _conversionIncidents.Add(
                    new ConversionIncident(
                        caTimeId,
                        "TITLE: object is renamed",
                        "DESCRIPTION: object renamed from " + caTimeRangeName + " to " + cpTimeRangeName,
                        ConversionIncidentType.Informative));
            }

            CheckPoint_Time cpTime = new CheckPoint_Time();
            cpTime.Name = cpTimeRangeName;
            cpTime.Name = cpTime.SafeName();
            cpTime.Comments = "Old Time Object name: " + caTimeRangeName;
            cpTime.StartNow = true;
            cpTime.EndNever = true;

            if (cpStartDateTime != null) // check if Cisco has Start Time
            {
                cpTime.StartNow = false;

                DateTime date = DateTime.ParseExact(cpStartDateTime, "HH:mm dd MMMM yyyy", CultureInfo.InvariantCulture);
                cpTime.StartDate = date.ToString("dd-MMM-yyyy", CultureInfo.InvariantCulture).Trim();
                cpTime.StartTime = date.ToString("HH:mm").Trim();
            }

            if (cpEndDateTime != null)
            {
                cpTime.EndNever = false;

                DateTime date = DateTime.ParseExact(cpEndDateTime, "HH:mm dd MMMM yyyy", CultureInfo.InvariantCulture);
                cpTime.EndDate = date.ToString("dd-MMM-yyyy", CultureInfo.InvariantCulture).Trim();
                cpTime.EndTime = date.ToString("HH:mm").Trim();
            }


            if (period != null)
            {
                string[] times = null;

                if (period.StartsWith("daily"))
                {
                    times = period.Trim().Substring("daily".Length).Trim().Split(new string[] { "to" }, StringSplitOptions.RemoveEmptyEntries);

                    cpTime.RecurrencePattern = CheckPoint_Time.RecurrencePatternEnum.Daily;
                }
                else
                {
                    cpTime.RecurrencePattern = CheckPoint_Time.RecurrencePatternEnum.Weekly;

                    if (period.StartsWith("weekdays"))
                    {
                        cpTime.RecurrenceWeekdays.Add(CheckPoint_Time.Weekdays.Mon);
                        cpTime.RecurrenceWeekdays.Add(CheckPoint_Time.Weekdays.Tue);
                        cpTime.RecurrenceWeekdays.Add(CheckPoint_Time.Weekdays.Wed);
                        cpTime.RecurrenceWeekdays.Add(CheckPoint_Time.Weekdays.Thu);
                        cpTime.RecurrenceWeekdays.Add(CheckPoint_Time.Weekdays.Fri);

                        times = period.Trim().Substring("weekdays".Length).Trim().Split(new string[] { "to" }, StringSplitOptions.RemoveEmptyEntries);
                    }
                    else if (period.StartsWith("weekend"))
                    {
                        cpTime.RecurrenceWeekdays.Add(CheckPoint_Time.Weekdays.Sat);
                        cpTime.RecurrenceWeekdays.Add(CheckPoint_Time.Weekdays.Sun);

                        times = period.Trim().Substring("weekend".Length).Trim().Split(new string[] { "to" }, StringSplitOptions.RemoveEmptyEntries);
                    }
                    else
                    {
                        string[] daysTimes = period.Trim().Split(new string[] { "to" }, StringSplitOptions.RemoveEmptyEntries);

                        string[] daysTimes_1 = daysTimes[0].Split(new string[] { " " }, StringSplitOptions.RemoveEmptyEntries);
                        string[] daysTimes_2 = daysTimes[1].Split(new string[] { " " }, StringSplitOptions.RemoveEmptyEntries);

                        if (daysTimes_1.Length == 2 && daysTimes_2.Length == 2)
                        {
                            int startWdIndex = (int)WeekDayFromCiscoToCP(daysTimes_1[0]);
                            int endWdIndex = (int)WeekDayFromCiscoToCP(daysTimes_2[0]);

                            if (startWdIndex < endWdIndex)
                            {
                                for (int i = startWdIndex; i <= endWdIndex; i++)
                                {
                                    cpTime.RecurrenceWeekdays.Add((CheckPoint_Time.Weekdays)i);
                                }
                            }
                            else
                            {
                                int firstWdIndex = (int)Enum.GetValues(typeof(CheckPoint_Time.Weekdays)).Cast<CheckPoint_Time.Weekdays>().First();
                                int lastWdIndex = (int)Enum.GetValues(typeof(CheckPoint_Time.Weekdays)).Cast<CheckPoint_Time.Weekdays>().Last();

                                for (int i = firstWdIndex; i <= endWdIndex; i++)
                                {
                                    cpTime.RecurrenceWeekdays.Add((CheckPoint_Time.Weekdays)i);
                                }

                                for (int i = startWdIndex; i <= lastWdIndex; i++)
                                {
                                    cpTime.RecurrenceWeekdays.Add((CheckPoint_Time.Weekdays)i);
                                }
                            }

                            times = new string[] { daysTimes_1[daysTimes_1.Length - 1], daysTimes_2[daysTimes_2.Length - 1] };
                        }
                        else if (daysTimes_2.Length == 1)
                        {
                            for (int i = 0; i < daysTimes_1.Length - 1; i++)
                            {
                                cpTime.RecurrenceWeekdays.Add(WeekDayFromCiscoToCP(daysTimes_1[i]));
                            }

                            times = new string[] { daysTimes_1[daysTimes_1.Length - 1], daysTimes_2[0] };
                        }
                        else
                        {
                            throw new IOException("Invalid periodic pattern");
                        }
                    }
                }

                TimeSpan timeCheck0 = TimeSpan.ParseExact(times[0].Trim(), "h\\:mm", CultureInfo.InvariantCulture);
                TimeSpan timeCheck1 = TimeSpan.ParseExact(times[1].Trim(), "h\\:mm", CultureInfo.InvariantCulture);

                if (TimeSpan.Compare(timeCheck0, timeCheck1) == -1)
                {
                    cpTime.HoursRangesEnabled_1 = true;
                    cpTime.HoursRangesFrom_1 = times[0].Trim();
                    cpTime.HoursRangesTo_1 = times[1].Trim();
                }
                else
                {
                    cpTime.HoursRangesEnabled_1 = true;
                    cpTime.HoursRangesFrom_1 = times[0].Trim();
                    cpTime.HoursRangesTo_1 = "23:59".Trim();

                    cpTime.HoursRangesEnabled_2 = true;
                    cpTime.HoursRangesFrom_2 = "00:00".Trim();
                    cpTime.HoursRangesTo_2 = times[1].Trim();
                }
            }

            AddCheckPointObject(cpTime);

            List<string> cpTimeNamesList = null;
            _ciscoTimeNamesToCpTimeNamesDict.TryGetValue(caTimeRangeName, out cpTimeNamesList);
            if (cpTimeNamesList == null)
            {
                cpTimeNamesList = new List<string>();
            }
            cpTimeNamesList.Add(cpTime.Name);
            _ciscoTimeNamesToCpTimeNamesDict[caTimeRangeName] = cpTimeNamesList;
        }

        private CheckPoint_Time.Weekdays WeekDayFromCiscoToCP(string weekDayCisco)
        {
            CheckPoint_Time.Weekdays weekDayCP;
            switch (weekDayCisco)
            {
                case "Monday": weekDayCP = CheckPoint_Time.Weekdays.Mon; break;
                case "Tuesday": weekDayCP = CheckPoint_Time.Weekdays.Tue; break;
                case "Wednesday": weekDayCP = CheckPoint_Time.Weekdays.Wed; break;
                case "Thursday": weekDayCP = CheckPoint_Time.Weekdays.Thu; break;
                case "Friday": weekDayCP = CheckPoint_Time.Weekdays.Fri; break;
                case "Saturday": weekDayCP = CheckPoint_Time.Weekdays.Sat; break;
                default: weekDayCP = CheckPoint_Time.Weekdays.Sun; break;
            }

            return weekDayCP;
        }

        private CheckPoint_Package Add_Package(bool isPreExecution = false)
        {
            var cpPackage = new CheckPoint_Package();
            cpPackage.Name = _policyPackageName;

            // add parent layer
            Add_ParentLayer(cpPackage);

            // add sub-policies
            Add_Layers_And_Rules(cpPackage);

            // add sub-policies for zones without access-groups
            Add_Layers_And_Rules_For_Other_Zones(cpPackage);

            // add global rules to every sub-policy
            Add_Global_Rules(cpPackage);

            DetectCheckPointFirewallRulesAffectedByInspectPolicy(cpPackage);

            if (!isPreExecution)
                AddCheckPointObject(cpPackage);

            return cpPackage;
        }

        private void Add_ParentLayer(CheckPoint_Package package)
        {
            package.ParentLayer.Name = package.NameOfAccessLayer;

            // Add rules to parent layer due to Cisco SSH OS commands for firewall control and management.
            // These rules must be the topmost rules!!!
            if (CiscoSshCommands.Count > 0 && CiscoHostnameCommand != null)
            {
                // Create a destination simple gateway object
                string gwIpAddress = "1.1.1.1";

                var ciscoInterfaceObject = _ciscoParser.GetCommandByCiscoId(CiscoCommand.InterfacePrefix + "Management");
                if (ciscoInterfaceObject != null && ciscoInterfaceObject.GetType() == typeof(Cisco_Interface))
                {
                    var ciscoInterface = (Cisco_Interface)ciscoInterfaceObject;
                    if (ciscoInterface.HasValidIpAddress())
                    {
                        gwIpAddress = ciscoInterface.IpAddress;
                    }
                }

                var cpSimpleGw = new CheckPoint_SimpleGateway();
                cpSimpleGw.Name = CiscoHostnameCommand.HostName;
                cpSimpleGw.IpAddress = gwIpAddress;
                AddCheckPointObject(cpSimpleGw);

                // Create a collection of SSH hosts/networks as a source for the rules
                var sshHosts = new List<CheckPointObject>();
                foreach (CiscoCommand command in CiscoSshCommands)
                {
                    var ssh = (Cisco_SSH)command;
                    var sshHost = new CiscoNetwork(command.Id, ssh.IpAddress, ssh.Netmask);

                    if (sshHost.IsHost())
                    {
                        var cpHost = new CheckPoint_Host();
                        cpHost.Name = sshHost.AutoGeneratedName();
                        cpHost.IpAddress = sshHost.IpAddress;
                        cpHost.ConvertedCommandId = sshHost.CiscoCommandId;
                        AddCheckPointObject(cpHost);

                        sshHosts.Add(cpHost);
                    }
                    else if (sshHost.IsNetwork())
                    {
                        var cpNetwork = new CheckPoint_Network();
                        cpNetwork.Name = sshHost.AutoGeneratedName();
                        cpNetwork.Subnet = sshHost.IpAddress;
                        cpNetwork.Netmask = sshHost.NetMask;
                        cpNetwork.ConvertedCommandId = sshHost.CiscoCommandId;
                        AddCheckPointObject(cpNetwork);

                        sshHosts.Add(cpNetwork);
                    }
                }

                // First rule: SSH access to the Firewall
                var cpRule = new CheckPoint_Rule();
                cpRule.Name = "SSH access to the Firewall";
                cpRule.Source.AddRange(sshHosts);
                cpRule.Destination.Add(cpSimpleGw);
                cpRule.Service.Add(_cpObjects.GetObject("ssh_version_2"));
                cpRule.Action = CheckPoint_Rule.ActionType.Accept;
                cpRule.Layer = package.NameOfAccessLayer;
                cpRule.ConversionComments = "Firewall control and management";

                package.ParentLayer.Rules.Add(cpRule);

                // Second rule: SSH access to the WebUI
                cpRule = new CheckPoint_Rule();
                cpRule.Name = "Allow access to the WebUI";
                cpRule.Source.AddRange(sshHosts);
                cpRule.Destination.Add(cpSimpleGw);
                cpRule.Service.Add(_cpObjects.GetObject("https"));
                cpRule.Action = CheckPoint_Rule.ActionType.Accept;
                ////////////////////////////////////////////////////////////
                ///
                if (!cpRule.Track.Equals(TrackTypes.Log))
                {
                    NewCiscoAnalizStatistic._nonServicesLoggingServicesRulesCount++;
                }
                NewCiscoAnalizStatistic._disabledServicesRulesCount++;
                cpRule.Enabled = false;   // !!!
                /////////////////////////////////////////////////////////////
                cpRule.Layer = package.NameOfAccessLayer;
                cpRule.ConversionComments = "Firewall control and management";

                package.ParentLayer.Rules.Add(cpRule);

                // Third rule: Stealth Rule
                cpRule = new CheckPoint_Rule();
                cpRule.Name = "Stealth Rule";
                cpRule.Destination.Add(cpSimpleGw);
                cpRule.Action = CheckPoint_Rule.ActionType.Drop;
                cpRule.Layer = package.NameOfAccessLayer;
                cpRule.ConversionComments = "Firewall control and management";
                NewCiscoAnalizStatistic._stealthServicesRuleCount++;
                package.ParentLayer.Rules.Add(cpRule);
            }

            // Add parent rules for interfaces used in access-groups
            var accessGroups = new List<string>();
            var accessGroupsExclude = new List<string>();
            var aclNames = new List<string>();

            foreach (CiscoCommand command in CiscoAccessGroupCommands)
            {
                var ciscoAccessGroup = (Cisco_AccessGroup)command;
                if (ciscoAccessGroup.Direction == Cisco_AccessGroup.DirectionType.Inbound)
                {
                    if (aclNames.Contains(ciscoAccessGroup.AccessListName))
                    {
                        continue;
                    }
                    aclNames.Add(ciscoAccessGroup.AccessListName);

                    accessGroups.Add(CiscoCommand.InterfacePrefix + ciscoAccessGroup.InterfaceName);

                    // get Cisco interface object
                    var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(CiscoCommand.InterfacePrefix + ciscoAccessGroup.InterfaceName);
                    if (ciscoInterface == null || !ciscoInterface.HasValidIpAddress())
                    {
                        continue;
                    }

                    // This cpObject is supposed to be a CheckPoint_Zone object, unless there was an error...
                    var cpObject = GetCheckPointObjectOrCreateDummy(CiscoCommand.InterfacePrefix + ciscoAccessGroup.InterfaceName,
                                                                    CheckPointDummyObjectType.NetworkGroup,
                                                                    ciscoAccessGroup,
                                                                    "Error creating a parent layer rule, missing topology information for Cisco interface",
                                                                    "Interface details: " + ciscoAccessGroup.InterfaceName + ".");

                    var cpRule = new CheckPoint_Rule();
                    cpRule.Source.Add(cpObject);
                    if (cpObject.Name.Equals("Any"))
                    {
                        NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnySourceCount++;
                        NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                    }
                    if (!cpRule.Track.Equals(TrackTypes.Log))
                    {
                        NewCiscoAnalizStatistic._nonServicesLoggingServicesRulesCount++;
                    }
                    cpRule.Action = CheckPoint_Rule.ActionType.SubPolicy;
                    cpRule.SubPolicyName = ciscoAccessGroup.AccessListName;
                    cpRule.Layer = package.NameOfAccessLayer;
                    ApplyConversionIncidentOnCheckPointObject(cpRule, ciscoAccessGroup);

                    package.ParentLayer.Rules.Add(cpRule);
                }
                else
                {
                    // No Outbound nor Global...
                    accessGroupsExclude.Add(CiscoCommand.InterfacePrefix + ciscoAccessGroup.InterfaceName);
                }
            }

            // Add parent rules for interfaces without access-groups
            var availableZones = new List<CheckPoint_Zone>();
            int availableZonesWithZeroSecurityLevel = 0;

            foreach (CheckPoint_Zone cpZone in _cpZones)
            {
                if (accessGroups.Contains(cpZone.Name) || accessGroupsExclude.Contains(cpZone.Name))
                {
                    continue;
                }

                // get Cisco interface object
                var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(cpZone.Name);
                if (ciscoInterface == null || !ciscoInterface.HasValidIpAddress() || ciscoInterface.ManagementOnly)
                {
                    continue;
                }

                availableZones.Add(cpZone);

                // If the _isInterInterfaceTrafficAllowed flag is on and there are at least two Cisco interfaces with zero security level,
                // we should add parent rules for the equivalent CP zones to allow traffic between them.
                if (ciscoInterface.SecurityLevel == 0)
                {
                    ++availableZonesWithZeroSecurityLevel;
                }
            }

            foreach (CheckPoint_Zone cpZone in availableZones)
            {
                // get Cisco interface object
                var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(cpZone.Name);

                bool addParentRule = (_isIntraInterfaceTrafficAllowed || (_isInterInterfaceTrafficAllowed && availableZonesWithZeroSecurityLevel >= 2))
                                         ? (ciscoInterface.SecurityLevel >= 0)
                                         : (ciscoInterface.SecurityLevel > 0);

                if (addParentRule)
                {
                    var cpRule = new CheckPoint_Rule();

                    cpRule.Source.Add(cpZone);
                    if (cpZone.Name.Equals("Any"))
                    {
                        NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnySourceCount++;
                        NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                    }
                    if (!cpRule.Track.Equals(TrackTypes.Log))
                    {
                        NewCiscoAnalizStatistic._nonServicesLoggingServicesRulesCount++;
                    }
                    cpRule.Action = CheckPoint_Rule.ActionType.SubPolicy;
                    cpRule.SubPolicyName = cpZone.Name + "_sub_policy";
                    cpRule.Layer = package.NameOfAccessLayer;
                    cpRule.ConversionComments = "Cisco zone with security-level " + ciscoInterface.SecurityLevel;
                    ApplyConversionIncidentOnCheckPointObject(cpRule, ciscoInterface);

                    package.ParentLayer.Rules.Add(cpRule);
                }
            }

            // Add cleanup rule
            var cpCleanupRule = new CheckPoint_Rule();
            cpCleanupRule.Name = "Cleanup rule";
            cpCleanupRule.Action = CheckPoint_Rule.ActionType.Drop;
            cpCleanupRule.Layer = package.NameOfAccessLayer;

            package.ParentLayer.Rules.Add(cpCleanupRule);
        }

        private void Add_Layers_And_Rules(CheckPoint_Package package)
        {
            var aclNames = new List<string>();

            foreach (CiscoCommand command in CiscoAccessGroupCommands)
            {
                var ciscoAccessGroup = (Cisco_AccessGroup)command;

                if (aclNames.Contains(ciscoAccessGroup.AccessListName))
                {
                    continue;
                }

                if (ciscoAccessGroup.Direction != Cisco_AccessGroup.DirectionType.Inbound && ciscoAccessGroup.Direction != Cisco_AccessGroup.DirectionType.Global)
                {
                    ciscoAccessGroup.ConversionIncidentType = ConversionIncidentType.Informative;

                    _conversionIncidents.Add(new ConversionIncident(ciscoAccessGroup.Id,
                                                                    "Not converting outbound ACL groups",
                                                                    "All related ACLs are skipped.",
                                                                    ciscoAccessGroup.ConversionIncidentType));

                    continue;
                }

                aclNames.Add(ciscoAccessGroup.AccessListName);

                if (ciscoAccessGroup.Direction == Cisco_AccessGroup.DirectionType.Global)
                {
                    foreach (CiscoCommand aclCommand in CiscoAclCommands)
                    {
                        var ciscoAcl = (Cisco_AccessList)aclCommand;
                        if (!ciscoAcl.IsRemark && ciscoAcl.ACLName == ciscoAccessGroup.AccessListName)
                        {
                            _ciscoGlobalAclCommands.Add(ciscoAcl);
                        }
                    }
                }
                else   // Inbound
                {
                    // get Cisco interface object
                    var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(CiscoCommand.InterfacePrefix + ciscoAccessGroup.InterfaceName);
                    if (ciscoInterface == null)
                    {
                        ciscoAccessGroup.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                        _conversionIncidents.Add(new ConversionIncident(ciscoAccessGroup.Id,
                                                                        "Cannot find interface assigned to ACL group",
                                                                        "Interface details: " + ciscoAccessGroup.InterfaceName + ".",
                                                                        ciscoAccessGroup.ConversionIncidentType));

                        continue;
                    }
                    if (!ciscoInterface.HasValidIpAddress())
                    {
                        ciscoAccessGroup.ConversionIncidentType = ConversionIncidentType.Informative;

                        _conversionIncidents.Add(new ConversionIncident(ciscoAccessGroup.Id,
                                                                        "Not processing ACL groups that reference an interface without IP address",
                                                                        "All ACLs related to interface " + ciscoAccessGroup.InterfaceName + " are skipped.",
                                                                        ciscoAccessGroup.ConversionIncidentType));

                        continue;
                    }

                    var cpLayer = new CheckPoint_Layer();
                    cpLayer.Name = ciscoAccessGroup.AccessListName;
                    cpLayer.Comments = ciscoAccessGroup.Description;

                    if (ciscoInterface.Shutdown)
                    {
                        cpLayer.Tag = "InterfaceDisabled";
                    }

                    // Automatic rule is added for management-only interface:
                    if (ciscoInterface.ManagementOnly && CiscoHostnameCommand != null)
                    {
                        var cpRule = new CheckPoint_Rule();
                        cpRule.Enabled = true;
                        if (!cpRule.Track.Equals(TrackTypes.Log))
                        {
                            NewCiscoAnalizStatistic._nonServicesLoggingServicesRulesCount++;
                        }
                        cpRule.Layer = ciscoAccessGroup.AccessListName;
                        cpRule.Source.Add(_cpObjects.GetObject(CheckPointObject.Any));
                        NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnySourceCount++;
                        NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                        cpRule.Destination.Add(_cpObjects.GetObject(CiscoHostnameCommand.HostName));
                        cpRule.DestinationNegated = true;
                        cpRule.Service.Add(_cpObjects.GetObject(CheckPointObject.Any));
                        NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyServiceCount++;

                        cpRule.Action = CheckPoint_Rule.ActionType.Drop;
                        cpRule.ConversionComments = "Automatic rule for management-only interface";

                        cpLayer.Rules.Add(cpRule);
                    }

                    foreach (CiscoCommand aclCommand in CiscoAclCommands)
                    {
                        var ciscoAcl = (Cisco_AccessList)aclCommand;
                        if (!ciscoAcl.IsRemark && ciscoAcl.ACLName == ciscoAccessGroup.AccessListName)
                        {
                            var cpRule = Acl_To_CPRule(ciscoAcl, null);

                            if (ciscoInterface.Shutdown)
                            {
                                NewCiscoAnalizStatistic._disabledServicesRulesCount++;
                                cpRule.Enabled = false;
                            }
                            if (!cpRule.Track.Equals(TrackTypes.Log))
                            {
                                NewCiscoAnalizStatistic._nonServicesLoggingServicesRulesCount++;
                            }

                            cpLayer.Rules.Add(cpRule);

                            if (cpRule.ConversionIncidentType != ConversionIncidentType.None || ciscoAcl.ConversionIncidentType != ConversionIncidentType.None)
                            {
                                package.ConversionIncidentType = ConversionIncidentType.Informative;
                            }
                        }
                    }

                    // Do NOT create a cleanup rule if it already exists
                    bool createCleanupRule = true;
                    if (cpLayer.Rules.Count > 0)
                    {
                        var lastRule = cpLayer.Rules[cpLayer.Rules.Count - 1];
                        createCleanupRule = !lastRule.IsCleanupRule();
                    }

                    if (createCleanupRule)
                    {
                        var cpCleanupRule = new CheckPoint_Rule();
                        cpCleanupRule.Name = CheckPoint_Rule.SubPolicyCleanupRuleName;
                        cpCleanupRule.Action = CheckPoint_Rule.ActionType.Drop;
                        cpCleanupRule.Layer = cpLayer.Name;

                        cpLayer.Rules.Add(cpCleanupRule);
                    }

                    package.SubPolicies.Add(cpLayer);
                    validatePackage(package);
                }
            }
        }

        private void Add_Global_Rules(CheckPoint_Package package)
        {
            if (_ciscoGlobalAclCommands.Count > 0)
            {
                // remove clenup rule of each sublayer if global rules exist because cleanup rule should be added after global-rules
                foreach (var subpolicy in package.SubPolicies)
                {
                    if (subpolicy.Rules.Count > 0)
                    {
                        var lastRule = subpolicy.Rules[subpolicy.Rules.Count - 1];
                        if (lastRule.IsCleanupRule())
                        {
                            subpolicy.Rules.Remove(lastRule);
                        }
                    }
                }

                //remove cleanup rule of parent layer because it will be added after global rules
                if (package.ParentLayer.Rules.Count > 0)
                {
                    var lastRule = package.ParentLayer.Rules[package.ParentLayer.Rules.Count - 1];
                    if (lastRule.IsCleanupRule())
                    {
                        package.ParentLayer.Rules.Remove(lastRule);
                    }
                }

                CheckPoint_Rule cpRule4GlobalLayer = new CheckPoint_Rule();
                cpRule4GlobalLayer.Name = "";
                cpRule4GlobalLayer.Layer = package.NameOfAccessLayer;
                cpRule4GlobalLayer.Source.Add(_cpObjects.GetObject(CheckPointObject.Any));
                cpRule4GlobalLayer.Destination.Add(_cpObjects.GetObject(CheckPointObject.Any));
                cpRule4GlobalLayer.Action = CheckPoint_Rule.ActionType.SubPolicy;
                cpRule4GlobalLayer.Track = CheckPoint_Rule.TrackTypes.None;
                cpRule4GlobalLayer.Time.Add(_cpObjects.GetObject(CheckPointObject.Any));
                cpRule4GlobalLayer.Service.Add(_cpObjects.GetObject(CheckPointObject.Any));

                NewCiscoAnalizStatistic._timesServicesRulesCount++;
                NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyDestinationCount++;
                NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyServiceCount++;
                NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnySourceCount++;
                NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;

                cpRule4GlobalLayer.SubPolicyName = GlobalRulesSubpolicyName;

                package.ParentLayer.Rules.Add(cpRule4GlobalLayer);

                CheckPoint_Layer cpSubLayer4GlobalRules = new CheckPoint_Layer();
                cpSubLayer4GlobalRules.ApplicationsAndUrlFiltering = true;
                cpSubLayer4GlobalRules.Shared = true;
                cpSubLayer4GlobalRules.Name = cpRule4GlobalLayer.SubPolicyName;

                package.SubPolicies.Insert(0, cpSubLayer4GlobalRules); // insert at the begging becuase Global Rules should be created before all policy

                foreach (var globalPolicyRule in _ciscoGlobalAclCommands)
                {
                    // Append the global policy rules BELOW the existing sub-policies.
                    CheckPoint_Rule cpRule = Acl_To_CPRule(globalPolicyRule, cpSubLayer4GlobalRules.Name);
                    cpSubLayer4GlobalRules.Rules.Add(cpRule);
                }

                //add cleanup rule after all global rules

                // Do NOT create a cleanup rule if it already exists
                bool createCleanupRule = true;
                if (cpSubLayer4GlobalRules.Rules.Count > 0)
                {
                    var lastRule = cpSubLayer4GlobalRules.Rules[cpSubLayer4GlobalRules.Rules.Count - 1];
                    createCleanupRule = !lastRule.IsCleanupRule();
                }

                if (createCleanupRule)
                {
                    var cpCleanupRule = new CheckPoint_Rule();
                    cpCleanupRule.Name = CheckPoint_Rule.SubPolicyCleanupRuleName;
                    cpCleanupRule.Action = CheckPoint_Rule.ActionType.Drop;
                    cpCleanupRule.Layer = cpSubLayer4GlobalRules.Name;
                    cpSubLayer4GlobalRules.Rules.Add(cpCleanupRule);
                    NewCiscoAnalizStatistic._cleanupServicesRuleCount++;
                }

                // Fill in the shared layer with global policy rules INSIDE the existing sub-policies.
                foreach (CheckPoint_Layer subPolicy in package.SubPolicies)
                {
                    if (subPolicy.Name.Equals(cpSubLayer4GlobalRules.Name))
                    {
                        continue;
                    }

                    CheckPoint_Rule cpSubRule4GlobalLayer = cpRule4GlobalLayer.Clone();

                    NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyDestinationCount++;
                    NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyServiceCount++;
                    NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnySourceCount++;
                    NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                    if (cpSubRule4GlobalLayer.Time.Count > 0 && cpSubRule4GlobalLayer.Time.First().Name.Equals("Any"))
                    {
                        NewCiscoAnalizStatistic._timesServicesRulesCount++;
                    }
                    cpSubRule4GlobalLayer.Name = "Global Layer";
                    cpSubRule4GlobalLayer.Layer = subPolicy.Name;
                    subPolicy.Rules.Add(cpSubRule4GlobalLayer);
                }


                //the last rule which is created by default by CheckPoint script importer. It is for report only.
                var cpRuleCleanUp = new CheckPoint_Rule();
                cpRuleCleanUp.Name = "Cleanup rule";
                package.ParentLayer.Rules.Add(cpRuleCleanUp);
                NewCiscoAnalizStatistic._cleanupServicesRuleCount++;
            }
            else
            {
                foreach (Cisco_AccessList ciscoAcl in _ciscoGlobalAclCommands)
                {
                    // Fill in the global policy rules INSIDE the existing sub-policies.
                    foreach (CheckPoint_Rule cpParentRule in package.ParentLayer.Rules)
                    {
                        if (cpParentRule.Action == CheckPoint_Rule.ActionType.SubPolicy)
                        {
                            // Get into the relevant sub-policy
                            foreach (CheckPoint_Layer subPolicy in package.SubPolicies)
                            {
                                if (subPolicy.Name == cpParentRule.SubPolicyName)
                                {
                                    // This is done to avoid duplication of incident reporting over all matched sub-policy rules.
                                    ConversionIncidentType aclConversionIncident = ciscoAcl.ConversionIncidentType;
                                    ciscoAcl.ConversionIncidentType = ConversionIncidentType.None;

                                    var cpRule = Acl_To_CPRule(ciscoAcl, subPolicy.Name);

                                    cpRule.Layer = subPolicy.Name;

                                    if (!string.IsNullOrEmpty(subPolicy.Tag) && subPolicy.Tag == "InterfaceDisabled")
                                    {
                                        NewCiscoAnalizStatistic._disabledServicesRulesCount++;
                                        cpRule.Enabled = false;
                                    }

                                    if (!cpRule.Track.Equals(TrackTypes.Log))
                                    {
                                        NewCiscoAnalizStatistic._nonServicesLoggingServicesRulesCount++;
                                    }

                                    // If the global ACL didn't have an incident previously,
                                    // and the incident was just encountered during this convertion, retain the incident!!!
                                    if (ciscoAcl.ConversionIncidentType == ConversionIncidentType.None)
                                    {
                                        ciscoAcl.ConversionIncidentType = aclConversionIncident;
                                    }

                                    // Insert the global rules at the end of each sub-policy, BEFORE the cleanup rule.
                                    int rulesCount = subPolicy.Rules.Count;
                                    subPolicy.Rules.Insert(rulesCount - 1, cpRule);

                                    if (cpRule.ConversionIncidentType != ConversionIncidentType.None || ciscoAcl.ConversionIncidentType != ConversionIncidentType.None)
                                    {
                                        package.ConversionIncidentType = ConversionIncidentType.Informative;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        private CheckPoint_Rule Acl_To_CPRule(Cisco_AccessList ciscoAcl, string layerName)
        {
            var cpRule = new CheckPoint_Rule();
            cpRule.Name = ciscoAcl.Description;
            cpRule.Enabled = !ciscoAcl.Inactive;
            if (!cpRule.Enabled)
            {
                NewCiscoAnalizStatistic._disabledServicesRulesCount++;
            }

            if (!cpRule.Track.Equals(TrackTypes.Log))
            {
                NewCiscoAnalizStatistic._nonServicesLoggingServicesRulesCount++;
            }
            if (layerName != null)
                cpRule.Layer = layerName;
            else
                cpRule.Layer = ciscoAcl.ACLName;

            cpRule.Comments = ciscoAcl.Remark;
            cpRule.ConversionComments = ciscoAcl.Id + ") " + ciscoAcl.Text;

            ApplyConversionIncidentOnCheckPointObject(cpRule, ciscoAcl);

            CheckPointObject cpObject;
            string srcObjectName;
            string destObjectName;

            if (ciscoAcl.IsTimeRangeSpecified)
            {
                List<string> cpTimeNamesList = null;
                _ciscoTimeNamesToCpTimeNamesDict.TryGetValue(ciscoAcl.TimeRangeName, out cpTimeNamesList);
                if (cpTimeNamesList != null)
                {
                    bool calc = true;
                    foreach (string cpTimeName in cpTimeNamesList)
                    {
                        cpObject = GetCheckPointObjectOrCreateDummy(cpTimeName,
                                                                CheckPointDummyObjectType.TimeGroup,
                                                                ciscoAcl,
                                                                "Not applying time-range objects to ACLs",
                                                                "Appropriate time object should be added manually.");
                        cpRule.Time.Add(cpObject);
                        if (!cpObject.Name.Equals("Any") && calc)
                        {
                            NewCiscoAnalizStatistic._timesServicesRulesCount++;
                            calc = false;
                        }
                    }
                }
                else
                {
                    cpObject = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                                CheckPointDummyObjectType.TimeGroup,
                                                                ciscoAcl,
                                                                "Not applying time-range objects to ACLs",
                                                                "Appropriate time object should be added manually.");
                    cpRule.Time.Add(cpObject);
                    if (!cpObject.Name.Equals("Any"))
                    {
                        NewCiscoAnalizStatistic._timesServicesRulesCount++;
                    }
                }
            }
            bool any_fl = true;
            switch (ciscoAcl.Source.Type)
            {
                case Cisco_AccessList.SourceDest.SourceDestType.Any:
                    cpRule.Source.Add(_cpObjects.GetObject(CheckPointObject.Any));
                    NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnySourceCount++;
                    if (any_fl)
                    {
                        NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                        any_fl = false;
                    }
                    break;

                case Cisco_AccessList.SourceDest.SourceDestType.Any6:
                    cpObject = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                                CheckPointDummyObjectType.NetworkGroup,
                                                                ciscoAcl,
                                                                "Error creating a rule, IPv6 objects are not supported",
                                                                "Source details: Any6.");
                    cpRule.Source.Add(cpObject);
                    if (cpObject.Name.Equals("Any"))
                    {
                        NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnySourceCount++;
                        if (any_fl)
                        {
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                            any_fl = false;
                        }
                    }
                    break;

                case Cisco_AccessList.SourceDest.SourceDestType.Host:
                    srcObjectName = (new CiscoNetwork(ciscoAcl.Id, ciscoAcl.Source.HostIp)).AutoGeneratedName();
                    cpObject = GetCheckPointObjectOrCreateDummy(srcObjectName,
                                                                CheckPointDummyObjectType.NetworkGroup,
                                                                ciscoAcl,
                                                                "Error creating a rule, missing information for source Cisco host",
                                                                "Host details: " + ciscoAcl.Source.HostIp + ".");
                    cpRule.Source.Add(cpObject);
                    if (cpObject.Name.Equals("Any"))
                    {
                        NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnySourceCount++;
                        if (any_fl)
                        {
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                            any_fl = false;
                        }
                    }
                    break;

                case Cisco_AccessList.SourceDest.SourceDestType.SubnetAndMask:
                    srcObjectName = (new CiscoNetwork(ciscoAcl.Id, ciscoAcl.Source.Subnet, ciscoAcl.Source.Netmask)).AutoGeneratedName();
                    cpObject = GetCheckPointObjectOrCreateDummy(srcObjectName,
                                                                CheckPointDummyObjectType.NetworkGroup,
                                                                ciscoAcl,
                                                                "Error creating a rule, missing information for source Cisco network",
                                                                "Network details: " + ciscoAcl.Source.Subnet + " " + ciscoAcl.Source.Netmask + ".");
                    cpRule.Source.Add(cpObject);
                    if (cpObject.Name.Equals("Any"))
                    {
                        NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnySourceCount++;
                        if (any_fl)
                        {
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                            any_fl = false;
                        }
                    }
                    break;

                case Cisco_AccessList.SourceDest.SourceDestType.ReferenceObject:
                    srcObjectName = ciscoAcl.Source.RefObjectName;
                    cpObject = GetCheckPointObjectOrCreateDummy(srcObjectName,
                                                                CheckPointDummyObjectType.NetworkGroup,
                                                                ciscoAcl,
                                                                "Error creating a rule, missing information for source Cisco object",
                                                                "Object details: " + srcObjectName + ".");
                    cpRule.Source.Add(cpObject);
                    if (cpObject.Name.Equals("Any"))
                    {
                        NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnySourceCount++;
                        if (any_fl)
                        {
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                            any_fl = false;
                        }
                    }
                    break;
            }

            switch (ciscoAcl.Destination.Type)
            {
                case Cisco_AccessList.SourceDest.SourceDestType.Any:
                    cpRule.Destination.Add(_cpObjects.GetObject(CheckPointObject.Any));
                    NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyDestinationCount++;
                    if (any_fl)
                    {
                        NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                        any_fl = false;
                    }
                    break;

                case Cisco_AccessList.SourceDest.SourceDestType.Any6:
                    cpObject = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                                CheckPointDummyObjectType.NetworkGroup,
                                                                ciscoAcl,
                                                                "Error creating a rule, IPv6 objects are not supported",
                                                                "Destination details: Any6.");
                    cpRule.Destination.Add(cpObject);
                    if (cpObject.Name.Equals("Any"))
                    {
                        NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyDestinationCount++;
                        if (any_fl)
                        {
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                            any_fl = false;
                        }
                    }
                    break;

                case Cisco_AccessList.SourceDest.SourceDestType.Host:
                    destObjectName = (new CiscoNetwork(ciscoAcl.Id, ciscoAcl.Destination.HostIp)).AutoGeneratedName();
                    cpObject = GetCheckPointObjectOrCreateDummy(destObjectName,
                                                                CheckPointDummyObjectType.NetworkGroup,
                                                                ciscoAcl,
                                                                "Error creating a rule, missing information for destination Cisco host",
                                                                "Host details: " + ciscoAcl.Destination.HostIp + ".");
                    cpRule.Destination.Add(cpObject);
                    if (cpObject.Name.Equals("Any"))
                    {
                        NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyDestinationCount++;
                        if (any_fl)
                        {
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                            any_fl = false;
                        }
                    }
                    break;

                case Cisco_AccessList.SourceDest.SourceDestType.SubnetAndMask:
                    destObjectName = (new CiscoNetwork(ciscoAcl.Id, ciscoAcl.Destination.Subnet, ciscoAcl.Destination.Netmask)).AutoGeneratedName();
                    cpObject = GetCheckPointObjectOrCreateDummy(destObjectName,
                                                                CheckPointDummyObjectType.NetworkGroup,
                                                                ciscoAcl,
                                                                "Error creating a rule, missing information for destination Cisco network",
                                                                "Network details: " + ciscoAcl.Destination.Subnet + " " + ciscoAcl.Destination.Netmask + ".");
                    cpRule.Destination.Add(cpObject);
                    if (cpObject.Name.Equals("Any"))
                    {
                        NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyDestinationCount++;
                        if (any_fl)
                        {
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                            any_fl = false;
                        }
                    }
                    break;

                case Cisco_AccessList.SourceDest.SourceDestType.ReferenceObject:
                    destObjectName = ciscoAcl.Destination.RefObjectName;
                    cpObject = GetCheckPointObjectOrCreateDummy(destObjectName,
                                                                CheckPointDummyObjectType.NetworkGroup,
                                                                ciscoAcl,
                                                                "Error creating a rule, missing information for destination Cisco object",
                                                                "Object details: " + destObjectName + ".");
                    cpRule.Destination.Add(cpObject);
                    if (cpObject.Name.Equals("Any"))
                    {
                        NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyDestinationCount++;
                        if (any_fl)
                        {
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                            any_fl = false;
                        }
                    }
                    break;
            }

            switch (ciscoAcl.Action)
            {
                case Cisco_AccessList.ActionType.Permit:
                    cpRule.Action = CheckPoint_Rule.ActionType.Accept;
                    break;

                case Cisco_AccessList.ActionType.Deny:
                    cpRule.Action = CheckPoint_Rule.ActionType.Drop;
                    break;
            }

            if (ciscoAcl.Protocol == ProtocolType.NA)
            {
                cpObject = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                            CheckPointDummyObjectType.ServiceGroup,
                                                            ciscoAcl,
                                                            "Error creating a rule, unrecognized Cisco ACL protocol",
                                                            "Protocol details: " + ciscoAcl.ProtocolReference + ".");
                cpRule.Service.Add(cpObject);
                if (cpObject.Name.Equals("Any"))
                {
                    NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyServiceCount++;
                    if (any_fl)
                    {
                        NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                        any_fl = false;
                    }
                }
                return cpRule;
            }

            if (ciscoAcl.Protocol != ProtocolType.ReferenceObject)   // a specific ACL protocol is used
            {
                // Destination service should be checked first
                if (ciscoAcl.DestinationProperties.Protocol != ProtocolType.NA && (ciscoAcl.DestinationProperties.WordsCount > 0 || ciscoAcl.DestinationProperties.TcpUdpPortOperator == TcpUdpPortOperatorType.All))
                {
                    if (ciscoAcl.DestinationProperties.TcpUdpPortOperator != TcpUdpPortOperatorType.ReferenceObject)   // specific protocol with a specific port
                    {
                        string serviceName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                               ciscoAcl.DestinationProperties.Protocol,
                                                                                               ciscoAcl.DestinationProperties.TcpUdpPortOperator,
                                                                                               ciscoAcl.DestinationProperties.TcpUdpPortValue,
                                                                                               ServiceDirection.Destination,
                                                                                               ciscoAcl.Id);
                        var dummyObjectType = (ciscoAcl.DestinationProperties.Protocol == ProtocolType.KnownOtherIpProtocol) ? CheckPointDummyObjectType.OtherService : CheckPointDummyObjectType.ServiceGroup;

                        cpObject = GetCheckPointObjectOrCreateDummy(serviceName,
                                                                    dummyObjectType,
                                                                    ciscoAcl,
                                                                    "Error creating a rule, missing information for Cisco destination service",
                                                                    "Service details: " + ciscoAcl.DestinationProperties.Protocol + " " + ciscoAcl.DestinationProperties.TcpUdpPortOperator + " " + ciscoAcl.DestinationProperties.TcpUdpPortValue + ".");
                        cpRule.Service.Add(cpObject);
                        if (cpObject.Name.Equals("Any"))
                        {
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyServiceCount++;
                            if (any_fl)
                            {
                                NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                                any_fl = false;
                            }
                        }
                    }
                    else   // specific protocol with a service group of ports or icmp protocol with service group of icmp types
                    {
                        CiscoCommand ciscoPortReferenceCommand = _ciscoParser.GetCommandByCiscoId(ciscoAcl.DestinationProperties.TcpUdpPortValue);

                        if (ciscoPortReferenceCommand != null && ciscoPortReferenceCommand.Name() == "object-group")
                        {
                            var ciscoGroupReferenceObject = (Cisco_GroupObject)ciscoPortReferenceCommand;

                            if (ciscoGroupReferenceObject.GroupType == Cisco_GroupObject.Group_Type.Service)
                            {
                                Add_AclPorts_To_CPRule(ciscoAcl, ciscoGroupReferenceObject.ServiceProtocol, ciscoGroupReferenceObject, cpRule);
                            }
                            else if (ciscoGroupReferenceObject.GroupType == Cisco_GroupObject.Group_Type.Icmp || ciscoGroupReferenceObject.GroupType == Cisco_GroupObject.Group_Type.Icmp6)
                            {
                                Add_AclIcmpTypes_To_CPRule(ciscoAcl, ciscoGroupReferenceObject, cpRule);
                            }
                        }
                    }
                }

                // Now check the source service
                if (ciscoAcl.SourceProperties.Protocol != ProtocolType.NA && ciscoAcl.SourceProperties.WordsCount > 0)
                {
                    string serviceName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                           ciscoAcl.SourceProperties.Protocol,
                                                                                           ciscoAcl.SourceProperties.TcpUdpPortOperator,
                                                                                           ciscoAcl.SourceProperties.TcpUdpPortValue,
                                                                                           ServiceDirection.Source,
                                                                                           ciscoAcl.Id);

                    // Do we already have the destination services applied?
                    if (cpRule.Service.Count > 0)
                    {
                        cpRule.ConversionIncidentType = ConversionIncidentType.Informative;
                        ciscoAcl.ConversionIncidentType = ConversionIncidentType.Informative;

                        _conversionIncidents.Add(new ConversionIncident(ciscoAcl.Id,
                                                                        "Cannot convert ACL with both source service and destination service",
                                                                        "Ignoring source service: " + serviceName,
                                                                        ciscoAcl.ConversionIncidentType));
                    }
                    else   // no "regular" services - only source service
                    {
                        string errDescription;
                        if (ciscoAcl.SourceProperties.TcpUdpPortOperator == TcpUdpPortOperatorType.ReferenceObject)
                        {
                            errDescription = "Object details: " + ciscoAcl.SourceProperties.TcpUdpPortValue + ".";
                        }
                        else
                        {
                            errDescription = "Service details: " + ciscoAcl.SourceProperties.Protocol + " " + ciscoAcl.SourceProperties.TcpUdpPortOperator + " " + ciscoAcl.SourceProperties.TcpUdpPortValue + ".";
                        }

                        cpObject = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                                    CheckPointDummyObjectType.ServiceGroup,
                                                                    ciscoAcl,
                                                                    "Cannot convert ACL with only source service",
                                                                    errDescription);
                        cpRule.Service.Add(cpObject);
                        if (cpObject.Name.Equals("Any"))
                        {
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyServiceCount++;
                            if (any_fl)
                            {
                                NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                                any_fl = false;
                            }
                        }
                    }
                }
            }
            else   // ProtocolType.ReferenceObject - ACL protocol is a referenced "object-group" or "object"
            {
                CiscoCommand ciscoProtocolReferenceCommand = _ciscoParser.GetCommandByCiscoId(ciscoAcl.ProtocolReference);

                if (ciscoProtocolReferenceCommand != null && ciscoProtocolReferenceCommand.Name() == "object-group")   // services group or protocols group
                {
                    var ciscoGroupReferenceObject = (Cisco_GroupObject)ciscoProtocolReferenceCommand;

                    if (ciscoGroupReferenceObject.GroupType == Cisco_GroupObject.Group_Type.Service)
                    {
                        Add_AclServices_To_CPRule(ciscoAcl, ciscoGroupReferenceObject, cpRule);
                    }
                    else if (ciscoGroupReferenceObject.GroupType == Cisco_GroupObject.Group_Type.Protocol)
                    {
                        Add_AclProtocols_To_CPRule(ciscoAcl, ciscoGroupReferenceObject, cpRule);
                    }
                }
                else if (ciscoProtocolReferenceCommand != null && ciscoProtocolReferenceCommand.Name() == "object")   // service object
                {
                    var ciscoReferenceObject = (Cisco_Object)ciscoProtocolReferenceCommand;

                    if (ciscoReferenceObject.ObjectType == Cisco_Object.ObjectTypes.IcmpService)   // using a predefined icmp object
                    {
                        string icmpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                            ProtocolType.Icmp,
                                                                                            TcpUdpPortOperatorType.Eq,
                                                                                            ciscoReferenceObject.ServicePort,
                                                                                            ServiceDirection.Destination,
                                                                                            ciscoAcl.Id);
                        cpObject = GetCheckPointObjectOrCreateDummy(icmpName,
                                                                    CheckPointDummyObjectType.ServiceGroup,
                                                                    ciscoAcl,
                                                                    "Error creating a rule, missing information for Cisco destination service",
                                                                    "Service details: icmp " + ciscoReferenceObject.ServicePort + ".");
                        cpRule.Service.Add(cpObject);
                        if (cpObject.Name.Equals("Any"))
                        {
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyServiceCount++;
                            if (any_fl)
                            {
                                NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                                any_fl = false;
                            }
                        }
                    }
                    else if (ciscoReferenceObject.ObjectType == Cisco_Object.ObjectTypes.Icmp6Service)   // using a predefined icmp6 object
                    {
                        string icmpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                            ProtocolType.Icmp6,
                                                                                            TcpUdpPortOperatorType.Eq,
                                                                                            ciscoReferenceObject.ServicePort,
                                                                                            ServiceDirection.Destination,
                                                                                            ciscoAcl.Id);
                        cpObject = GetCheckPointObjectOrCreateDummy(icmpName,
                                                                    CheckPointDummyObjectType.ServiceGroup,
                                                                    ciscoAcl,
                                                                    "Error creating a rule, missing information for Cisco destination service",
                                                                    "Service details: icmp6 " + ciscoReferenceObject.ServicePort + ".");
                        cpRule.Service.Add(cpObject);
                        if (cpObject.Name.Equals("Any"))
                        {
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyServiceCount++;
                            if (any_fl)
                            {
                                NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                                any_fl = false;
                            }
                        }
                    }
                    else if (_cpObjects.HasObject(ciscoReferenceObject.CiscoId))
                    {
                        if (ciscoReferenceObject.IsDestination)
                        {
                            cpObject = GetCheckPointObjectOrCreateDummy(ciscoReferenceObject.CiscoId,
                                                                        CheckPointDummyObjectType.ServiceGroup,
                                                                        ciscoAcl,
                                                                        "Error creating a rule, missing information for Cisco service object",
                                                                        "Object details: " + ciscoReferenceObject.CiscoId + ".");
                            cpRule.Service.Add(cpObject);
                            if (cpObject.Name.Equals("Any"))
                            {
                                NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyServiceCount++;
                                if (any_fl)
                                {
                                    NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                                    any_fl = false;
                                }
                            }

                            // This may happen if both source and destination protocols are defined on the Cisco service!!!
                            if (ciscoReferenceObject.ConversionIncidentType != ConversionIncidentType.None)
                            {
                                ciscoAcl.ConversionIncidentType = ConversionIncidentType.Informative;
                            }
                        }
                        else
                        {
                            cpRule.ConversionIncidentType = ConversionIncidentType.Informative;
                            ciscoAcl.ConversionIncidentType = ConversionIncidentType.Informative;

                            _conversionIncidents.Add(new ConversionIncident(ciscoAcl.Id,
                                                                            "ACL protocol points to a source service",
                                                                            "Ignoring source service: " + ciscoReferenceObject.CiscoId + ".",
                                                                            ciscoAcl.ConversionIncidentType));
                        }
                    }
                    else
                    {
                        cpObject = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                                    CheckPointDummyObjectType.ServiceGroup,
                                                                    ciscoAcl,
                                                                    "Error creating a rule, missing information for Cisco service object",
                                                                    "Object details: " + ciscoReferenceObject.CiscoId + ".");
                        cpRule.Service.Add(cpObject);
                        if (cpObject.Name.Equals("Any"))
                        {
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyServiceCount++;
                            if (any_fl)
                            {
                                NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                                any_fl = false;
                            }
                        }
                    }
                }
                else
                {
                    cpRule.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                    ciscoAcl.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                    _conversionIncidents.Add(new ConversionIncident(ciscoAcl.Id,
                                                                    "Error creating a rule, missing information for Cisco ACL protocol",
                                                                    "ACL Protocol details: " + ciscoAcl.ProtocolReference + ".",
                                                                    ciscoAcl.ConversionIncidentType));
                }
            }

            if (ciscoAcl.Protocol == ProtocolType.Icmp && cpRule.Service.Count == 0)
            {
                cpRule.Service.Add(_cpObjects.GetObject("icmp-proto"));
            }

            if (ciscoAcl.Protocol == ProtocolType.Icmp6 && cpRule.Service.Count == 0)
            {
                cpRule.Service.Add(_cpObjects.GetObject("IPv6-ICMP"));
            }

            if (ciscoAcl.Protocol == ProtocolType.Tcp && cpRule.Service.Count == 0)
            {
                cpRule.Service.Add(_cpObjects.GetObject("unknown_protocol_tcp"));
            }

            if (ciscoAcl.Protocol == ProtocolType.Udp && cpRule.Service.Count == 0)
            {
                cpRule.Service.Add(_cpObjects.GetObject("unknown_protocol_udp"));
            }

            if (cpRule.Service.Count == 0)
            {
                NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyServiceCount++;
                if (any_fl)
                {
                    NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                    any_fl = false;
                }
                // No service detected, or generic IP service protocol was skipped.
                // "any" service object will be used automatically...
            }

            return cpRule;
        }

        private void Add_AclServices_To_CPRule(Cisco_AccessList ciscoAcl, Cisco_GroupObject aclServices, CheckPoint_Rule cpRule)
        {
            // Avoid general "icmp-proto" service duplicates
            bool hasGeneralIcmpServiceMember = false;

            foreach (Cisco_ServiceObject ciscoService in aclServices.GetChildServices())
            {
                CheckPointObject cpObject;

                // Check for the case where we are referencing a service object by its name
                if (!string.IsNullOrEmpty(ciscoService.RefObjectName))
                {
                    var ciscoReferencedService = (Cisco_Object)_ciscoParser.GetCommandByCiscoId(ciscoService.RefObjectName);
                    if (ciscoReferencedService != null && _cpObjects.HasObject(ciscoReferencedService.CiscoId))
                    {
                        if (ciscoReferencedService.IsDestination)
                        {
                            cpObject = GetCheckPointObjectOrCreateDummy(ciscoReferencedService.CiscoId,
                                                                        CheckPointDummyObjectType.ServiceGroup,
                                                                        ciscoAcl,
                                                                        "Error creating a rule, missing information for Cisco service object",
                                                                        "Object details: " + ciscoReferencedService.CiscoId + ".");
                            cpRule.Service.Add(cpObject);
                            if (cpObject.Name.Equals("Any"))
                            {
                                NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyServiceCount++;
                                NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                            }

                            // This may happen, for example, if:
                            // 1. both source and destination protocols are defined on the Cisco service
                            // 2. the Cisco service has a duplicate name
                            if (ciscoReferencedService.ConversionIncidentType != ConversionIncidentType.None)
                            {
                                ciscoAcl.ConversionIncidentType = ConversionIncidentType.Informative;
                            }
                        }
                        else
                        {
                            cpRule.ConversionIncidentType = ConversionIncidentType.Informative;
                            ciscoAcl.ConversionIncidentType = ConversionIncidentType.Informative;

                            _conversionIncidents.Add(new ConversionIncident(ciscoAcl.Id,
                                                                            "ACL protocol points to a service group with \"source-services\"",
                                                                            "Ignoring source service: " + ciscoReferencedService.CiscoId + ".",
                                                                            ciscoAcl.ConversionIncidentType));
                        }
                    }

                    continue;
                }

                if (ciscoService.IsDestination)
                {
                    if (ciscoService.Protocol == "tcp-udp")
                    {
                        string tcpServiceName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                  "tcp",
                                                                                                  ciscoService.Operator,
                                                                                                  ciscoService.Port,
                                                                                                  ServiceDirection.Destination,
                                                                                                  ciscoService.Id);
                        cpObject = GetCheckPointObjectOrCreateDummy(tcpServiceName,
                                                                    CheckPointDummyObjectType.ServiceGroup,
                                                                    ciscoAcl,
                                                                    "Error creating a rule, missing information for Cisco destination service",
                                                                    "Service details: " + ciscoService.Protocol + " " + ciscoService.Operator + " " + ciscoService.Port + ".");
                        cpRule.Service.Add(cpObject);
                        if (cpObject.Name.Equals("Any"))
                        {
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyServiceCount++;
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                        }

                        string udpServiceName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                                  "udp",
                                                                                                  ciscoService.Operator,
                                                                                                  ciscoService.Port,
                                                                                                  ServiceDirection.Destination,
                                                                                                  ciscoService.Id);
                        cpObject = GetCheckPointObjectOrCreateDummy(udpServiceName,
                                                                    CheckPointDummyObjectType.ServiceGroup,
                                                                    ciscoAcl,
                                                                    "Error creating a rule, missing information for Cisco destination service",
                                                                    "Service details: " + ciscoService.Protocol + " " + ciscoService.Operator + " " + ciscoService.Port + ".");
                        cpRule.Service.Add(cpObject);
                        if (cpObject.Name.Equals("Any"))
                        {
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyServiceCount++;
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                        }
                    }
                    else if (ciscoService.Protocol == "ip")
                    {
                        cpRule.Service.Clear();   // "any" service object will be used automatically...

                        cpRule.ConversionIncidentType = ConversionIncidentType.Informative;
                        ciscoAcl.ConversionIncidentType = ConversionIncidentType.Informative;

                        _conversionIncidents.Add(new ConversionIncident(ciscoAcl.Id,
                                                                        "ACL protocol points to a service group with generic IP protocol",
                                                                        "Using \"any\" service object. Service group details: " + aclServices.CiscoId + ".",
                                                                        ciscoAcl.ConversionIncidentType));

                        return;
                    }
                    else   // regular icmp, tcp or udp, or other known ip protocol...
                    {
                        string serviceName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                               ciscoService.Protocol,
                                                                                               ciscoService.Operator,
                                                                                               ciscoService.Port,
                                                                                               ServiceDirection.Destination,
                                                                                               ciscoService.Id);
                        if (serviceName == "icmp-proto" || serviceName == "IPv6-ICMP")
                        {
                            if (hasGeneralIcmpServiceMember)
                            {
                                continue;
                            }
                            hasGeneralIcmpServiceMember = true;
                        }

                        var dummyObjectType = (ciscoAcl.DestinationProperties.Protocol == ProtocolType.KnownOtherIpProtocol)
                            ? CheckPointDummyObjectType.OtherService
                            : CheckPointDummyObjectType.ServiceGroup;

                        cpObject = GetCheckPointObjectOrCreateDummy(serviceName,
                                                                    dummyObjectType,
                                                                    ciscoAcl,
                                                                    "Error creating a rule, missing information for Cisco destination service",
                                                                    "Service details: " + ciscoService.Protocol + " " + ciscoService.Operator + " " + ciscoService.Port + ".");
                        cpRule.Service.Add(cpObject);
                        if (cpObject.Name.Equals("Any"))
                        {
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyServiceCount++;
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                        }
                    }

                    // This may happen if both source and destination protocols are defined on the Cisco service!!!
                    if (ciscoService.ConversionIncidentType != ConversionIncidentType.None)
                    {
                        ciscoAcl.ConversionIncidentType = ConversionIncidentType.Informative;
                    }
                }
                else   // reference objects with source ports
                {
                    cpRule.ConversionIncidentType = ConversionIncidentType.Informative;
                    ciscoAcl.ConversionIncidentType = ConversionIncidentType.Informative;

                    _conversionIncidents.Add(new ConversionIncident(ciscoAcl.Id,
                                                                    "ACL protocol points to a service group with \"source-services\"",
                                                                    "Ignoring source service: " + ciscoService.Protocol + " " + ciscoService.Port + ", in group: " + ciscoAcl.ProtocolReference + ".",
                                                                    ciscoAcl.ConversionIncidentType));
                }
            }
        }

        private void Add_AclIcmpTypes_To_CPRule(Cisco_AccessList ciscoAcl, Cisco_GroupObject aclIcmpTypes, CheckPoint_Rule cpRule)
        {
            foreach (var icmpType in aclIcmpTypes.IcmpTypes)
            {
                string icmpName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                    ProtocolType.Icmp,
                                                                                    TcpUdpPortOperatorType.Eq,
                                                                                    icmpType,
                                                                                    ServiceDirection.Destination,
                                                                                    ciscoAcl.Id);
                var cpObject = GetCheckPointObjectOrCreateDummy(icmpName,
                                                                CheckPointDummyObjectType.ServiceGroup,
                                                                ciscoAcl,
                                                                "Error creating a rule, missing information for Cisco destination service",
                                                                "Service details: icmp " + icmpType + ".");
                cpRule.Service.Add(cpObject);
                if (cpObject.Name.Equals("Any"))
                {
                    NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyServiceCount++;
                    NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                }
            }
        }

        private void Add_AclProtocols_To_CPRule(Cisco_AccessList ciscoAcl, Cisco_GroupObject aclProtocols, CheckPoint_Rule cpRule)
        {
            foreach (var proto in aclProtocols.Protocols)
            {
                string protocol = proto;
                var protocolType = CheckPointServiceObjectsFactory.ProtocolStringToProtocolType(ref protocol);
                if (protocolType == ProtocolType.NA)
                {
                    cpRule.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                    ciscoAcl.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                    _conversionIncidents.Add(new ConversionIncident(ciscoAcl.Id,
                                                                    "Error creating a rule, missing information for Cisco ACL protocol",
                                                                    "ACL Protocol details: " + protocol + ", in group: " + aclProtocols.CiscoId + ".",
                                                                    ciscoAcl.ConversionIncidentType));

                    continue;
                }

                string sPort = (protocolType == ProtocolType.KnownOtherIpProtocol) ? protocol : ciscoAcl.DestinationProperties.TcpUdpPortValue;

                if (protocolType == ProtocolType.KnownOtherIpProtocol || ciscoAcl.DestinationProperties.TcpUdpPortOperator != TcpUdpPortOperatorType.ReferenceObject)
                {
                    // specific protocol with a specific port
                    var cpObject = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects,
                                                                                    protocolType,
                                                                                    ciscoAcl.DestinationProperties.TcpUdpPortOperator,
                                                                                    sPort,
                                                                                    ServiceDirection.Destination,
                                                                                    ciscoAcl.Id);
                    if (cpObject != null &&
                        (cpObject.GetType() == typeof(CheckPoint_TcpService) || cpObject.GetType() == typeof(CheckPoint_UdpService) || cpObject.GetType() == typeof(CheckPoint_OtherService)))
                    {
                        ApplyConversionIncidentOnCheckPointObject(cpObject, ciscoAcl);
                        AddCheckPointObject(cpObject);
                        cpRule.Service.Add(cpObject);
                        if (cpObject.Name.Equals("Any"))
                        {
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyServiceCount++;
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                        }
                    }
                }
                else
                {
                    // specific protocol with a service group of ports
                    CiscoCommand ciscoPortReferenceCommand = _ciscoParser.GetCommandByCiscoId(ciscoAcl.DestinationProperties.TcpUdpPortValue);

                    if (ciscoPortReferenceCommand != null && ciscoPortReferenceCommand.Name() == "object-group")
                    {
                        var ciscoGroupReferenceObject = (Cisco_GroupObject)ciscoPortReferenceCommand;

                        if (ciscoGroupReferenceObject.GroupType == Cisco_GroupObject.Group_Type.Service)
                        {
                            Add_AclPorts_To_CPRule(ciscoAcl, protocol, ciscoGroupReferenceObject, cpRule);
                        }
                    }
                }
            }
        }

        private void Add_AclPorts_To_CPRule(Cisco_AccessList ciscoAcl, string aclProtocol, Cisco_GroupObject aclPorts, CheckPoint_Rule cpRule)
        {
            foreach (Cisco_PortObject ciscoPort in aclPorts.GetChildPorts())
            {
                CheckPointObject cpObject;
                string serviceName;

                switch (aclProtocol)
                {
                    case "tcp-udp":
                        serviceName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                        ProtocolType.Tcp,
                                                                                        TcpUdpPortOperatorType.Eq,
                                                                                        ciscoPort.Port,
                                                                                        ServiceDirection.Destination,
                                                                                        ciscoPort.Id);
                        cpObject = GetCheckPointObjectOrCreateDummy(serviceName,
                                                                    CheckPointDummyObjectType.ServiceGroup,
                                                                    ciscoAcl,
                                                                    "Error creating a rule, missing information for Cisco service object",
                                                                    "Object details: " + aclPorts.CiscoId + ".");
                        cpRule.Service.Add(cpObject);
                        if (cpObject.Name.Equals("Any"))
                        {
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyServiceCount++;
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                        }

                        serviceName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                        ProtocolType.Udp,
                                                                                        TcpUdpPortOperatorType.Eq,
                                                                                        ciscoPort.Port,
                                                                                        ServiceDirection.Destination,
                                                                                        ciscoPort.Id);
                        cpObject = GetCheckPointObjectOrCreateDummy(serviceName,
                                                                    CheckPointDummyObjectType.ServiceGroup,
                                                                    ciscoAcl,
                                                                    "Error creating a rule, missing information for Cisco service object",
                                                                    "Object details: " + aclPorts.CiscoId + ".");
                        cpRule.Service.Add(cpObject);
                        if (cpObject.Name.Equals("Any"))
                        {
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyServiceCount++;
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                        }
                        break;

                    case "tcp":
                    case "udp":
                        serviceName = CheckPointServiceObjectsFactory.AutoGeneratedName(_cpObjects,
                                                                                        aclProtocol,
                                                                                        "eq",
                                                                                        ciscoPort.Port,
                                                                                        ServiceDirection.Destination,
                                                                                        ciscoPort.Id);
                        cpObject = GetCheckPointObjectOrCreateDummy(serviceName,
                                                                    CheckPointDummyObjectType.ServiceGroup,
                                                                    ciscoAcl,
                                                                    "Error creating a rule, missing information for Cisco service object",
                                                                    "Object details: " + aclPorts.CiscoId + ".");
                        cpRule.Service.Add(cpObject);
                        if (cpObject.Name.Equals("Any"))
                        {
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyServiceCount++;
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                        }
                        break;
                }
            }
        }

        private void Add_Layers_And_Rules_For_Other_Zones(CheckPoint_Package package)
        {
            var accessGroups = new List<string>();
            var accessGroupsExclude = new List<string>();
            var aclNames = new List<string>();

            foreach (CiscoCommand command in CiscoAccessGroupCommands)
            {
                var ciscoAccessGroup = (Cisco_AccessGroup)command;
                if (ciscoAccessGroup.Direction == Cisco_AccessGroup.DirectionType.Inbound)
                {
                    if (aclNames.Contains(ciscoAccessGroup.AccessListName))
                    {
                        continue;
                    }
                    aclNames.Add(ciscoAccessGroup.AccessListName);

                    accessGroups.Add(CiscoCommand.InterfacePrefix + ciscoAccessGroup.InterfaceName);
                }
                else
                {
                    // No Outbound nor Global...
                    accessGroupsExclude.Add(CiscoCommand.InterfacePrefix + ciscoAccessGroup.InterfaceName);
                }
            }

            var availableZones = new List<CheckPoint_Zone>();
            int availableZonesWithZeroSecurityLevel = 0;

            foreach (CheckPoint_Zone cpZone in _cpZones)
            {
                if (accessGroups.Contains(cpZone.Name) || accessGroupsExclude.Contains(cpZone.Name))
                {
                    continue;
                }

                // get Cisco interface object
                var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(cpZone.Name);
                if (ciscoInterface == null || !ciscoInterface.HasValidIpAddress() || ciscoInterface.ManagementOnly)
                {
                    continue;
                }

                availableZones.Add(cpZone);

                // If the _isInterInterfaceTrafficAllowed flag is on and there are at least two Cisco interfaces with zero security level,
                // we should add sub-policies for the equivalent CP zones to allow traffic between them.
                if (ciscoInterface.SecurityLevel == 0)
                {
                    ++availableZonesWithZeroSecurityLevel;
                }
            }

            foreach (CheckPoint_Zone cpZone in availableZones)
            {
                // get Cisco interface object
                var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(cpZone.Name);

                bool addSubPolicy = (_isIntraInterfaceTrafficAllowed || (_isInterInterfaceTrafficAllowed && availableZonesWithZeroSecurityLevel >= 2))
                                        ? (ciscoInterface.SecurityLevel >= 0)
                                        : (ciscoInterface.SecurityLevel > 0);

                if (addSubPolicy)
                {
                    var cpLayer = new CheckPoint_Layer();
                    cpLayer.Name = cpZone.Name + "_sub_policy";

                    if (ciscoInterface.Shutdown)
                    {
                        cpLayer.Tag = "InterfaceDisabled";
                    }

                    if (_isIntraInterfaceTrafficAllowed)
                    {
                        var cpRule = new CheckPoint_Rule();
                        cpRule.ConversionComments = "Traffic allowed due to Cisco intra-interface configuration";
                        cpRule.Layer = cpLayer.Name;
                        cpRule.Action = CheckPoint_Rule.ActionType.Accept;
                        cpRule.Destination.Add(cpZone);
                        if (cpZone.Name.Equals("Any"))
                        {
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyDestinationCount++;
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                        }

                        if (ciscoInterface.Shutdown)
                        {
                            NewCiscoAnalizStatistic._disabledServicesRulesCount++;
                            cpRule.Enabled = false;
                        }

                        if (!cpRule.Track.Equals(TrackTypes.Log))
                        {
                            NewCiscoAnalizStatistic._nonServicesLoggingServicesRulesCount++;
                        }

                        cpLayer.Rules.Add(cpRule);
                    }

                    // add rules to this sub policy
                    foreach (CiscoCommand command in CiscoInterfaceCommands)
                    {
                        var otherCiscoInterface = (Cisco_Interface)command;

                        if (string.IsNullOrEmpty(otherCiscoInterface.CiscoId) ||
                            otherCiscoInterface.CiscoId == ciscoInterface.CiscoId ||
                            !otherCiscoInterface.HasValidIpAddress() ||
                            otherCiscoInterface.ManagementOnly)
                        {
                            continue;
                        }

                        bool addRule = _isInterInterfaceTrafficAllowed
                                           ? (ciscoInterface.SecurityLevel >= otherCiscoInterface.SecurityLevel)
                                           : (ciscoInterface.SecurityLevel > otherCiscoInterface.SecurityLevel);

                        if (addRule)
                        {
                            var cpRule = new CheckPoint_Rule();
                            cpRule.ConversionComments = otherCiscoInterface.CiscoId + " security level " + otherCiscoInterface.SecurityLevel;
                            cpRule.Layer = cpLayer.Name;
                            cpRule.Action = CheckPoint_Rule.ActionType.Accept;
                            cpRule.Destination.Add(_cpObjects.GetObject(otherCiscoInterface.CiscoId));
                            if (_cpObjects.GetObject(otherCiscoInterface.CiscoId).Name.Equals("Any"))
                            {
#pragma warning disable CS0219 // The variable 'count' is assigned but its value is never used
                                int count = 0;
#pragma warning restore CS0219 // The variable 'count' is assigned but its value is never used
                            }
                            if (ciscoInterface.Shutdown || otherCiscoInterface.Shutdown)
                            {
                                NewCiscoAnalizStatistic._disabledServicesRulesCount++;
                                cpRule.Enabled = false;
                            }

                            if (!cpRule.Track.Equals(TrackTypes.Log))
                            {
                                NewCiscoAnalizStatistic._nonServicesLoggingServicesRulesCount++;
                            }

                            ApplyConversionIncidentOnCheckPointObject(cpRule, otherCiscoInterface);

                            cpLayer.Rules.Add(cpRule);
                        }
                    }

                    var cpCleanupRule = new CheckPoint_Rule();
                    cpCleanupRule.Name = CheckPoint_Rule.SubPolicyCleanupRuleName;
                    cpCleanupRule.Action = CheckPoint_Rule.ActionType.Drop;
                    cpCleanupRule.Layer = cpLayer.Name;

                    cpLayer.Rules.Add(cpCleanupRule);

                    package.SubPolicies.Add(cpLayer);
                    validatePackage(package);
                }
            }
        }

        private void DetectCheckPointFirewallRulesAffectedByInspectPolicy(CheckPoint_Package package)
        {
            var ciscoInspectedAclCommands = new List<Cisco_AccessList>();

            // Detect the affected ACLs
            foreach (var ciscoCommand in CiscoClassMapCommands)
            {
                var ciscoClassMapCommand = (Cisco_ClassMap)ciscoCommand;

                foreach (var matchedAclName in ciscoClassMapCommand.MatchedAclNames)
                {
                    foreach (CiscoCommand aclCommand in CiscoAclCommands)
                    {
                        var ciscoAcl = (Cisco_AccessList)aclCommand;
                        if (!ciscoAcl.IsRemark && ciscoAcl.ACLName == matchedAclName)
                        {
                            ciscoAcl.Tag = ciscoClassMapCommand.ClassMapName;
                            ciscoInspectedAclCommands.Add(ciscoAcl);
                        }
                    }
                }
            }

            // Go over the affected ACLs and match the fw rules by: source, destination and service fields
            foreach (var ciscoInspectedAcl in ciscoInspectedAclCommands)
            {
                var inspectedRule = Acl_To_CPRule(ciscoInspectedAcl, null);

                if ((inspectedRule.Source.Count == 1 && inspectedRule.Source[0].Name == CheckPointObject.Any) &&
                    (inspectedRule.Destination.Count == 1 && inspectedRule.Destination[0].Name == CheckPointObject.Any) &&
                    (inspectedRule.Service.Count == 1 && inspectedRule.Service[0].Name == CheckPointObject.Any))
                {
                    continue;   // cisco any/any/any??? skip!!!
                }

                bool foundMatchedRules = false;

                foreach (CheckPoint_Rule cpParentRule in package.ParentLayer.Rules)
                {
                    if (cpParentRule.Action != CheckPoint_Rule.ActionType.SubPolicy)
                    {
                        continue;
                    }

                    // Skip automatic rules for interfaces without access-group
                    if (cpParentRule.SubPolicyName.EndsWith("_sub_policy"))
                    {
                        continue;
                    }

                    // Get into the relevant sub-policy
                    foreach (CheckPoint_Layer subPolicy in package.SubPolicies)
                    {
                        if (subPolicy.Name != cpParentRule.SubPolicyName)
                        {
                            continue;
                        }

                        for (int ruleNumber = 0; ruleNumber < subPolicy.Rules.Count; ruleNumber++)
                        {
                            var cpRule = subPolicy.Rules[ruleNumber];

                            // Do not match on cleanup rule!!!
                            if (cpRule.IsCleanupRule())
                            {
                                continue;
                            }

                            // Do not match if rule's destination is 'any'
                            if (cpRule.Destination.Count == 1 && cpRule.Destination[0].Name == CheckPointObject.Any)
                            {
                                continue;
                            }

                            if (IsCheckPointFirewallRuleMatchedByInspectPolicy(cpRule, inspectedRule))
                            {
                                if (string.IsNullOrEmpty(cpRule.Tag))
                                {
                                    cpRule.Tag = ciscoInspectedAcl.Tag;   // Cisco Class-Map object name
                                }
                                else
                                {
                                    // There may be several class-maps (e.g: class1, class2, ...) matching the same fw rule...
                                    // BUT - do not tag on the SAME class-map (e.g: class1) multiple times!!!
                                    if (!cpRule.Tag.Contains(ciscoInspectedAcl.Tag))
                                    {
                                        cpRule.Tag += ",";
                                        cpRule.Tag += ciscoInspectedAcl.Tag;   // Cisco Class-Map object name
                                    }
                                }

                                foundMatchedRules = true;
                            }
                        }
                    }
                }

                if (foundMatchedRules)
                {
                    package.ConversionIncidentType = ConversionIncidentType.Informative;

                    _conversionIncidents.Add(new ConversionIncident(ciscoInspectedAcl.Id,
                                                                    "Check Point firewall rules traffic is affected by Cisco inspect policy",
                                                                    "Cisco class-map object: " + ciscoInspectedAcl.Tag + ". For rules details refer to the Converted Policy Report.",
                                                                    ConversionIncidentType.Informative));
                }
            }
        }

        private bool IsCheckPointFirewallRuleMatchedByInspectPolicy(CheckPoint_Rule fwRule, CheckPoint_Rule inspectedRule)
        {
            // Do not match on any/any/any rule!!!
            // There may be such rules due to usage of generic IP protocol as a service in ACL...
            if ((fwRule.Source.Count == 1 && fwRule.Source[0].Name == CheckPointObject.Any) &&
                (fwRule.Destination.Count == 1 && fwRule.Destination[0].Name == CheckPointObject.Any) &&
                (fwRule.Service.Count == 1 && fwRule.Service[0].Name == CheckPointObject.Any))
            {
                return false;
            }

            var fwRuleSourceRanges = (fwRule.Source.Count > 0) ? GetRanges(fwRule.Source[0]) : IPRanges.Any();
            var fwRuleDestRanges = (fwRule.Destination.Count > 0) ? GetRanges(fwRule.Destination[0]) : IPRanges.Any();
            var inspectedRuleSourceRanges = (inspectedRule.Source.Count > 0) ? GetRanges(inspectedRule.Source[0]) : IPRanges.Any();
            var inspectedRuleDestRanges = (inspectedRule.Destination.Count > 0) ? GetRanges(inspectedRule.Destination[0]) : IPRanges.Any();

            if (inspectedRuleSourceRanges.Overlaps(fwRuleSourceRanges) && inspectedRuleDestRanges.Overlaps(fwRuleDestRanges))
            {
                if ((fwRule.Service.Count == 1 && fwRule.Service[0].Name == CheckPointObject.Any) ||
                    (inspectedRule.Service.Count == 1 && inspectedRule.Service[0].Name == CheckPointObject.Any))
                {
                    return true;
                }

                // Inspected services should be a subset of fw services
                foreach (var inspectedService in inspectedRule.Service)
                {
                    bool matchService = fwRule.Service.Any(fwService => fwService.Name == inspectedService.Name);
                    if (!matchService)
                    {
                        return false;
                    }
                }

                return true;
            }

            return false;
        }

        private void Add_object_NAT()
        {
            foreach (Cisco_Object command in CiscoObjectCommands)
            {
                if (command.Children == null)
                {
                    continue;
                }

                foreach (CiscoCommand childCommand in command.Children)
                {
                    // This is for object-NAT only
                    if (childCommand.Name() == "nat")
                    {
                        var ciscoNat = (Cisco_Nat)childCommand;

                        var cpNatRule = new CheckPoint_NAT_Rule();
                        cpNatRule.Enabled = !ciscoNat.Inactive;
                        cpNatRule.Method = ciscoNat.IsStatic ? CheckPoint_NAT_Rule.NatMethod.Static : CheckPoint_NAT_Rule.NatMethod.Hide;
                        cpNatRule.Source = _cpObjects.GetObject(command.CiscoId);
                        cpNatRule.Comments = command.Id + ")" + (ciscoNat.IsStatic ? " Static " : " Dynamic ") + "object NAT for " + command.CiscoId;

                        cpNatRule.VendorCustomData = new CiscoNatCustomData();
                        ((CiscoNatCustomData)cpNatRule.VendorCustomData).Interface1 = ciscoNat.RealInterface;
                        ((CiscoNatCustomData)cpNatRule.VendorCustomData).Interface2 = ciscoNat.MappedInterface;
                        ((CiscoNatCustomData)cpNatRule.VendorCustomData).IsObjectNatRule = true;

                        ApplyConversionIncidentOnCheckPointObject(cpNatRule, ciscoNat);

                        string translatedSourceName;

                        string ciscoNetworkObjectName = ciscoNat.IsStatic ? ciscoNat.StaticNatIpAddressOrObjectName : ciscoNat.DynamicNatIpAddressOrObjectName;
                        var ciscoNetworkObject = _ciscoParser.GetCommandByCiscoId(ciscoNetworkObjectName);

                        if (ciscoNetworkObject != null)   // mapped_object_name
                        {
                            // Should be a host/network/range object only.
                            if (ciscoNetworkObject.GetType() == typeof(Cisco_Object))
                            {
                                var ciscoNetwork = (Cisco_Object)ciscoNetworkObject;

                                switch (ciscoNetwork.ObjectType)
                                {
                                    case Cisco_Object.ObjectTypes.Host:
                                        {
                                            var network = new CiscoNetwork(ciscoNat.Id, ciscoNetwork.HostAddress);

                                            var cpHostTranslated = new CheckPoint_Host();
                                            cpHostTranslated.Name = ciscoNetworkObjectName;
                                            cpHostTranslated.IpAddress = network.IpAddress;
                                            ApplyConversionIncidentOnCheckPointObject(cpHostTranslated, ciscoNat);
                                            AddCheckPointObject(cpHostTranslated);

                                            translatedSourceName = cpHostTranslated.Name;
                                        }
                                        break;

                                    case Cisco_Object.ObjectTypes.Network:
                                        {
                                            var network = new CiscoNetwork(ciscoNat.Id, ciscoNetwork.Network, ciscoNetwork.Netmask, ciscoNetwork.MaskPrefix);

                                            var cpNetworkTranslated = new CheckPoint_Network();
                                            cpNetworkTranslated.Name = ciscoNetworkObjectName;
                                            cpNetworkTranslated.Subnet = network.IpAddress;
                                            cpNetworkTranslated.Netmask = network.NetMask;
                                            ApplyConversionIncidentOnCheckPointObject(cpNetworkTranslated, ciscoNat);
                                            AddCheckPointObject(cpNetworkTranslated);

                                            translatedSourceName = cpNetworkTranslated.Name;
                                        }
                                        break;

                                    case Cisco_Object.ObjectTypes.Range:
                                        {
                                            var cpRangeTranslated = new CheckPoint_Range();
                                            cpRangeTranslated.Name = "r_" + ciscoNetwork.RangeFrom + "-" + ciscoNetwork.RangeTo;
                                            cpRangeTranslated.RangeFrom = ciscoNetwork.RangeFrom;
                                            cpRangeTranslated.RangeTo = ciscoNetwork.RangeTo;
                                            ApplyConversionIncidentOnCheckPointObject(cpRangeTranslated, ciscoNat);
                                            AddCheckPointObject(cpRangeTranslated);

                                            translatedSourceName = cpRangeTranslated.Name;
                                        }
                                        break;

                                    default:
                                        {
                                            var cpError = GetCheckPointObjectOrCreateDummy(ciscoNetwork.ObjectType.ToString(),
                                                                                           CheckPointDummyObjectType.Host,
                                                                                           ciscoNat,
                                                                                           "Error creating a NAT rule, missing information for Cisco translated source",
                                                                                           "Translated source details: " + ciscoNetworkObjectName + ".");
                                            translatedSourceName = cpError.Name;
                                        }
                                        break;
                                }
                            }
                            else
                            {
                                var cpError = GetCheckPointObjectOrCreateDummy("not_existing_object",
                                                                               CheckPointDummyObjectType.Host,
                                                                               ciscoNat,
                                                                               "Error creating a NAT rule, group object cannot be used as a translated source",
                                                                               "Group object details: " + ciscoNetworkObjectName + ".");
                                translatedSourceName = cpError.Name;
                            }
                        }
                        else
                        {
                            if (ciscoNat.IsHideBehindInterface)   // interface
                            {
                                // No need for translated source for NAT hidden behind an interface...
                                translatedSourceName = "";
                            }
                            else   // mapped_host_ip_address
                            {
                                // Can be a host IP address only.
                                var network = new CiscoNetwork(ciscoNat.Id, ciscoNat.IsStatic ? ciscoNat.StaticNatIpAddressOrObjectName : ciscoNat.DynamicNatIpAddressOrObjectName);

                                var cpHostTranslated = new CheckPoint_Host();
                                cpHostTranslated.Name = network.AutoGeneratedName();
                                cpHostTranslated.IpAddress = network.IpAddress;
                                ApplyConversionIncidentOnCheckPointObject(cpHostTranslated, ciscoNat);
                                AddCheckPointObject(cpHostTranslated);

                                translatedSourceName = cpHostTranslated.Name;
                            }
                        }

                        if (ciscoNat.IsHideBehindInterface)
                        {
                            cpNatRule.TranslatedSource = GetCheckPointObjectOrCreateDummy(CiscoCommand.InterfacePrefix + ciscoNat.MappedInterface + "_address",
                                                                                          CheckPointDummyObjectType.Host,
                                                                                          ciscoNat,
                                                                                          "Error creating a NAT rule, missing topology information for Cisco interface",
                                                                                          "Interface details: " + ciscoNat.MappedInterface + ".");
                        }
                        else   // hide behind an arbitrary ip/network
                        {
                            cpNatRule.TranslatedSource = _cpObjects.GetObject(translatedSourceName);
                        }

                        if (ciscoNat.MappedInterface == CiscoCommand.Any)
                        {
                            cpNatRule.Destination = _cpObjects.GetObject(CheckPointObject.Any);
                        }
                        else
                        {
                            var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(CiscoCommand.InterfacePrefix + ciscoNat.MappedInterface);
                            if (ciscoInterface != null && ciscoInterface.LeadsToInternet)
                            {
                                cpNatRule.Destination = _cpObjects.GetObject(CheckPointObject.Any);
                                ((CiscoNatCustomData)cpNatRule.VendorCustomData).IsNonNatSectionRule = true;
                            }
                            else
                            {
                                cpNatRule.Destination = GetCheckPointObjectOrCreateDummy(CiscoCommand.InterfacePrefix + ciscoNat.MappedInterface + "_subnets",
                                                                                         CheckPointDummyObjectType.NetworkGroup,
                                                                                         ciscoNat,
                                                                                         "Error creating a NAT rule, missing topology information for Cisco interface",
                                                                                         "Interface details: " + ciscoNat.MappedInterface + ".");
                            }
                        }

                        if (ciscoNat.IsStatic && !string.IsNullOrEmpty(ciscoNat.ServiceProtocol))
                        {
                            CheckPointObject cpService = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects,
                                                                                                          (ciscoNat.ServiceProtocol == "tcp") ? ProtocolType.Tcp : ProtocolType.Udp,
                                                                                                          TcpUdpPortOperatorType.Eq,
                                                                                                          ciscoNat.ServiceId,
                                                                                                          ServiceDirection.Destination,
                                                                                                          ciscoNat.Id);
                            ApplyConversionIncidentOnCheckPointObject(cpService, ciscoNat);
                            AddCheckPointObject(cpService);

                            cpNatRule.Service = cpService;

                            if (ciscoNat.ServiceId != ciscoNat.TranslatedServiceId)
                            {
                                CheckPointObject cpTranslatedService = CheckPointServiceObjectsFactory.CreateServiceObj(_cpObjects,
                                                                                                                        (ciscoNat.ServiceProtocol == "tcp") ? ProtocolType.Tcp : ProtocolType.Udp,
                                                                                                                        TcpUdpPortOperatorType.Eq,
                                                                                                                        ciscoNat.TranslatedServiceId,
                                                                                                                        ServiceDirection.Destination,
                                                                                                                        ciscoNat.Id);
                                ApplyConversionIncidentOnCheckPointObject(cpTranslatedService, ciscoNat);
                                AddCheckPointObject(cpTranslatedService);

                                cpNatRule.TranslatedService = cpTranslatedService;
                            }
                        }

                        _cpPreorderedNatRules.Add(cpNatRule);

                        bool natRuleObjectHasConversionIncident = (cpNatRule.Source != null && cpNatRule.Source.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                  (cpNatRule.TranslatedSource != null && cpNatRule.TranslatedSource.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                  (cpNatRule.Destination != null && cpNatRule.Destination.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                  (cpNatRule.TranslatedDestination != null && cpNatRule.TranslatedDestination.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                  (cpNatRule.Service != null && cpNatRule.Service.ConversionIncidentType != ConversionIncidentType.None) ||
                                                                  (cpNatRule.TranslatedService != null && cpNatRule.TranslatedService.ConversionIncidentType != ConversionIncidentType.None);

                        if (cpNatRule.ConversionIncidentType != ConversionIncidentType.None ||
                            ciscoNat.ConversionIncidentType != ConversionIncidentType.None ||
                            natRuleObjectHasConversionIncident)
                        {
                            _hasNATConversionIncident = true;
                        }

                        // Mirrored NAT rule
                        if (ciscoNat.IsStatic && !ciscoNat.IsUnidirectional)
                        {
                            var cpNatMirrorRule = new CheckPoint_NAT_Rule();
                            cpNatMirrorRule.Enabled = cpNatRule.Enabled;
                            cpNatMirrorRule.Method = CheckPoint_NAT_Rule.NatMethod.Static;
                            cpNatMirrorRule.Source = cpNatRule.Destination;
                            cpNatMirrorRule.Destination = cpNatRule.TranslatedSource;
                            cpNatMirrorRule.Service = cpNatRule.TranslatedService ?? cpNatRule.Service;
                            cpNatMirrorRule.TranslatedDestination = _cpObjects.GetObject(command.CiscoId);
                            cpNatMirrorRule.TranslatedService = (cpNatRule.TranslatedService != null) ? cpNatRule.Service : cpNatRule.TranslatedService;
                            cpNatMirrorRule.Comments = "Mirror rule for object " + command.CiscoId;

                            cpNatMirrorRule.VendorCustomData = new CiscoNatCustomData();
                            ((CiscoNatCustomData)cpNatMirrorRule.VendorCustomData).Interface1 = ciscoNat.MappedInterface;
                            ((CiscoNatCustomData)cpNatMirrorRule.VendorCustomData).Interface2 = ciscoNat.RealInterface;
                            ((CiscoNatCustomData)cpNatMirrorRule.VendorCustomData).IsStaticMirrorRule = true;
                            ((CiscoNatCustomData)cpNatMirrorRule.VendorCustomData).IsObjectNatRule = true;
                            ((CiscoNatCustomData)cpNatMirrorRule.VendorCustomData).IsNonNatSectionRule = ((CiscoNatCustomData)cpNatRule.VendorCustomData).IsNonNatSectionRule;

                            _cpPreorderedNatRules.Add(cpNatMirrorRule);
                        }
                    }
                }
            }
        }

        private void Add_NAT_Rules()
        {
            // This is for manual-NAT, twice-NAT and auto-after-manual-twice-NAT
            List<CiscoCommand> natCommands = _ciscoParser.Filter("nat");

            foreach (CiscoCommand command in natCommands)
            {
                bool any_fl = true;
                var ciscoNat = (Cisco_Nat)command;

                Add_IP_as_Host(ciscoNat.Id, ciscoNat.SourceId);
                if (!ciscoNat.IsHideBehindInterface)
                {
                    Add_IP_as_Host(ciscoNat.Id, ciscoNat.TranslatedSourceId);
                }
                Add_IP_as_Host(ciscoNat.Id, ciscoNat.DestinationId);
                Add_IP_as_Host(ciscoNat.Id, ciscoNat.TranslatedDestinationId);

                // Original NAT rule
                var cpNatRule = new CheckPoint_NAT_Rule();
                cpNatRule.Enabled = !ciscoNat.Inactive;
                cpNatRule.Method = ciscoNat.IsStatic ? CheckPoint_NAT_Rule.NatMethod.Static : CheckPoint_NAT_Rule.NatMethod.Hide;
                cpNatRule.Comments = ciscoNat.Id + ") " + ciscoNat.Text;

                cpNatRule.VendorCustomData = new CiscoNatCustomData();
                ((CiscoNatCustomData)cpNatRule.VendorCustomData).Interface1 = ciscoNat.RealInterface;
                ((CiscoNatCustomData)cpNatRule.VendorCustomData).Interface2 = ciscoNat.MappedInterface;
                ((CiscoNatCustomData)cpNatRule.VendorCustomData).IsAutoAfterSectionRule = ciscoNat.IsAutoAfter;

                if (ciscoNat.SourceId == ciscoNat.TranslatedSourceId && ciscoNat.DestinationId == ciscoNat.TranslatedDestinationId)
                {
                    ((CiscoNatCustomData)cpNatRule.VendorCustomData).IsNonNatRule = true;
                }

                ApplyConversionIncidentOnCheckPointObject(cpNatRule, ciscoNat);

                // Source
                if (ciscoNat.SourceId != CiscoCommand.Any)
                {
                    cpNatRule.Source = GetCheckPointObjectOrCreateDummy(ciscoNat.SourceId,
                                                                        CheckPointDummyObjectType.NetworkGroup,
                                                                        ciscoNat,
                                                                        "Error creating a NAT rule, missing information for Cisco source",
                                                                        "Source details: " + ciscoNat.SourceId + ".");

                    if (ciscoNat.RealInterface != CiscoCommand.Any)
                    {
                        var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(CiscoCommand.InterfacePrefix + ciscoNat.RealInterface);
                        if (ciscoInterface == null)
                        {
                            cpNatRule.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                            ciscoNat.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                            _conversionIncidents.Add(new ConversionIncident(ciscoNat.Id,
                                                                            "Error creating a NAT rule, missing information for Cisco interface",
                                                                            "Interface details: " + ciscoNat.RealInterface + ".",
                                                                            ciscoNat.ConversionIncidentType));
                        }
                        else if (ciscoInterface.LeadsToInternet)
                        {
                            ((CiscoNatCustomData)cpNatRule.VendorCustomData).IsNonNatSectionRule = true;
                        }
                    }
                    else
                    {
                        NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnySourceCount++;
                        if (any_fl)
                        {
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                            any_fl = false;
                        }
                    }
                }
                else   // Identity NAT ???
                {
                    if (ciscoNat.RealInterface == CiscoCommand.Any)
                    {
                        cpNatRule.Source = _cpObjects.GetObject(CheckPointObject.Any);
                        NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnySourceCount++;
                        if (any_fl)
                        {
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                            any_fl = false;
                        }
                    }
                    else
                    {
                        var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(CiscoCommand.InterfacePrefix + ciscoNat.RealInterface);
                        if (ciscoInterface != null && ciscoInterface.LeadsToInternet)
                        {
                            cpNatRule.Source = _cpObjects.GetObject(CheckPointObject.Any);
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnySourceCount++;
                            if (any_fl)
                            {
                                NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                                any_fl = false;
                            }
                            ((CiscoNatCustomData)cpNatRule.VendorCustomData).IsNonNatSectionRule = true;
                        }
                        else
                        {
                            cpNatRule.Source = GetCheckPointObjectOrCreateDummy(CiscoCommand.InterfacePrefix + ciscoNat.RealInterface + "_subnets",
                                                                                CheckPointDummyObjectType.NetworkGroup,
                                                                                ciscoNat,
                                                                                "Error creating a NAT rule, missing topology information for Cisco interface",
                                                                                "Interface details: " + ciscoNat.RealInterface + ".");
                        }
                    }
                }

                // Destination
                if (string.IsNullOrEmpty(ciscoNat.DestinationId))   // Manual NAT
                {
                    if (ciscoNat.MappedInterface == CiscoCommand.Any)
                    {
                        cpNatRule.Destination = _cpObjects.GetObject(CheckPointObject.Any);
                        NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyDestinationCount++;
                        if (any_fl)
                        {
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                            any_fl = false;
                        }
                    }
                    else
                    {
                        var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(CiscoCommand.InterfacePrefix + ciscoNat.MappedInterface);
                        if (ciscoInterface != null && ciscoInterface.LeadsToInternet)
                        {
                            cpNatRule.Destination = _cpObjects.GetObject(CheckPointObject.Any);
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyDestinationCount++;
                            if (any_fl)
                            {
                                NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                                any_fl = false;
                            }
                            ((CiscoNatCustomData)cpNatRule.VendorCustomData).IsNonNatSectionRule = true;
                        }
                        else
                        {
                            cpNatRule.Destination = GetCheckPointObjectOrCreateDummy(CiscoCommand.InterfacePrefix + ciscoNat.MappedInterface + "_subnets",
                                                                                     CheckPointDummyObjectType.NetworkGroup,
                                                                                     ciscoNat,
                                                                                     "Error creating a NAT rule, missing topology information for Cisco interface",
                                                                                     "Interface details: " + ciscoNat.MappedInterface + ".");
                        }
                    }
                }
                else   // Twice NAT
                {
                    if (ciscoNat.DestinationId != CiscoCommand.Any)
                    {
                        cpNatRule.Destination = GetCheckPointObjectOrCreateDummy(ciscoNat.DestinationId,
                                                                                 CheckPointDummyObjectType.NetworkGroup,
                                                                                 ciscoNat,
                                                                                 "Error creating a NAT rule, missing information for Cisco destination",
                                                                                 "Destination details: " + ciscoNat.DestinationId + ".");

                        if (ciscoNat.MappedInterface != CiscoCommand.Any)
                        {
                            var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(CiscoCommand.InterfacePrefix + ciscoNat.MappedInterface);
                            if (ciscoInterface == null)
                            {
                                cpNatRule.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;
                                ciscoNat.ConversionIncidentType = ConversionIncidentType.ManualActionRequired;

                                _conversionIncidents.Add(new ConversionIncident(ciscoNat.Id,
                                                                                "Error creating a NAT rule, missing information for Cisco interface",
                                                                                "Interface details: " + ciscoNat.MappedInterface + ".",
                                                                                ciscoNat.ConversionIncidentType));
                            }
                            else if (ciscoInterface.LeadsToInternet)
                            {
                                ((CiscoNatCustomData)cpNatRule.VendorCustomData).IsNonNatSectionRule = true;
                            }
                        }
                    }
                    else
                    {
                        if (ciscoNat.MappedInterface == CiscoCommand.Any)
                        {
                            cpNatRule.Destination = _cpObjects.GetObject(CheckPointObject.Any);
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyDestinationCount++;
                            if (any_fl)
                            {
                                NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                                any_fl = false;
                            }
                        }
                        else
                        {
                            var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(CiscoCommand.InterfacePrefix + ciscoNat.MappedInterface);
                            if (ciscoInterface != null && ciscoInterface.LeadsToInternet)
                            {
                                cpNatRule.Destination = _cpObjects.GetObject(CheckPointObject.Any);
                                NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyDestinationCount++;
                                if (any_fl)
                                {
                                    NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                                    any_fl = false;
                                }
                                ((CiscoNatCustomData)cpNatRule.VendorCustomData).IsNonNatSectionRule = true;
                            }
                            else
                            {
                                cpNatRule.Destination = GetCheckPointObjectOrCreateDummy(CiscoCommand.InterfacePrefix + ciscoNat.MappedInterface + "_subnets",
                                                                                         CheckPointDummyObjectType.NetworkGroup,
                                                                                         ciscoNat,
                                                                                         "Error creating a NAT rule, missing topology information for Cisco interface",
                                                                                         "Interface details: " + ciscoNat.MappedInterface + ".");
                            }
                        }
                    }
                }

                // Service
                if (!string.IsNullOrEmpty(ciscoNat.ServiceId))
                {
                    cpNatRule.Service = GetCheckPointObjectOrCreateDummy(ciscoNat.ServiceId,
                                                                         CheckPointDummyObjectType.ServiceGroup,
                                                                         ciscoNat,
                                                                         "Error creating a NAT rule, missing information for Cisco service",
                                                                         "Service details: " + ciscoNat.ServiceId + ".");
                }

                // Translated source
                if (ciscoNat.IsHideBehindInterface)
                {
                    cpNatRule.TranslatedSource = GetCheckPointObjectOrCreateDummy(CiscoCommand.InterfacePrefix + ciscoNat.MappedInterface + "_address",
                                                                                  CheckPointDummyObjectType.Host,
                                                                                  ciscoNat,
                                                                                  "Error creating a NAT rule, missing topology information for Cisco interface",
                                                                                  "Interface details: " + ciscoNat.MappedInterface + ".");
                }
                else if (ciscoNat.SourceId != ciscoNat.TranslatedSourceId && ciscoNat.TranslatedSourceId != CiscoCommand.Any)
                {
                    cpNatRule.TranslatedSource = GetCheckPointObjectOrCreateDummy(ciscoNat.TranslatedSourceId,
                                                                                  CheckPointDummyObjectType.Host,
                                                                                  ciscoNat,
                                                                                  "Error creating a NAT rule, missing information for Cisco translated source",
                                                                                  "Translated source details: " + ciscoNat.TranslatedSourceId + ".");
                }

                // Translated destination for Twice NAT only
                if (ciscoNat.DestinationId != ciscoNat.TranslatedDestinationId && ciscoNat.TranslatedDestinationId != CiscoCommand.Any)
                {
                    cpNatRule.TranslatedDestination = GetCheckPointObjectOrCreateDummy(ciscoNat.TranslatedDestinationId,
                                                                                       CheckPointDummyObjectType.Host,
                                                                                       ciscoNat,
                                                                                       "Error creating a NAT rule, missing information for Cisco translated destination",
                                                                                       "Translated destination details: " + ciscoNat.TranslatedDestinationId + ".");
                }

                // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                // If NAT source/destination/translated source/translated destination is a group object and there is only one member in the group,
                // then use object rather than group.
                // In case of NAT translated source/translated destination we should create an error host object because group cannot be used here!!!
                if (cpNatRule.Source != null && cpNatRule.Source.GetType() == typeof(CheckPoint_NetworkGroup))
                {
                    cpNatRule.Source = GetCheckPointObjectOrCreateDummyFromNetworkGroupWithSingleMember((CheckPoint_NetworkGroup)cpNatRule.Source, ciscoNat, false);
                }
                if (cpNatRule.Destination != null && cpNatRule.Destination.GetType() == typeof(CheckPoint_NetworkGroup))
                {
                    cpNatRule.Destination = GetCheckPointObjectOrCreateDummyFromNetworkGroupWithSingleMember((CheckPoint_NetworkGroup)cpNatRule.Destination, ciscoNat, false);
                }
                if (cpNatRule.TranslatedSource != null && cpNatRule.TranslatedSource.GetType() == typeof(CheckPoint_NetworkGroup))
                {
                    cpNatRule.TranslatedSource = GetCheckPointObjectOrCreateDummyFromNetworkGroupWithSingleMember((CheckPoint_NetworkGroup)cpNatRule.TranslatedSource, ciscoNat);
                }
                if (cpNatRule.TranslatedDestination != null && cpNatRule.TranslatedDestination.GetType() == typeof(CheckPoint_NetworkGroup))
                {
                    cpNatRule.TranslatedDestination = GetCheckPointObjectOrCreateDummyFromNetworkGroupWithSingleMember((CheckPoint_NetworkGroup)cpNatRule.TranslatedDestination, ciscoNat);
                }
                // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

                // Translated Service
                if (ciscoNat.ServiceId != ciscoNat.TranslatedServiceId)
                {
                    cpNatRule.TranslatedService = GetCheckPointObjectOrCreateDummy(ciscoNat.TranslatedServiceId,
                                                                                   CheckPointDummyObjectType.ServiceGroup,
                                                                                   ciscoNat,
                                                                                   "Error creating a NAT rule, missing information for Cisco  translated service",
                                                                                   "Translated service details: " + ciscoNat.TranslatedServiceId + ".");
                }

                // Static NAT: if a source is a network or a network group and a translated source is a host,
                // we should convert to dynamic NAT rule!!!
                if (cpNatRule.Method == CheckPoint_NAT_Rule.NatMethod.Static)
                {
                    if ((cpNatRule.Source.GetType() == typeof(CheckPoint_Network) || cpNatRule.Source.GetType() == typeof(CheckPoint_NetworkGroup)) &&
                        cpNatRule.TranslatedSource != null && cpNatRule.TranslatedSource.GetType() == typeof(CheckPoint_Host))
                    {
                        cpNatRule.Method = CheckPoint_NAT_Rule.NatMethod.Hide;
                        ciscoNat.IsStatic = false;
                    }
                }

                PostProcessNatRule64(cpNatRule);
                PostProcessNatRule46(cpNatRule);
                _cpPreorderedNatRules.Add(cpNatRule);

                bool natRuleObjectHasConversionIncident = (cpNatRule.Source != null && cpNatRule.Source.ConversionIncidentType != ConversionIncidentType.None) ||
                                                          (cpNatRule.TranslatedSource != null && cpNatRule.TranslatedSource.ConversionIncidentType != ConversionIncidentType.None) ||
                                                          (cpNatRule.Destination != null && cpNatRule.Destination.ConversionIncidentType != ConversionIncidentType.None) ||
                                                          (cpNatRule.TranslatedDestination != null && cpNatRule.TranslatedDestination.ConversionIncidentType != ConversionIncidentType.None) ||
                                                          (cpNatRule.Service != null && cpNatRule.Service.ConversionIncidentType != ConversionIncidentType.None) ||
                                                          (cpNatRule.TranslatedService != null && cpNatRule.TranslatedService.ConversionIncidentType != ConversionIncidentType.None);

                if (cpNatRule.ConversionIncidentType != ConversionIncidentType.None ||
                    ciscoNat.ConversionIncidentType != ConversionIncidentType.None ||
                    natRuleObjectHasConversionIncident)
                {
                    _hasNATConversionIncident = true;
                }

                // Mirrored NAT rule for Static NAT
                if (ciscoNat.IsStatic && !ciscoNat.IsUnidirectional)
                {
                    var cpNatMirrorRule = new CheckPoint_NAT_Rule();
                    cpNatMirrorRule.Enabled = cpNatRule.Enabled;
                    cpNatMirrorRule.Method = CheckPoint_NAT_Rule.NatMethod.Static;

                    if (((CiscoNatCustomData)cpNatRule.VendorCustomData).IsNonNatRule)
                    {
                        cpNatMirrorRule.Source = cpNatRule.Destination;
                        cpNatMirrorRule.Destination = cpNatRule.Source;
                    }
                    else
                    {
                        cpNatMirrorRule.Source = cpNatRule.TranslatedDestination ?? cpNatRule.Destination;
                        if (cpNatMirrorRule.Source.Name.Equals("Any") && !cpNatRule.Source.Name.Equals("Any"))
                        {
                            NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnySourceCount++;
                            if (any_fl)
                            {
                                NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount++;
                                any_fl = false;
                            }
                        }

                        cpNatMirrorRule.Destination = cpNatRule.TranslatedSource ?? cpNatRule.Source;
                        if (!string.IsNullOrEmpty(ciscoNat.DestinationId))
                        {
                            cpNatMirrorRule.TranslatedSource = cpNatRule.Destination;
                        }
                        if (ciscoNat.SourceId != ciscoNat.TranslatedSourceId)
                        {
                            cpNatMirrorRule.TranslatedDestination = cpNatRule.Source;
                        }

                        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                        // Network group cannot be used as NAT translated source/destination!!!
                        // Remediation:
                        // if only one member object in group, then use object rather than group,
                        // otherwise create an error host object.
                        if (cpNatMirrorRule.TranslatedSource != null && cpNatMirrorRule.TranslatedSource.GetType() == typeof(CheckPoint_NetworkGroup))
                        {
                            cpNatMirrorRule.TranslatedSource = GetCheckPointObjectOrCreateDummyFromNetworkGroupWithSingleMember((CheckPoint_NetworkGroup)cpNatMirrorRule.TranslatedSource, ciscoNat);
                        }
                        if (cpNatMirrorRule.TranslatedDestination != null && cpNatMirrorRule.TranslatedDestination.GetType() == typeof(CheckPoint_NetworkGroup))
                        {
                            cpNatMirrorRule.TranslatedDestination = GetCheckPointObjectOrCreateDummyFromNetworkGroupWithSingleMember((CheckPoint_NetworkGroup)cpNatMirrorRule.TranslatedDestination, ciscoNat);
                        }
                        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                    }

                    cpNatMirrorRule.Service = cpNatRule.TranslatedService ?? cpNatRule.Service;
                    cpNatMirrorRule.TranslatedService = (cpNatRule.TranslatedService != null) ? cpNatRule.Service : cpNatRule.TranslatedService;
                    cpNatMirrorRule.Comments = string.Format("Mirror rule for {0}", ciscoNat.Id);

                    cpNatMirrorRule.VendorCustomData = new CiscoNatCustomData();
                    ((CiscoNatCustomData)cpNatMirrorRule.VendorCustomData).Interface1 = ciscoNat.MappedInterface;
                    ((CiscoNatCustomData)cpNatMirrorRule.VendorCustomData).Interface2 = ciscoNat.RealInterface;
                    ((CiscoNatCustomData)cpNatMirrorRule.VendorCustomData).IsStaticMirrorRule = true;
                    ((CiscoNatCustomData)cpNatMirrorRule.VendorCustomData).IsNonNatSectionRule = ((CiscoNatCustomData)cpNatRule.VendorCustomData).IsNonNatSectionRule;
                    ((CiscoNatCustomData)cpNatMirrorRule.VendorCustomData).IsAutoAfterSectionRule = ((CiscoNatCustomData)cpNatRule.VendorCustomData).IsAutoAfterSectionRule;

                    _cpPreorderedNatRules.Add(cpNatMirrorRule);

                    if (cpNatMirrorRule.ConversionIncidentType != ConversionIncidentType.None ||
                        ciscoNat.ConversionIncidentType != ConversionIncidentType.None)
                    {
                        _hasNATConversionIncident = true;
                    }
                }
            }
        }

        private void Add_IP_as_Host(int ciscoCommandId, string sIp)
        {
            // The order of this condition check is important!!!
            if (string.IsNullOrEmpty(sIp) || _cpObjects.HasObject(sIp) || !NetworkUtils.IsValidIp(sIp))
            {
                return;
            }

            var network = new CiscoNetwork(ciscoCommandId, sIp);

            var cpHost = new CheckPoint_Host();
            cpHost.Name = network.AutoGeneratedName();
            cpHost.IpAddress = network.IpAddress;
            cpHost.ConvertedCommandId = ciscoCommandId;
            AddCheckPointObject(cpHost);
        }

        private void CreateNATRulebase()
        {
            var section1 = new List<CheckPoint_NAT_Rule>();
            var section2Static = new List<CheckPoint_NAT_Rule>();
            var section2Dynamic = new List<CheckPoint_NAT_Rule>();
            var section3 = new List<CheckPoint_NAT_Rule>();
            var section5 = new List<CheckPoint_NAT_Rule>();
            var section6Static = new List<CheckPoint_NAT_Rule>();
            var section6Dynamic = new List<CheckPoint_NAT_Rule>();
            var section7 = new List<CheckPoint_NAT_Rule>();

            // Create the NAT sections
            foreach (var cpNatRule in _cpPreorderedNatRules)
            {
                var ciscoNatCustomData = ((CiscoNatCustomData)cpNatRule.VendorCustomData);

                // Create section #1:
                // Manual and twice NAT rules --> no Non-NAT and no auto-after and no object-NAT
                if (!ciscoNatCustomData.IsNonNatSectionRule && !ciscoNatCustomData.IsAutoAfterSectionRule && !ciscoNatCustomData.IsObjectNatRule)
                {
                    section1.Add(cpNatRule);
                }

                // Create section #2.1:
                // Object NAT rules - static --> no Non-NAT and no auto-after
                if (!ciscoNatCustomData.IsNonNatSectionRule && !ciscoNatCustomData.IsAutoAfterSectionRule && ciscoNatCustomData.IsObjectNatRule && cpNatRule.Method == CheckPoint_NAT_Rule.NatMethod.Static)
                {
                    section2Static.Add(cpNatRule);
                }

                // Create section #2.2:
                // Object NAT rules - dynamic --> no Non-NAT and no auto-after
                if (!ciscoNatCustomData.IsNonNatSectionRule && !ciscoNatCustomData.IsAutoAfterSectionRule && ciscoNatCustomData.IsObjectNatRule && cpNatRule.Method == CheckPoint_NAT_Rule.NatMethod.Hide)
                {
                    section2Dynamic.Add(cpNatRule);
                }

                // Create section #3:
                // Auto-After manual and twice NAT rules --> no Non-NAT and no object-NAT
                if (!ciscoNatCustomData.IsNonNatSectionRule && ciscoNatCustomData.IsAutoAfterSectionRule && !ciscoNatCustomData.IsObjectNatRule)
                {
                    section3.Add(cpNatRule);
                }

                // Create section #5:
                // Non-NAT manual and twice NAT rules --> no auto-after and no object-NAT
                if (ciscoNatCustomData.IsNonNatSectionRule && !ciscoNatCustomData.IsAutoAfterSectionRule && !ciscoNatCustomData.IsObjectNatRule)
                {
                    section5.Add(cpNatRule);
                }

                // Create section #6.1:
                // Non-NAT object NAT rules - static --> no auto-after
                if (ciscoNatCustomData.IsNonNatSectionRule && !ciscoNatCustomData.IsAutoAfterSectionRule && ciscoNatCustomData.IsObjectNatRule && cpNatRule.Method == CheckPoint_NAT_Rule.NatMethod.Static)
                {
                    section6Static.Add(cpNatRule);
                }

                // Create section #6.2:
                // Non-NAT object NAT rules - dynamic --> no auto-after
                if (ciscoNatCustomData.IsNonNatSectionRule && !ciscoNatCustomData.IsAutoAfterSectionRule && ciscoNatCustomData.IsObjectNatRule && cpNatRule.Method == CheckPoint_NAT_Rule.NatMethod.Hide)
                {
                    section6Dynamic.Add(cpNatRule);
                }

                // Create section #7:
                // Non-NAT auto-After manual and twice NAT rules --> no object-NAT
                if (ciscoNatCustomData.IsNonNatSectionRule && ciscoNatCustomData.IsAutoAfterSectionRule && !ciscoNatCustomData.IsObjectNatRule)
                {
                    section7.Add(cpNatRule);
                }
            }

            // Create the NAT Rulebase
            _cpNatRules.AddRange(section1);
            _cpNatRules.AddRange(section2Static);
            _cpNatRules.AddRange(section2Dynamic);
            _cpNatRules.AddRange(section3);

            // Do we need Non-NAT sections?
            if (section5.Any() || section6Static.Any() || section6Dynamic.Any() || section7.Any())
            {
                // Create section #4:
                // A single Non-NATs top rule
                var section4 = new CheckPoint_NAT_Rule();
                section4.Comments = "Auto-generated rule above interfaces that lead to the internet";
                section4.Method = CheckPoint_NAT_Rule.NatMethod.Static;
                section4.Source = _cpObjects.GetObject(AllInternalNetwotkGroupName);
                section4.Destination = _cpObjects.GetObject(AllInternalNetwotkGroupName);
                _cpNatRules.Add(section4);

                _cpNatRules.AddRange(section5);
                _cpNatRules.AddRange(section6Static);
                _cpNatRules.AddRange(section6Dynamic);
                _cpNatRules.AddRange(section7);
            }
        }

        public class CheckPoint_Rule_With_SubPoliciesIndex
        {
            public int SubPoliciesIndex;
            public CheckPoint_Rule CheckPoint_Rule;

            public CheckPoint_Rule_With_SubPoliciesIndex(int SubPoliciesIndex, CheckPoint_Rule CheckPoint_Rule)
            {
                this.SubPoliciesIndex = SubPoliciesIndex;
                this.CheckPoint_Rule = CheckPoint_Rule;
            }
        }
        private void MatchNATRulesIntoFirewallPolicy()
        {
            CheckPoint_Package cpPackage = _cpPackages[0];
            int index = 0;

            List<CheckPoint_Rule_With_SubPoliciesIndex> newRules = new List<CheckPoint_Rule_With_SubPoliciesIndex>();

            List<Thread> threads = new List<Thread>();


            foreach (CheckPoint_NAT_Rule cpNatRule in _cpNatRules)
            {
                void SubMatchNATRulesIntoFirewallPolicy()
                {

                    if (!cpNatRule.Enabled)
                    {
                        return;
                    }

                    var ciscoNatCustomData = ((CiscoNatCustomData)cpNatRule.VendorCustomData);

                    // For example, NAT section #4 rule...
                    if (cpNatRule.TranslatedSource == null && cpNatRule.TranslatedDestination == null)
                    {
                        return;
                    }

                    // Skip dynamic object-NAT rules
                    if (ciscoNatCustomData.IsObjectNatRule && cpNatRule.Method == CheckPoint_NAT_Rule.NatMethod.Hide)
                    {
                        return;
                    }

                    // Skip dynamic manual-NAT rules
                    if (!ciscoNatCustomData.IsObjectNatRule && cpNatRule.Method == CheckPoint_NAT_Rule.NatMethod.Hide && cpNatRule.TranslatedDestination == null)
                    {
                        return;
                    }

                    // Skip static NAT mirrored rules
                    if (ciscoNatCustomData.IsStaticMirrorRule)
                    {
                        return;
                    }

                    // Skip Non-NAT rules (only twice-NAT: SourceId == TranslatedSourceId && DestinationId == TranslatedDestinationId)
                    if (ciscoNatCustomData.IsNonNatRule)
                    {
                        return;
                    }

                    string natRuleInterface1 = (ciscoNatCustomData.Interface1 != CiscoCommand.Any) ? (CiscoCommand.InterfacePrefix + ciscoNatCustomData.Interface1) : ciscoNatCustomData.Interface1;
                    string natRuleInterface2 = (ciscoNatCustomData.Interface2 != CiscoCommand.Any) ? (CiscoCommand.InterfacePrefix + ciscoNatCustomData.Interface2) : ciscoNatCustomData.Interface2;

                    foreach (CheckPoint_Rule cpParentRule in cpPackage.ParentLayer.Rules)
                    {
                        if (cpParentRule.Action != CheckPoint_Rule.ActionType.SubPolicy)
                        {
                            continue;
                        }

                        if (cpParentRule.Source[0] is CheckPoint_PredifinedObject && cpParentRule.Source[0].Name.Equals(CheckPointObject.Any))
                        {
                            if (cpParentRule.SubPolicyName != GlobalRulesSubpolicyName)
                            {
                                continue;
                            }
                        }

                        CheckPoint_Zone parentLayerRuleZone = new CheckPoint_Zone();
                        if (cpParentRule.SubPolicyName == GlobalRulesSubpolicyName)
                        {
                            parentLayerRuleZone.Name = "any";
                        }
                        else
                        {
                            parentLayerRuleZone = (CheckPoint_Zone)cpParentRule.Source[0];
                        }

                        // NAT rule interfaces should match on firewall rule interfaces (zones)
                        if (natRuleInterface1 != CiscoCommand.Any && natRuleInterface1 != parentLayerRuleZone.Name &&
                            natRuleInterface2 != CiscoCommand.Any && natRuleInterface2 != parentLayerRuleZone.Name)
                        {
                            continue;
                        }
                        int SubPoliciesIndex = -1;
                        // Get into the relevant sub-policy
                        foreach (CheckPoint_Layer subPolicy in cpPackage.SubPolicies)
                        {
                            SubPoliciesIndex++;
                            if (subPolicy.Name != cpParentRule.SubPolicyName)
                            {
                                continue;
                            }

                            for (int ruleNumber = 0; ruleNumber < subPolicy.Rules.Count; ruleNumber++)
                            {
                                var cpRule = subPolicy.Rules[ruleNumber];

                                // Do not match on cleanup rule
                                if (cpRule.IsCleanupRule())
                                {
                                    continue;
                                }

                                // Do not match if rule's destination is 'any'
                                if (cpRule.Destination.Count == 1)
                                {
                                    string destinationName = cpRule.Destination[0].Name;
                                    if (destinationName == CheckPointObject.Any)
                                    {
                                        continue;
                                    }

                                    if (destinationName.StartsWith(CiscoCommand.InterfacePrefix))
                                    {
                                        // get Cisco interface object
                                        var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(destinationName);
                                        if (ciscoInterface != null && (ciscoInterface.LeadsToInternet || ciscoInterface.SecurityLevel == 0))
                                        {
                                            continue;
                                        }
                                    }
                                }

                                CheckPointObject newRuleDest = null;
                                bool serviceMatchedToo = false;

                                //dont't check added matched NAT rules
                                if (!cpRule.ConversionComments.StartsWith("Matched NAT rule") && IsFirewallRuleMatchedByNATRule(parentLayerRuleZone, cpNatRule, cpRule, out newRuleDest, out serviceMatchedToo))
                                {
                                    string translatedSourceName = (cpNatRule.TranslatedSource != null) ? cpNatRule.TranslatedSource.Name : "original";
                                    string translatedDestName = (cpNatRule.TranslatedDestination != null) ? cpNatRule.TranslatedDestination.Name : "original";
                                    string translatedServiceName = (cpNatRule.TranslatedService != null) ?
                                                                   cpNatRule.TranslatedService.Name : (cpNatRule.Service != null ? cpNatRule.Service.Name : "");

                                    var newRule = new CheckPoint_Rule();

                                    newRule.Enabled = cpRule.Enabled;
                                    //if (!cpRule.Enabled)
                                    //{
                                    //    NewCiscoAnalizStatistic._disabledServicesRulesCount++;
                                    //}

                                    if (!cpRule.Track.Equals(TrackTypes.Log))
                                    {
                                        NewCiscoAnalizStatistic._nonServicesLoggingServicesRulesCount++;
                                    }
                                    newRule.Source.AddRange(cpRule.Source);
                                    newRule.Destination.Add(newRuleDest);
                                    if (serviceMatchedToo)
                                    {
                                        newRule.Service.Add(_cpObjects.GetObject(translatedServiceName));
                                    }
                                    else
                                    {
                                        newRule.Service.AddRange(cpRule.Service);
                                    }
                                    newRule.Time.AddRange(cpRule.Time);
                                    if (cpRule.Time.Count > 0 && !cpRule.Time.First().Name.Equals("Any"))
                                    {
                                        NewCiscoAnalizStatistic._timesServicesRulesCount++;
                                    }
                                    newRule.Action = cpRule.Action;
                                    newRule.Layer = subPolicy.Name;
                                    newRule.ConvertedCommandId = cpNatRule.ConvertedCommandId;
                                    newRule.ConversionIncidentType = (cpRule.ConversionIncidentType != ConversionIncidentType.None) ? cpRule.ConversionIncidentType : cpNatRule.ConversionIncidentType;
                                    if (serviceMatchedToo)
                                    {
                                        translatedServiceName = (cpNatRule.TranslatedService != null) ? cpNatRule.TranslatedService.Name : "original";
                                        newRule.ConversionComments = "Matched NAT rule ((" + cpNatRule.ConvertedCommandId + ") translated source: " + translatedSourceName + ", translated dest: " + translatedDestName + ", translated service: " + translatedServiceName + ")";
                                    }
                                    else
                                    {
                                        newRule.ConversionComments = "Matched NAT rule ((" + cpNatRule.ConvertedCommandId + ") translated source: " + translatedSourceName + ", translated dest: " + translatedDestName + ")";
                                    }

                                    //don't add duplicated rules
                                    bool ruleIsAlreadyAdded = false;
                                    foreach (var rule in subPolicy.Rules)
                                    {
                                        if (newRule.CompareTo(rule))
                                        {
                                            ruleIsAlreadyAdded = true;
                                            break;
                                        }
                                    }

                                    // Add a new rule ABOVE the matched rule.
                                    if (!ruleIsAlreadyAdded)
                                    {
                                        //subPolicy.Rules.Insert(ruleNumber, newRule);
                                        newRules.Add(new CheckPoint_Rule_With_SubPoliciesIndex(SubPoliciesIndex: SubPoliciesIndex, CheckPoint_Rule: newRule));
                                    }

                                    if (newRule.ConversionIncidentType != ConversionIncidentType.None)
                                    {
                                        cpPackage.ConversionIncidentType = ConversionIncidentType.Informative;
                                    }

                                    // If NAT rule's service is "any" (null), we need to keep matching for all relevant FW rules.
                                    if (serviceMatchedToo)
                                    {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
                if (index % 100 == 0)
                {
                    foreach (Thread t in threads)
                    {
                        if (t.IsAlive)
                            t.Join();
                    }
                }
                index++;
                Thread thread = new Thread(SubMatchNATRulesIntoFirewallPolicy);
                threads.Add(thread);
                thread.Start();
            }
            foreach (Thread t in threads)
            {
                if (t.IsAlive) t.Join();
            }

            //remove duplicates
            for (int ruleNumber = 0; ruleNumber < newRules.Count; ruleNumber++)
            {
                for (int ruleNumber2 = 0; ruleNumber2 < newRules.Count; ruleNumber2++)
                {
                    if (newRules[ruleNumber].CheckPoint_Rule.CompareTo(newRules[ruleNumber2].CheckPoint_Rule) && ruleNumber != ruleNumber2 && newRules[ruleNumber].SubPoliciesIndex == newRules[ruleNumber2].SubPoliciesIndex)
                    {

                        newRules.Remove(newRules[ruleNumber2]);
                    }
                }
            }
            foreach (CheckPoint_Rule_With_SubPoliciesIndex rule in newRules)
            {
                cpPackage.SubPolicies[rule.SubPoliciesIndex].Rules.Add(rule.CheckPoint_Rule);
            }

        }

        ///if have some problem with MatchNATRulesIntoFirewallPolicy, then remove current MatchNATRulesIntoFirewallPolicy and uncomment old MatchNATRulesIntoFirewallPolicy
        /*
       private void MatchNATRulesIntoFirewallPolicy()
        {
            CheckPoint_Package cpPackage = _cpPackages[0];

            foreach (CheckPoint_NAT_Rule cpNatRule in _cpNatRules)
            {
                if (!cpNatRule.Enabled)
                {
                    continue;
                }

                var ciscoNatCustomData = ((CiscoNatCustomData)cpNatRule.VendorCustomData);

                // For example, NAT section #4 rule...
                if (cpNatRule.TranslatedSource == null && cpNatRule.TranslatedDestination == null)
                {
                    continue;
                }

                // Skip dynamic object-NAT rules
                if (ciscoNatCustomData.IsObjectNatRule && cpNatRule.Method == CheckPoint_NAT_Rule.NatMethod.Hide)
                {
                    continue;
                }

                // Skip dynamic manual-NAT rules
                if (!ciscoNatCustomData.IsObjectNatRule && cpNatRule.Method == CheckPoint_NAT_Rule.NatMethod.Hide && cpNatRule.TranslatedDestination == null)
                {
                    continue;
                }

                // Skip static NAT mirrored rules
                if (ciscoNatCustomData.IsStaticMirrorRule)
                {
                    continue;
                }

                // Skip Non-NAT rules (only twice-NAT: SourceId == TranslatedSourceId && DestinationId == TranslatedDestinationId)
                if (ciscoNatCustomData.IsNonNatRule)
                {
                    continue;
                }

                string natRuleInterface1 = (ciscoNatCustomData.Interface1 != CiscoCommand.Any) ? (CiscoCommand.InterfacePrefix + ciscoNatCustomData.Interface1) : ciscoNatCustomData.Interface1;
                string natRuleInterface2 = (ciscoNatCustomData.Interface2 != CiscoCommand.Any) ? (CiscoCommand.InterfacePrefix + ciscoNatCustomData.Interface2) : ciscoNatCustomData.Interface2;

                foreach (CheckPoint_Rule cpParentRule in cpPackage.ParentLayer.Rules)
                {
                    if (cpParentRule.Action != CheckPoint_Rule.ActionType.SubPolicy)
                    {
                        continue;
                    }

                    if (cpParentRule.Source[0] is CheckPoint_PredifinedObject && cpParentRule.Source[0].Name.Equals(CheckPointObject.Any))
                    {
                        if (cpParentRule.SubPolicyName != GlobalRulesSubpolicyName)
                        {
                            continue;
                        }
                    }

                    CheckPoint_Zone parentLayerRuleZone = new CheckPoint_Zone();
                    if (cpParentRule.SubPolicyName == GlobalRulesSubpolicyName)
                    {
                        parentLayerRuleZone.Name = "any";
                    }
                    else
                    {
                        parentLayerRuleZone = (CheckPoint_Zone)cpParentRule.Source[0];
                    }

                    // NAT rule interfaces should match on firewall rule interfaces (zones)
                    if (natRuleInterface1 != CiscoCommand.Any && natRuleInterface1 != parentLayerRuleZone.Name &&
                        natRuleInterface2 != CiscoCommand.Any && natRuleInterface2 != parentLayerRuleZone.Name)
                    {
                        continue;
                    }

                    // Get into the relevant sub-policy
                    foreach (CheckPoint_Layer subPolicy in cpPackage.SubPolicies)
                    {
                        if (subPolicy.Name != cpParentRule.SubPolicyName)
                        {
                            continue;
                        }

                        for (int ruleNumber = 0; ruleNumber < subPolicy.Rules.Count; ruleNumber++)
                        {
                            var cpRule = subPolicy.Rules[ruleNumber];

                            // Do not match on cleanup rule
                            if (cpRule.IsCleanupRule())
                            {
                                continue;
                            }

                            // Do not match if rule's destination is 'any'
                            if (cpRule.Destination.Count == 1)
                            {
                                string destinationName = cpRule.Destination[0].Name;
                                if (destinationName == CheckPointObject.Any)
                                {
                                    continue;
                                }

                                if (destinationName.StartsWith(CiscoCommand.InterfacePrefix))
                                {
                                    // get Cisco interface object
                                    var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(destinationName);
                                    if (ciscoInterface != null && (ciscoInterface.LeadsToInternet || ciscoInterface.SecurityLevel == 0))
                                    {
                                        continue;
                                    }
                                }
                            }

                            CheckPointObject newRuleDest = null;
                            bool serviceMatchedToo = false;

                            //dont't check added matched NAT rules
                            if (!cpRule.ConversionComments.StartsWith("Matched NAT rule") && IsFirewallRuleMatchedByNATRule(parentLayerRuleZone, cpNatRule, cpRule, out newRuleDest, out serviceMatchedToo))
                            {
                                string translatedSourceName = (cpNatRule.TranslatedSource != null) ? cpNatRule.TranslatedSource.Name : "original";
                                string translatedDestName = (cpNatRule.TranslatedDestination != null) ? cpNatRule.TranslatedDestination.Name : "original";
                                string translatedServiceName = (cpNatRule.TranslatedService != null) ?
                                                               cpNatRule.TranslatedService.Name : (cpNatRule.Service != null ? cpNatRule.Service.Name : "");

                                var newRule = new CheckPoint_Rule();

                                newRule.Enabled = cpRule.Enabled;
                                //if (!cpRule.Enabled)
                                //{
                                //    NewCiscoAnalizStatistic._disabledServicesRulesCount++;
                                //}

                                if (!cpRule.Track.Equals(TrackTypes.Log))
                                {
                                    NewCiscoAnalizStatistic._nonServicesLoggingServicesRulesCount++;
                                }
                                newRule.Source.AddRange(cpRule.Source);
                                newRule.Destination.Add(newRuleDest);
                                if (serviceMatchedToo)
                                {
                                    newRule.Service.Add(_cpObjects.GetObject(translatedServiceName));
                                }
                                else
                                {
                                    newRule.Service.AddRange(cpRule.Service);
                                }
                                newRule.Time.AddRange(cpRule.Time);
                                if(cpRule.Time.Count > 0 && !cpRule.Time.First().Name.Equals("Any"))
                                {
                                    NewCiscoAnalizStatistic._timesServicesRulesCount++;
                                }
                                newRule.Action = cpRule.Action;
                                newRule.Layer = subPolicy.Name;
                                newRule.ConvertedCommandId = cpNatRule.ConvertedCommandId;
                                newRule.ConversionIncidentType = (cpRule.ConversionIncidentType != ConversionIncidentType.None) ? cpRule.ConversionIncidentType : cpNatRule.ConversionIncidentType;
                                if (serviceMatchedToo)
                                {
                                    translatedServiceName = (cpNatRule.TranslatedService != null) ? cpNatRule.TranslatedService.Name : "original";
                                    newRule.ConversionComments = "Matched NAT rule ((" + cpNatRule.ConvertedCommandId + ") translated source: " + translatedSourceName + ", translated dest: " + translatedDestName + ", translated service: " + translatedServiceName + ")";
                                }
                                else
                                {
                                    newRule.ConversionComments = "Matched NAT rule ((" + cpNatRule.ConvertedCommandId + ") translated source: " + translatedSourceName + ", translated dest: " + translatedDestName + ")";
                                }

                                //don't add duplicated rules
                                bool ruleIsAlreadyAdded = false;
                                foreach (var rule in subPolicy.Rules)
                                {
                                    if (newRule.CompareTo(rule))
                                    {
                                        ruleIsAlreadyAdded = true;
                                    }
                                }

                                // Add a new rule ABOVE the matched rule.
                                if (!ruleIsAlreadyAdded)
                                {
                                    subPolicy.Rules.Insert(ruleNumber, newRule);
                                }

                                if (newRule.ConversionIncidentType != ConversionIncidentType.None)
                                {
                                    cpPackage.ConversionIncidentType = ConversionIncidentType.Informative;
                                }

                                // If NAT rule's service is "any" (null), we need to keep matching for all relevant FW rules.
                                if (serviceMatchedToo)
                                {
                                    break;
                                }
                                else
                                {
                                    ++ruleNumber;   // this is because we are changing the collection during iteration!!!
                                }
                            }
                        }
                    }
                }
            }
        }
        */



        /// <summary>
        /// !!! This method's logic follows the instructions from the "NAT rules matching FlowChart.vsd" document !!!
        /// </summary>
        private bool IsFirewallRuleMatchedByNATRule(CheckPoint_Zone parentLayerRuleZone, CheckPoint_NAT_Rule natRule, CheckPoint_Rule fwRule, out CheckPointObject newFwRuleDest, out bool serviceMatchedToo)
        {
            newFwRuleDest = null;
            serviceMatchedToo = false;

            var ciscoNatCustomData = ((CiscoNatCustomData)natRule.VendorCustomData);

            // If NAT rule interface is "any", it should match on EVERY firewall rule interface (zone)
            string natRuleInterface1 = (ciscoNatCustomData.Interface1 != CiscoCommand.Any) ? (CiscoCommand.InterfacePrefix + ciscoNatCustomData.Interface1) : parentLayerRuleZone.Name;
            string natRuleInterface2 = (ciscoNatCustomData.Interface2 != CiscoCommand.Any) ? (CiscoCommand.InterfacePrefix + ciscoNatCustomData.Interface2) : parentLayerRuleZone.Name;

            // Static NAT rule matching (no mirrors!!!)
            if (natRule.Method == CheckPoint_NAT_Rule.NatMethod.Static)
            {
                // Object-NAT rule matching
                if (ciscoNatCustomData.IsObjectNatRule)
                {
                    if (natRuleInterface2 == parentLayerRuleZone.Name)
                    {
                        var natSourceRanges = (natRule.Source != null) ? GetRanges(natRule.Source) : IPRanges.Any();
                        var fwRuleDestRanges = (fwRule.Destination.Count > 0) ? GetRanges(fwRule.Destination[0]) : IPRanges.Any();

                        if (fwRuleDestRanges.Overlaps(natSourceRanges))
                        {
                            newFwRuleDest = natRule.TranslatedSource ?? _cpObjects.GetObject(CheckPointObject.Any);
                        }
                    }
                }
                else   // Manual-NAT or Twice-NAT rule matching
                {
                    var natSourceRanges = (natRule.Source != null) ? GetRanges(natRule.Source) : IPRanges.Any();
                    var natDestRanges = (natRule.Destination != null) ? GetRanges(natRule.Destination) : IPRanges.Any();
                    var fwRuleSourceRanges = (fwRule.Source.Count > 0) ? GetRanges(fwRule.Source[0]) : IPRanges.Any();
                    var fwRuleDestRanges = (fwRule.Destination.Count > 0) ? GetRanges(fwRule.Destination[0]) : IPRanges.Any();

                    bool natSourceModified = (natRule.TranslatedSource != null);
                    bool natDestModified = (natRule.TranslatedDestination != null);   // Twice-NAT rule matching only!!!

                    if (natSourceModified && natDestModified)
                    {
                        var natTranslatedDestRanges = GetRanges(natRule.TranslatedDestination);

                        if (natRuleInterface2 == parentLayerRuleZone.Name)
                        {
                            if (fwRuleDestRanges.Overlaps(natSourceRanges) && fwRuleSourceRanges.Overlaps(natTranslatedDestRanges))
                            {
                                newFwRuleDest = natRule.TranslatedSource;
                            }
                        }

                        if (natRuleInterface1 == parentLayerRuleZone.Name)
                        {
                            var natTranslatedSourceRanges = GetRanges(natRule.TranslatedSource);

                            if (fwRuleDestRanges.Overlaps(natTranslatedDestRanges) && fwRuleSourceRanges.Overlaps(natTranslatedSourceRanges))
                            {
                                newFwRuleDest = natRule.Destination ?? _cpObjects.GetObject(CheckPointObject.Any);
                            }
                        }
                    }
                    else if (natSourceModified)
                    {
                        if (natRuleInterface2 == parentLayerRuleZone.Name)
                        {
                            if (fwRuleDestRanges.Overlaps(natSourceRanges) && fwRuleSourceRanges.Overlaps(natDestRanges))
                            {
                                newFwRuleDest = natRule.TranslatedSource;
                            }
                        }
                    }
                    else if (natDestModified)
                    {
                        if (natRuleInterface1 == parentLayerRuleZone.Name)
                        {
                            var natTranslatedDestRanges = GetRanges(natRule.TranslatedDestination);

                            if (fwRuleDestRanges.Overlaps(natTranslatedDestRanges) && fwRuleSourceRanges.Overlaps(natSourceRanges))
                            {
                                newFwRuleDest = natRule.Destination ?? _cpObjects.GetObject(CheckPointObject.Any);
                            }
                        }
                    }
                }
            }
            else   // Dynamic NAT rule matching (dynamic source and static dest)
            {
                bool natDestModified = (natRule.TranslatedDestination != null);   // Twice-NAT rule matching only!!!

                if (natDestModified)
                {
                    if (natRuleInterface1 == parentLayerRuleZone.Name)
                    {
                        var natSourceRanges = (natRule.Source != null) ? GetRanges(natRule.Source) : IPRanges.Any();
                        var natTranslatedDestRanges = GetRanges(natRule.TranslatedDestination);
                        var fwRuleSourceRanges = (fwRule.Source.Count > 0) ? GetRanges(fwRule.Source[0]) : IPRanges.Any();
                        var fwRuleDestRanges = (fwRule.Destination.Count > 0) ? GetRanges(fwRule.Destination[0]) : IPRanges.Any();

                        if (fwRuleDestRanges.Overlaps(natTranslatedDestRanges) && fwRuleSourceRanges.Overlaps(natSourceRanges))
                        {
                            newFwRuleDest = natRule.TranslatedDestination;
                        }
                    }
                }
            }

            // Match on service too...
            if (newFwRuleDest != null)
            {
                if (natRule.Service == null)
                {
                    // No NAT service at all
                    return true;
                }

                if (fwRule.Service.Count == 0) { }
                else if (fwRule.Service.Count == 1 && fwRule.Service[0].Name == CheckPointObject.Any)
                {
                    // There is only one service in FW rule and it is "any", no matter what NAT rule service is...
                    serviceMatchedToo = true;
                    return true;
                }
                else if (fwRule.Service.Any(fwService => natRule.Service.Name == fwService.Name ||
                         CheckPointServiceObjectsFactory.CheckServicesPortRangesOverlapping(natRule.Service, fwService)))
                {
                    // 1. service names match - NAT rule service appears in the list of FW rule's services
                    // 2. service port ranges match - NAT rule service should be a subset of FW rule's services
                    serviceMatchedToo = true;
                    return true;
                }
            }

            return false;
        }

        private IPRanges GetRanges(CheckPointObject cpObject)
        {
            if (cpObject == null || cpObject.Name == CheckPointObject.Any)
            {
                return new IPRanges(new IPRange(IPRange.Any));
            }

            if (cpObject.GetType().ToString().EndsWith("_NetworkGroup"))
            {
                return GetGroupRanges((CheckPoint_NetworkGroup)cpObject);
            }

            if (cpObject.GetType().ToString().EndsWith("_Zone"))
            {
                return GetZoneRanges((CheckPoint_Zone)cpObject);
            }

            if (cpObject.GetType().ToString().EndsWith("_Host"))
            {
                return ((CheckPoint_Host)cpObject).GetIPRanges();
            }

            if (cpObject.GetType().ToString().EndsWith("_Network"))
            {
                return ((CheckPoint_Network)cpObject).GetIPRanges();
            }

            if (cpObject.GetType().ToString().EndsWith("_Range"))
            {
                return ((CheckPoint_Range)cpObject).GetIPRanges();
            }

            return new IPRanges();
        }

        private IPRanges GetZoneRanges(CheckPoint_Zone cpZone)
        {
            // get Cisco interface object
            var ciscoInterface = (Cisco_Interface)_ciscoParser.GetCommandByCiscoId(cpZone.Name);
            if (ciscoInterface != null && (ciscoInterface.LeadsToInternet || ciscoInterface.SecurityLevel == 0))
            {
                return new IPRanges(new IPRange(IPRange.Any));
            }

            string ifcSubnetsName = cpZone.Name + "_subnets";
            var ifcGroupObject = _cpObjects.GetObject(ifcSubnetsName);
            if (ifcGroupObject != null)
            {
                if (ifcGroupObject.GetType().ToString().EndsWith("_NetworkGroup"))
                {
                    var ifcSubnets = (CheckPoint_NetworkGroup)ifcGroupObject;
                    return GetGroupRanges(ifcSubnets);
                }

                if (ifcGroupObject.GetType().ToString().EndsWith("_GroupWithExclusion"))
                {
                    var groupWithExclusion = (CheckPoint_GroupWithExclusion)ifcGroupObject;
                    var groupInclude = (CheckPoint_NetworkGroup)_cpObjects.GetObject(groupWithExclusion.Include);
                    var groupExcept = (CheckPoint_NetworkGroup)_cpObjects.GetObject(groupWithExclusion.Except);
                    return GetGroupWithExclusionRanges(groupInclude, groupExcept);
                }
            }

            return new IPRanges();
        }

        private void Add_Optimized_Package()
        {
            CheckPoint_Package regularPackage = _cpPackages[0];

            var optimizedPackage = new CheckPoint_Package();
            optimizedPackage.Name = _policyPackageOptimizedName;
            optimizedPackage.ParentLayer.Name = optimizedPackage.NameOfAccessLayer;
            optimizedPackage.ConversionIncidentType = regularPackage.ConversionIncidentType;

            var regular2OptimizedLayers = new Dictionary<string, string>();

            foreach (CheckPoint_Layer layer in regularPackage.SubPolicies)
            {
                string optimizedSubPolicyName = layer.Name + "_opt";
                
                CheckPoint_Layer optimizedLayer = RuleBaseOptimizer.Optimize(layer, optimizedSubPolicyName);
                foreach (CheckPoint_Rule subSubRule in optimizedLayer.Rules)
                {
                    if (subSubRule.SubPolicyName.Equals(GlobalRulesSubpolicyName))
                    {
                        //The Global sub-sub rule subpolicy name should also be renamed for consistency
                        subSubRule.SubPolicyName += "_opt";
                    }
                }
                if (!regular2OptimizedLayers.ContainsKey(layer.Name))
                {
                    regular2OptimizedLayers.Add(layer.Name, optimizedSubPolicyName);
                    optimizedPackage.SubPolicies.Add(optimizedLayer);
                    validatePackage(optimizedPackage);
                }
            }

            foreach (CheckPoint_Rule rule in regularPackage.ParentLayer.Rules)
            {
                CheckPoint_Rule newRule = rule.Clone();
                if (newRule.Action == CheckPoint_Rule.ActionType.SubPolicy)
                {
                    newRule.SubPolicyName = regular2OptimizedLayers[rule.SubPolicyName];
                }
                newRule.Layer = optimizedPackage.ParentLayer.Name;
                newRule.ConversionComments = rule.ConversionComments;

                optimizedPackage.ParentLayer.Rules.Add(newRule);
            }

            AddCheckPointObject(optimizedPackage);
        }

        private string BuildInspectedRuleInfo(string ciscoClassMapName)
        {
            string inspectTooltip = "Rule traffic is affected by Cisco inspect policy. [class-map objects: " + ciscoClassMapName + "]";
            string htmlInspectedImageTag = string.Format(HtmlAlertImageTagFormat, inspectTooltip);
            return htmlInspectedImageTag;
        }

        private string BuildInspectedRuleLinkTag(string ciscoClassMapName)
        {
            foreach (var ciscoCommand in CiscoClassMapCommands)
            {
                var ciscoClassMapCommand = (Cisco_ClassMap)ciscoCommand;
                if (ciscoClassMapCommand.ClassMapName == ciscoClassMapName)
                {
                    return string.Format("<a href=\"./{0}#line_{1}\" target=\"_blank\">{2}</a>", Path.GetFileName(VendorHtmlFile), ciscoClassMapCommand.Id, ciscoClassMapName);
                }
            }

            return ciscoClassMapName;
        }

        #endregion

        #region Public Methods

        public override void Initialize(VendorParser vendorParser, string vendorFilePath, string toolVersion, string targetFolder, string domainName, string outputFormat = "json")
        {
            _ciscoParser = (CiscoParser)vendorParser;
            if (_ciscoParser == null)
            {
                throw new InvalidDataException("Unexpected!!!");
            }
            this._outputFormat = outputFormat;

            base.Initialize(vendorParser, vendorFilePath, toolVersion, targetFolder, domainName, outputFormat);
        }

        public override float Analyze()
        {
            if (IsConsoleRunning)
                Progress = new ProgressBar();

            if (IsConsoleRunning)
            {
                Console.WriteLine("Analyzing objects ...");
                Progress.SetProgress(20);
                Thread.Sleep(1000);
            }
            RaiseConversionProgress(20, "Analyzing objects ...");
            _cpObjects.Initialize();   // must be first!!!

            foreach (var cpObject in _cpObjects.GetPredefinedObjects())
            {
                _duplicateNamesLookup.Add(cpObject.Name, new DuplicateNameInfo(true));
            }

            PopulateCiscoNetworkObjects();
            CheckCiscoInterfacesTraffic();
            CheckCiscoInterfacesAntiSpoofing();
            Add_Networks();
            Add_Objects();
            Add_NetworkGroups();
            Add_InterfacesAndRoutes();
            Add_Zones();
            Add_or_Modify_InterfaceNetworkGroups();
            Add_ServicesAndServiceGroups();
            Add_TimeRanges();

            if (IsConsoleRunning)
            {
                Console.WriteLine("Analyzing rules ...");
                Progress.SetProgress(30);
                Thread.Sleep(1000);
            }
            RaiseConversionProgress(30, "Analyzing rules ...");
            NewCiscoAnalizStatistic._Package = Add_Package();

            if (IsConsoleRunning)
            {
                Console.WriteLine("Analyzing NAT rules ...");
                Progress.SetProgress(40);
                Thread.Sleep(1000);
            }
            RaiseConversionProgress(40, "Analyzing NAT rules ...");
            Add_object_NAT();
            Add_NAT_Rules();

            if (IsConsoleRunning)
            {
                Console.WriteLine("Creating NAT rulebase ...");
                Progress.SetProgress(50);
                Thread.Sleep(1000);
            }
            RaiseConversionProgress(50, "Creating NAT rulebase ...");
            CreateNATRulebase();

            if (IsConsoleRunning)
            {
                Console.WriteLine("Creating Firewall rulebase ...");
                Progress.SetProgress(60);
                Thread.Sleep(1000);
            }
            RaiseConversionProgress(60, "Creating Firewall rulebase ...");
            MatchNATRulesIntoFirewallPolicy();

            // This should be done here, after all objects are converted!!!
            EnforceObjectNameValidity();

            ExportManagmentReport(false);

            if (IsConsoleRunning)
            {
                Console.WriteLine("Analyzing using of objects ...");
                Progress.SetProgress(65);
                Thread.Sleep(1000);
            }
            RaiseConversionProgress(65, "Analyzing using of objects ...");
            BuildListOfUsedObjects(true);

            if (IsConsoleRunning)
            {
                Console.WriteLine("Analyzing Firewall rulebase ...");
                Progress.SetProgress(70);
                Thread.Sleep(1000);
            }
            RaiseConversionProgress(70, "Analyzing Firewall rulebase ...");
            Add_Optimized_Package();

            //Unused objects
            if (IsConsoleRunning)
            {
                Console.WriteLine("Analyzing objects ...");
                Progress.SetProgress(90);
                Thread.Sleep(1000);
            }
            RaiseConversionProgress(90, "Analyzing objects ...");
            CollectOnlyUsedObjects();


            ExportManagmentReport(true);


            if (IsConsoleRunning)
            {
                Progress.SetProgress(100);
                Progress.Dispose();
            }
            return 0;
        }

        public override Dictionary<string, int> Convert(bool convertNat)
        {
            if (IsConsoleRunning)
                Progress = new ProgressBar();

            if (IsConsoleRunning)
            {
                Console.WriteLine("Converting objects ...");
                Progress.SetProgress(20);
                Thread.Sleep(1000);
            }
            RaiseConversionProgress(20, "Converting objects ...");
            _cpObjects.Initialize();   // must be first!!!

            foreach (var cpObject in _cpObjects.GetPredefinedObjects())
            {
                _duplicateNamesLookup.Add(cpObject.Name, new DuplicateNameInfo(true));
            }


            PopulateCiscoNetworkObjects();
            CheckCiscoInterfacesTraffic();
            CheckCiscoInterfacesAntiSpoofing();
            Add_Networks();
            Add_Objects();
            Add_NetworkGroups();
            Add_InterfacesAndRoutes();
            Add_Zones();
            Add_or_Modify_InterfaceNetworkGroups();
            Add_ServicesAndServiceGroups();
            Add_TimeRanges();


            if (IsConsoleRunning)
            {
                Console.WriteLine("Converting rules ...");
                Progress.SetProgress(30);
                Thread.Sleep(1000);
            }
            RaiseConversionProgress(30, "Converting rules ...");
            Add_Package();

            if (convertNat)
            {
                if (IsConsoleRunning)
                {
                    Console.WriteLine("Converting NAT rules ...");
                    Progress.SetProgress(40);
                    Thread.Sleep(1000);
                }
                RaiseConversionProgress(40, "Converting NAT rules ...");
                Add_object_NAT();
                Add_NAT_Rules();

                if (IsConsoleRunning)
                {
                    Console.WriteLine("Creating NAT rulebase ...");
                    Progress.SetProgress(50);
                    Thread.Sleep(1000);
                }
                RaiseConversionProgress(50, "Creating NAT rulebase ...");
                CreateNATRulebase();

                if (IsConsoleRunning)
                {
                    Console.WriteLine("Creating Firewall rulebase ...");
                    Progress.SetProgress(60);
                    Thread.Sleep(1000);
                }
                RaiseConversionProgress(60, "Creating Firewall rulebase ...");
                MatchNATRulesIntoFirewallPolicy();
            }

            // This should be done here, after all objects are converted!!!
            EnforceObjectNameValidity();

            if (SkipUnusedObjects)
            {
                if (IsConsoleRunning)
                {
                    Console.WriteLine("Analyzing using of objects ...");
                    Progress.SetProgress(65);
                    Thread.Sleep(1000);
                }
                RaiseConversionProgress(65, "Analyzing using of objects ...");
                BuildListOfUsedObjects(convertNat);
            }

            if (IsConsoleRunning)
            {
                Console.WriteLine("Optimizing Firewall rulebase ...");
                Progress.SetProgress(70);
                Thread.Sleep(1000);
            }
            RaiseConversionProgress(70, "Optimizing Firewall rulebase ...");
            Add_Optimized_Package();

            if (IsConsoleRunning)
            {
                Console.WriteLine("Generating CLI scripts ...");
                Progress.SetProgress(80);
                Thread.Sleep(1000);
            }
            RaiseConversionProgress(80, "Generating CLI scripts ...");

            if (SkipUnusedObjects)
            {
                if (IsConsoleRunning)
                {
                    Console.WriteLine("Optimizing objects ...");
                    Progress.SetProgress(90);
                    Thread.Sleep(1000);
                }
                RaiseConversionProgress(90, "Optimizing objects ...");
                CollectOnlyUsedObjects();
            }

            CreateObjectsScript();
            CreatePackagesScript();
            CreateObjectsHtml();


            WarningsHtmlFile = _targetFolder + "\\" + _vendorFileName + "_warnings.html";
            ErrorsHtmlFile = _targetFolder + "\\" + _vendorFileName + "_errors.html";

            CreateErrorsReport(_vendorFileName);
            CreateWarningsReport(_vendorFileName);

            // This data container is important, and is used during rulebases html reports generation for incidents lookup!!!
            var incidentsGroupedByLineNumber = _conversionIncidents.GroupBy(error => error.LineNumber);
            _conversionIncidentsByLineNumber = incidentsGroupedByLineNumber.ToDictionary(error => error.Key, error => error.Distinct().ToList());

            // Resolve the conversion categories/lines count to report to the user.
            ConversionIncidentCategoriesCount = _conversionIncidents.GroupBy(error => error.Title).Count();
            ConversionIncidentsCommandsCount = _conversionIncidents.GroupBy(error => error.LineNumber).Count();

            CreateSmartConnector(true, false);      //cp_objects.json
            CreateSmartConnector(true, true);       //cp_objects_opt.json


            if (IsConsoleRunning)
            {
                Progress.SetProgress(100);
                Progress.Dispose();
            }
            return new Dictionary<string, int>() { { "warnings", ConversionIncidentCategoriesCount } };
        }

        public override int RulesInConvertedPackage()
        {
            return _cpPackages[0].TotalRules();
        }

        public override int RulesInConvertedOptimizedPackage()
        {
            return _cpPackages[1].TotalRules();
        }

        public override int RulesInNatLayer()
        {
            return _cpNatRules.Count;
        }

        public void CreateErrorsReport(string vDomName)
        {
            _errorsList.AddRange(_conversionIncidents.Where(i => i.IncidentType == ConversionIncidentType.ManualActionRequired).Select(i => i.ToString()));

            if (_errorsList.Count > 0)
            {
                _errorsList = Helper.RemoveDuplicates(_errorsList);

                string filename = _targetFolder + "\\" + vDomName + "_errors.html";

                using (var file = new StreamWriter(filename, false))
                {
                    file.WriteLine("<html>");
                    file.WriteLine("<head>");
                    file.WriteLine("</head>");
                    file.WriteLine("<body>");
                    file.WriteLine("<h1>List of " + vDomName + " Errors</h1>");
                    file.WriteLine("<table border='1' style='border-collapse: collapse;'>");
                    for (int i = 0; i < _errorsList.Count; i++)
                    {
                        file.WriteLine("<tr>");
                        file.WriteLine("<td>");
                        file.WriteLine(i);
                        file.WriteLine("</td>");
                        file.WriteLine("<td>");
                        file.WriteLine(_errorsList[i]);
                        file.WriteLine("</td>");
                        file.WriteLine("</tr>");
                    }
                    file.WriteLine("</table>");
                    file.WriteLine("</body>");
                    file.WriteLine("</html>");
                }
            }
        }

        //report about Warnings
        public void CreateWarningsReport(string vDomName)
        {
            _warningsList.AddRange(_conversionIncidents.Where(i => i.IncidentType == ConversionIncidentType.None || i.IncidentType == ConversionIncidentType.Informative).Select(i => i.ToString()));

            if (_warningsList.Count > 0)
            {
                _warningsList = Helper.RemoveDuplicates(_warningsList);

                string filename = _targetFolder + "\\" + vDomName + "_warnings.html";

                using (var file = new StreamWriter(filename, false))
                {
                    file.WriteLine("<html>");
                    file.WriteLine("<head>");
                    file.WriteLine("</head>");
                    file.WriteLine("<body>");
                    file.WriteLine("<h1>List of " + vDomName + " Warnings</h1>");
                    file.WriteLine("<table border='1' style='border-collapse: collapse;'>");
                    for (int i = 0; i < _warningsList.Count; i++)
                    {
                        file.WriteLine("<tr>");
                        file.WriteLine("<td>");
                        file.WriteLine(i);
                        file.WriteLine("</td>");
                        file.WriteLine("<td>");
                        file.WriteLine(_warningsList[i]);
                        file.WriteLine("</td>");
                        file.WriteLine("</tr>");
                    }
                    file.WriteLine("</table>");
                    file.WriteLine("</body>");
                    file.WriteLine("</html>");
                }
            }
        }

        public void ExportManagmentReport(bool optimazed)
        {
            NewCiscoAnalizStatistic._unusedNetworkObjectsCount += _cpNetworks.Count * (optimazed ? -1 : 1);
            NewCiscoAnalizStatistic._unusedNetworkObjectsCount += _cpNetworkGroups.Count * (optimazed ? -1 : 1);
            NewCiscoAnalizStatistic._unusedNetworkObjectsCount += _cpRanges.Count * (optimazed ? -1 : 1);
            NewCiscoAnalizStatistic._unusedNetworkObjectsCount += _cpHosts.Count * (optimazed ? -1 : 1);

            NewCiscoAnalizStatistic._unusedServicesObjectsCount += _cpTcpServices.Count * (optimazed ? -1 : 1);
            NewCiscoAnalizStatistic._unusedServicesObjectsCount += _cpUdpServices.Count * (optimazed ? -1 : 1);
            NewCiscoAnalizStatistic._unusedServicesObjectsCount += _cpSctpServices.Count * (optimazed ? -1 : 1);
            NewCiscoAnalizStatistic._unusedServicesObjectsCount += _cpIcmpServices.Count * (optimazed ? -1 : 1);
            NewCiscoAnalizStatistic._unusedServicesObjectsCount += _cpDceRpcServices.Count * (optimazed ? -1 : 1);
            NewCiscoAnalizStatistic._unusedServicesObjectsCount += _cpOtherServices.Count * (optimazed ? -1 : 1);
            NewCiscoAnalizStatistic._unusedServicesObjectsCount += _cpServiceGroups.Count * (optimazed ? -1 : 1);

            optimazed = !optimazed;
            if (optimazed)
            {
                int dis = 0;
                int all = 0;
                int so_count = 0;
                int se_count = 0;
                int de_count = 0;
                foreach (var layer in NewCiscoAnalizStatistic._Package.SubPolicies)
                {
                    foreach (var policy in layer.Rules)
                    {
                        bool any_fl = true;
                        if (!policy.Enabled)
                        {
                            dis += 1;
                        }
                        if (policy.Comments == null || policy.Comments == "")
                        {
                            NewCiscoAnalizStatistic._uncommentedServicesRulesCount++;
                        }
                        if (policy.Destination.Count > 0 && policy.Destination.First().Name.Equals("Any"))
                        {
                            de_count++;
                            if (any_fl)
                            {
                                all++;
                                any_fl = false;
                            }

                        }
                        if (policy.Source.Count > 0 && policy.Source.First().Name.Equals("Any"))
                        {
                            so_count++;
                            if (any_fl)
                            {
                                all++;
                                any_fl = false;
                            }

                        }
                        if (policy.Service.Count > 0 && policy.Service.First().Name.Equals("Any"))
                        {
                            se_count++;
                            if (any_fl)
                            {
                                all++;
                                any_fl = false;
                            }

                        }
                    }
                }
                foreach (var policy in NewCiscoAnalizStatistic._Package.ParentLayer.Rules)
                {
                    bool any_fl = true;
                    if (!policy.Enabled)
                    {
                        dis += 1;
                    }
                    if (policy.Comments == null || policy.Comments == "")
                    {
                        NewCiscoAnalizStatistic._uncommentedServicesRulesCount++;
                    }
                    if (policy.Destination.Count > 0 && policy.Destination.First().Name.Equals("Any"))
                    {
                        de_count++;
                        if (any_fl)
                        {
                            all++;
                            any_fl = false;
                        }

                    }
                    if (policy.Source.Count > 0 && policy.Source.First().Name.Equals("Any"))
                    {
                        so_count++;
                        if (any_fl)
                        {
                            all++;
                            any_fl = false;
                        }

                    }
                    if (policy.Service.Count > 0 && policy.Service.First().Name.Equals("Any"))
                    {
                        se_count++;
                        if (any_fl)
                        {
                            all++;
                            any_fl = false;
                        }

                    }
                }
                NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyDestinationCount = de_count;
                NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyServiceCount = se_count;
                NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnySourceCount = so_count;
                NewCiscoAnalizStatistic._rulesServicesutilizingServicesAnyCount = all;
                NewCiscoAnalizStatistic._disabledServicesRulesCount = dis;
                NewCiscoAnalizStatistic.CalculateCorrectAll(_cpNetworks, _cpNetworkGroups, _cpHosts, _cpRanges, _cpTcpServices, _cpUdpServices, _cpSctpServices, _cpIcmpServices, _cpDceRpcServices, _cpOtherServices, _cpServiceGroups);
            }
            else
            {
                if (_cpPackages.Count > 0)
                {
                    this.OptimizationPotential = RulesInConvertedPackage() > 0 ? ((RulesInConvertedPackage() - RulesInConvertedOptimizedPackage()) * 100 / (float)RulesInConvertedPackage()) : 0;

                    ExportManagmentReport();
                }

            }
        }

        public override void ExportManagmentReport()
        {
            TotalRules = RulesInConvertedPackage();
            NewCiscoAnalizStatistic._totalServicesRulesCount = RulesInConvertedPackage();
            NewCiscoAnalizStatistic._totalServicesRulesOptCount = RulesInConvertedOptimizedPackage();

            NewCiscoAnalizStatistic._totalFileRules += NewCiscoAnalizStatistic._totalServicesRulesCount;
            NewCiscoAnalizStatistic._totalFileRulesOpt += NewCiscoAnalizStatistic._totalServicesRulesOptCount;
            var potentialCount = NewCiscoAnalizStatistic._totalServicesRulesCount - NewCiscoAnalizStatistic._totalServicesRulesOptCount;
            var potentialPersent = NewCiscoAnalizStatistic._totalServicesRulesCount > 0 ? (potentialCount * 100 / (float)NewCiscoAnalizStatistic._totalServicesRulesCount) : 0;
            NewCiscoAnalizStatistic._fullrullPackageCount += NewCiscoAnalizStatistic._fullrullPackcount;
            NewCiscoAnalizStatistic._totalrullPackageCount += NewCiscoAnalizStatistic._totalServicesRulesCount;
            using (var file = new StreamWriter(VendorManagmentReportHtmlFile))
            {
                file.WriteLine("<html>");
                file.WriteLine("<head>");
                file.WriteLine("<style>");
                file.WriteLine("  body { font-family: Arial; }");
                file.WriteLine("  .report_table { border-collapse: separate;border-spacing: 0px; font-family: Lucida Console;}");
                file.WriteLine("  td {padding: 5px; vertical-align: top}");
                file.WriteLine("  .line_number {background: lightgray;}");
                file.WriteLine("  .unhandeled {color: Fuchsia;}");
                file.WriteLine("  .notimportant {color: Gray;}");
                file.WriteLine("  .converterr {color: Red;}");
                file.WriteLine("  .convertinfo {color: Blue;}");
                file.WriteLine("  .err_title {color: Red;}");
                file.WriteLine("  .info_title {color: Blue;}");
                file.WriteLine("</style>");
                file.WriteLine("</head>");

                file.WriteLine("<body>");
                file.WriteLine("<h2>Cisco managment report file</h2>");
                file.WriteLine("<h3>OBJECTS DATABASE</h3>");

                file.WriteLine("<table style='margin-bottom: 30px; background: rgb(250,250,250);'>");
                file.WriteLine($"   <tr><td style='font-size: 14px;'></td> <td style='font-size: 14px;'>STATUS</td> <td style='font-size: 14px;'>COUNT</td> <td style='font-size: 14px;'>PERCENT</td> <td style='font-size: 14px;'>REMEDIATION</td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Total Network Objects</td> <td style='font-size: 14px;'>{ChoosePict(NewCiscoAnalizStatistic.TotalNetworkObjectsPercent, 100, 100)}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic._totalNetworkObjectsCount}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic.TotalNetworkObjectsPercent}%</td> <td style='font-size: 14px;'></td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Unused Network Objects</td> <td style='font-size: 14px;'>{ChoosePict(NewCiscoAnalizStatistic.UnusedNetworkObjectsPercent, 5, 25)}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic._unusedNetworkObjectsCount}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic.UnusedNetworkObjectsPercent.ToString("F")}%</td> <td style='font-size: 14px;'>{(NewCiscoAnalizStatistic._unusedNetworkObjectsCount > 0 ? "Consider deleting these objects." : "")}</td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Duplicate Network Objects</td> <td style='font-size: 14px;'>{ChoosePict(NewCiscoAnalizStatistic.DuplicateNetworkObjectsPercent, 5, 25)}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic._duplicateNetworkObjectsCount}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic.DuplicateNetworkObjectsPercent.ToString("F")}%</td> <td style='font-size: 14px;'></td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Nested Network Groups</td> <td style='font-size: 14px;'>{ChoosePict(NewCiscoAnalizStatistic.NestedNetworkGroupsPercent, 5, 25)}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic._nestedNetworkGroupsCount}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic.NestedNetworkGroupsPercent.ToString("F")}%</td> <td style='font-size: 14px;'></td></tr>");
                file.WriteLine("</table>");

                file.WriteLine("<h3>SERVICES DATABASE</h3>");
                file.WriteLine("<table style='margin-bottom: 30px; background: rgb(250,250,250);'>");
                file.WriteLine($"   <tr><td style='font-size: 14px;'></td> <td style='font-size: 14px;'>STATUS</td> <td style='font-size: 14px;'>COUNT</td> <td style='font-size: 14px;'>PERCENT</td> <td style='font-size: 14px;'>REMEDIATION</td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Total Services Objects</td> <td style='font-size: 14px;'>{ChoosePict(NewCiscoAnalizStatistic.TotalServicesObjectsPercent, 100, 100)}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic._totalServicesObjectsCount}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic.TotalServicesObjectsPercent}%</td> <td style='font-size: 14px;'></td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Unused Services Objects</td> <td style='font-size: 14px;'>{ChoosePict(NewCiscoAnalizStatistic.UnusedServicesObjectsPercent, 5, 25)}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic._unusedServicesObjectsCount}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic.UnusedServicesObjectsPercent.ToString("F")}%</td> <td style='font-size: 14px;'>{(NewCiscoAnalizStatistic._unusedServicesObjectsCount > 0 ? "Consider deleting these objects." : "")}</td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Duplicate Services Objects</td> <td style='font-size: 14px;'>{ChoosePict(NewCiscoAnalizStatistic.DuplicateServicesObjectsPercent, 5, 25)}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic._duplicateServicesObjectsCount}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic.DuplicateServicesObjectsPercent.ToString("F")}%</td> <td style='font-size: 14px;'></td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Nested Services Groups</td> <td style='font-size: 14px;'>{ChoosePict(NewCiscoAnalizStatistic.NestedServicesGroupsPercent, 5, 25)}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic._nestedServicesGroupsCount}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic.NestedServicesGroupsPercent.ToString("F")}%</td> <td style='font-size: 14px;'></td></tr>");
                file.WriteLine("</table>");

                file.WriteLine("<h3>POLICY ANALYSIS</h3>");
                file.WriteLine("<table style='margin-bottom: 30px; background: rgb(250,250,250);'>");
                file.WriteLine($"   <tr><td style='font-size: 14px;'></td> <td style='font-size: 14px;'>STATUS</td> <td style='font-size: 14px;'>COUNT</td> <td style='font-size: 14px;'>PERCENT</td> <td style='font-size: 14px;'>REMEDIATION</td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Total Rules</td> <td style='font-size: 14px;'>{ChoosePict(NewCiscoAnalizStatistic.TotalServicesRulesPercent, 100, 100)}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic._totalServicesRulesCount}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic.TotalServicesRulesPercent}%</td> <td style='font-size: 14px;'></td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Rules utilizing \"Any\"</td> <td style='font-size: 14px;'>{ChoosePict(NewCiscoAnalizStatistic.RulesServicesutilizingServicesAnyPercent, 5, 15)}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic._unrulesServicesutilizingServicesAnyCount}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic.RulesServicesutilizingServicesAnyPercent.ToString("F")}%</td> <td style='font-size: 14px;'>- ANY in Source: {NewCiscoAnalizStatistic._unrulesServicesutilizingServicesAnySourceCount}</td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'></td> <td style='font-size: 14px;'></td> <td style='font-size: 14px;'></td> <td style='font-size: 14px;'></td> <td style='font-size: 14px;'>- ANY in Destination: {NewCiscoAnalizStatistic._unrulesServicesutilizingServicesAnyDestinationCount} </td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'></td> <td style='font-size: 14px;'></td> <td style='font-size: 14px;'></td> <td style='font-size: 14px;'></td> <td style='font-size: 14px;'>- ANY in Service: {NewCiscoAnalizStatistic._unrulesServicesutilizingServicesAnyServiceCount}</td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Disabled Rules</td> <td style='font-size: 14px;'>{ChoosePict(NewCiscoAnalizStatistic.DisabledServicesRulesPercent, 5, 25)}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic._undisabledServicesRulesCount}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic.DisabledServicesRulesPercent.ToString("F")}%</td> <td style='font-size: 14px;'></td> {(NewCiscoAnalizStatistic._disabledServicesRulesCount > 0 ? "Check if rules are required." : "")}</tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Times Rules</td> <td style='font-size: 14px;'>{ChoosePict(NewCiscoAnalizStatistic.TimesServicesRulesPercent, 5, 25)}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic._untimesServicesRulesCount}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic.TimesServicesRulesPercent.ToString("F")}%</td> <td style='font-size: 14px;'></td></tr>");
                //file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Non Logging Rules</td> <td style='font-size: 14px;'>{ChoosePict(NewCiscoAnalizStatistic.NonServicesLoggingServicesRulesPercent, 5, 25)}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic._nonServicesLoggingServicesRulesCount}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic.NonServicesLoggingServicesRulesPercent.ToString("F")}%</td> <td style='font-size: 14px;'> {(NewCiscoAnalizStatistic._nonServicesLoggingServicesRulesCount > 0 ? "Enable logging for these rules for better tracking and change management." : "")}</td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Cleanup Rule</td> <td style='font-size: 14px;'>{(NewCiscoAnalizStatistic._cleanupServicesRuleCount > 0 ? HtmlGoodImageTagManagerReport : HtmlSeriosImageTagManagerReport)}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic._cleanupServicesRuleCount}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic.CleanupServicesRulePercent.ToString("F")}%</td> <td style='font-size: 14px;'>{(NewCiscoAnalizStatistic._cleanupServicesRuleCount > 0 ? "Found" : "")}</td></tr>");
                //file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Uncommented Rules</td> <td style='font-size: 14px;'>{ChoosePict(NewCiscoAnalizStatistic.UncommentedServicesRulesPercent, 25, 100)}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic._uncommentedServicesRulesCount}</td> <td style='font-size: 14px;'>{NewCiscoAnalizStatistic.UncommentedServicesRulesPercent.ToString("F")}%</td> <td style='font-size: 14px;'>{(NewCiscoAnalizStatistic._uncommentedServicesRulesCount > 0 ? "Comment rules for better tracking and change management compliance." : "")}</td></tr>");
                file.WriteLine($"   <tr><td style='font-size: 14px; color: Black;'>Optimization Potential</td> <td style='font-size: 14px;'>{(potentialCount > 0 ? HtmlGoodImageTagManagerReport : HtmlAttentionImageTagManagerReport)}</td> <td style='font-size: 14px;'>{potentialCount}</td> <td style='font-size: 14px;'>{(potentialCount > 0 ? potentialPersent : 0).ToString("F")}%</td> <td style='font-size: 14px;'>{GetOptPhraze(potentialCount > 0 ? (int)potentialPersent : 0)}</td></tr>");
                file.WriteLine("</table>");
                file.WriteLine("</body>");
                file.WriteLine("</html>");
            }
        }

        public override void ExportConfigurationAsHtml()
        {
            using (var file = new StreamWriter(VendorHtmlFile))
            {
                file.WriteLine("<html>");
                file.WriteLine("<head>");
                file.WriteLine("<style>");
                file.WriteLine("  body { font-family: Arial; }");
                file.WriteLine("  .report_table { border-collapse: separate;border-spacing: 0px; font-family: Lucida Console;}");
                file.WriteLine("  td {padding: 5px; vertical-align: top}");
                file.WriteLine("  .line_number {background: lightgray;}");
                file.WriteLine("  .unhandeled {color: Fuchsia;}");
                file.WriteLine("  .notimportant {color: Gray;}");
                file.WriteLine("  .converterr {color: Red;}");
                file.WriteLine("  .convertinfo {color: Blue;}");
                file.WriteLine("  .err_title {color: Red;}");
                file.WriteLine("  .info_title {color: Blue;}");
                file.WriteLine("</style>");
                file.WriteLine("</head>");

                file.WriteLine("<body>");
                file.WriteLine("<h2>Cisco config file</h2>");

                file.WriteLine("<table style='margin-bottom: 20px; background: rgb(250,250,250);'>");
                file.WriteLine("   <tr><td style='font-size: 14px; text-decoration: underline;'>Colors Legend</td></tr>");
                file.WriteLine("   <tr><td style='font-size: 12px; color: Black;'>Parsed commands</td></tr>");
                file.WriteLine("   <tr><td style='font-size: 12px; color: Gray;'>Skipped commands</td></tr>");
                file.WriteLine("   <tr><td style='font-size: 12px; color: Fuchsia;'>Unknown commands</td></tr>");
                file.WriteLine("   <tr><td style='font-size: 12px; color: Red;'>Commands with conversion error</td></tr>");
                file.WriteLine("   <tr><td style='font-size: 12px; color: Blue;'>Commands with conversion notification</td></tr>");
                file.WriteLine("</table>");

                file.WriteLine("<div style='margin-bottom: 20px; font-size: 14px; color: Blue;'>");
                file.WriteLine("   <span style='vertical-align: middle; font-size: 14px;'>" + HtmlAlertImageTag);
                file.WriteLine("      <a> Valid Check Point object name consists of the following characters only - \"A-Za-z0-9_.-\". Any invalid character will be replaced with a \"_\" character.</a>");
                file.WriteLine("   </span>");
                file.WriteLine("</div>");

                if (_conversionIncidents.Count > 0)
                {
                    file.WriteLine("<div style='margin-bottom: 20px;'>");
                    file.WriteLine("   <span style='vertical-align: middle; font-size: 14px;'>" + HtmlAlertImageTag);
                    file.WriteLine("      <a href='#ConversionIncidents'>Found " + ConversionIncidentCategoriesCount + " conversion issues in " + ConversionIncidentsCommandsCount + " configuration lines</a>");
                    file.WriteLine("   </span>");
                    file.WriteLine("</div>");
                }

                file.WriteLine("<table class=\"report_table\">");

                foreach (CiscoCommand command in CiscoAllCommands)
                {
                    string lineStyle = "";
                    string indentation = "";

                    if (!command.KnownCommand) lineStyle = " class=\"unhandeled\" ";
                    if (command.NotAnInterestingCommand) lineStyle = " class=\"notimportant\" ";
                    if (command.ConversionIncidentType == ConversionIncidentType.ManualActionRequired) lineStyle = " class=\"converterr\" ";
                    if (command.ConversionIncidentType == ConversionIncidentType.Informative) lineStyle = " class=\"convertinfo\" ";

                    for (int i = 0; i < command.IndentationLevel; i++)
                    {
                        indentation += "&nbsp;&nbsp;";
                    }

                    string incidentFlag = "";
                    if (command.ConversionIncidentType != ConversionIncidentType.None)
                    {
                        ConversionIncidentType highestIncidentType;
                        incidentFlag = BuildConversionIncidentInfo(command.Id, out highestIncidentType);
                    }

                    file.WriteLine("<tr>");
                    file.WriteLine("  <td id=\"line_" + command.Id + "\" class=\"line_number\" style=\"text-align: right;\">" + incidentFlag + command.Id + "</td>" + "<td " + lineStyle + " >" + indentation + command.Text + "</td>");
                    file.WriteLine("</tr>");
                }
                file.WriteLine("</table>");

                if (_conversionIncidents.Count > 0)
                {
                    file.WriteLine("<hr/>");
                    file.WriteLine("<h2 id=\"ConversionIncidents\">Conversion Issues</h2>");

                    bool first = true;
                    ConversionIncident prevErr = null;

                    foreach (ConversionIncident err in _conversionIncidents.OrderByDescending(item => item.IncidentType).ThenBy(item => item.Title).ThenBy(item => item.LineNumber).ToList())
                    {
                        if (first)
                        {
                            if (err.IncidentType == ConversionIncidentType.ManualActionRequired)
                            {
                                file.WriteLine("<h4 class=\"err_title\">" + err.Title + "</h4>");
                            }
                            else
                            {
                                file.WriteLine("<h4 class=\"info_title\">" + err.Title + "</h4>");
                            }
                            file.WriteLine("<table class=\"report_table\">");
                        }

                        if (!first && prevErr.Title != err.Title)
                        {
                            file.WriteLine("</table>");

                            if (err.IncidentType == ConversionIncidentType.ManualActionRequired)
                            {
                                file.WriteLine("<h4 class=\"err_title\">" + err.Title + "</h4>");
                            }
                            else
                            {
                                file.WriteLine("<h4 class=\"info_title\">" + err.Title + "</h4>");
                            }
                            file.WriteLine("<table class=\"report_table\">");
                        }

                        // Do not display the same description for the same line...
                        if (prevErr == null || prevErr.LineNumber != err.LineNumber || prevErr.Description != err.Description)
                        {
                            file.WriteLine("  <tr>");
                            file.WriteLine("    <td class=\"line_number\" style=\"text-align: right;\"> <a href=\"#line_" + err.LineNumber + "\">" + err.LineNumber + "</a></td>");
                            file.WriteLine("    <td>" + err.Description + "</td>");
                            file.WriteLine("  </tr>");
                        }

                        first = false;
                        prevErr = err;
                    }
                }

                file.WriteLine("</body>");
                file.WriteLine("</html>");
            }
        }

        public override void ExportPolicyPackagesAsHtml()
        {
            const string ruleIdPrefix = "rule_";

            foreach (CheckPoint_Package package in _cpPackages)
            {
                if (package.ParentLayer.Rules.Count > 0)
                {
                    if (package.ParentLayer.Rules.Count == 1 && package.ParentLayer.Rules[0].Name == "Cleanup rule")
                        continue;

                    string filename = _targetFolder + "\\" + package.Name + ".html";

                    using (var file = new StreamWriter(filename, false))
                    {
                        var rulesWithConversionErrors = new Dictionary<string, CheckPoint_Rule>();
                        var rulesWithConversionInfos = new Dictionary<string, CheckPoint_Rule>();
                        var rulesWithInspection = new Dictionary<string, List<CheckPoint_Rule>>();

                        GeneratePackageHtmlReportHeaders(file, package.Name, package.ConversionIncidentType != ConversionIncidentType.None);

                        // Generate the report body
                        file.WriteLine("<table>");
                        file.WriteLine("   <tr>");
                        file.WriteLine("      <th colspan='3'>No.</th> <th>Name</th> <th>Source</th> <th>Destination</th> <th>Service</th> <th>Action</th> <th>Time</th> <th>Track</th> <th>Comments</th> <th>Conversion Comments</th>");
                        file.WriteLine("   </tr>");

                        int ruleNumber = 1;

                        foreach (CheckPoint_Rule rule in package.ParentLayer.Rules)
                        {
                            bool isSubPolicy = false;
                            string action = "";
                            string actionStyle = "";
                            var dummy = ConversionIncidentType.None;

                            switch (rule.Action)
                            {
                                case CheckPoint_Rule.ActionType.Accept:
                                case CheckPoint_Rule.ActionType.Drop:
                                    action = rule.Action.ToString();
                                    actionStyle = rule.Action.ToString().ToLower();
                                    break;

                                case CheckPoint_Rule.ActionType.SubPolicy:
                                    isSubPolicy = true;
                                    action = "Sub-policy: " + rule.SubPolicyName;
                                    actionStyle = "";
                                    break;
                            }

                            string curParentRuleId = string.Format("{0}{1}", ruleIdPrefix, ruleNumber);

                            if (rule.Enabled)
                            {
                                file.WriteLine("  <tr class='parent_rule' id=\"" + curParentRuleId + "\">");
                                if (isSubPolicy)
                                {
                                    file.WriteLine("      <td class='rule_number' colspan='3' onclick='toggleSubRules(this)'>" +
                                        string.Format(HtmlSubPolicyArrowImageTagFormat, curParentRuleId + "_img", HtmlDownArrowImageSourceData) + ruleNumber + "</td>");
                                }
                                else
                                {
                                    file.WriteLine("      <td class='rule_number' colspan='3' style='padding-left:22px;'>" + ruleNumber + "</td>");
                                }
                            }
                            else
                            {
                                file.WriteLine("  <tr class='parent_rule_disabled' id=\"" + curParentRuleId + "\">");
                                if (isSubPolicy)
                                {
                                    file.WriteLine("      <td class='rule_number' colspan='3' onclick='toggleSubRules(this)'>" +
                                        string.Format(HtmlSubPolicyArrowImageTagFormat, curParentRuleId + "_img", HtmlDownArrowImageSourceData) + ruleNumber + HtmlDisabledImageTag + "</td>");
                                }
                                else
                                {
                                    file.WriteLine("      <td class='rule_number' colspan='3' style='padding-left:22px;'>" + ruleNumber + HtmlDisabledImageTag + "</td>");
                                }
                            }
                            file.WriteLine("      <td>" + rule.Name + "</td>");
                            file.WriteLine("      <td>" + RuleItemsList2Html(rule.Source, rule.SourceNegated, CheckPointObject.Any, ref dummy) + "</td>");
                            file.WriteLine("      <td>" + RuleItemsList2Html(rule.Destination, rule.DestinationNegated, CheckPointObject.Any, ref dummy) + "</td>");
                            file.WriteLine("      <td>" + RuleItemsList2Html(rule.Service, false, CheckPointObject.Any, ref dummy) + "</td>");
                            file.WriteLine("      <td class='" + actionStyle + "'>" + action + "</td>");
                            file.WriteLine("      <td>" + RuleItemsList2Html(rule.Time, false, CheckPointObject.Any, ref dummy) + "</td>");
                            file.WriteLine("      <td>" + rule.Track.ToString() + "</td>");
                            file.WriteLine("      <td>" + rule.Comments + "</td>");
                            file.WriteLine("      <td>" + rule.ConversionComments + "</td>");
                            file.WriteLine("  </tr>");

                            if (isSubPolicy)
                            {
                                foreach (CheckPoint_Layer subPolicy in package.SubPolicies)
                                {
                                    int subRuleNumber = 1;

                                    foreach (CheckPoint_Rule subRule in subPolicy.Rules)
                                    {
                                        if (subRule.Layer == rule.SubPolicyName)
                                        {
                                            bool isSubSubPolicy = false;
                                            string subAction = "";
                                            string subActionStyle = "";

                                            switch (subRule.Action)
                                            {
                                                case CheckPoint_Rule.ActionType.Accept:
                                                case CheckPoint_Rule.ActionType.Drop:
                                                case CheckPoint_Rule.ActionType.Reject:
                                                    subAction = subRule.Action.ToString();
                                                    subActionStyle = subRule.Action.ToString().ToLower();
                                                    break;

                                                case CheckPoint_Rule.ActionType.SubPolicy:
                                                    isSubSubPolicy = true;
                                                    subAction = "Sub-policy: " + subRule.SubPolicyName;
                                                    subActionStyle = "";
                                                    break;
                                            }

                                            var ruleConversionIncidentType = ConversionIncidentType.None;
                                            bool isInspectedRule = !string.IsNullOrEmpty(subRule.Tag);
                                            string curRuleNumber = ruleNumber + "." + subRuleNumber;
                                            string curRuleId = ruleIdPrefix + curRuleNumber;

                                            if (subRule.Enabled)
                                            {
                                                file.WriteLine("  <tr id=\"" + curRuleId + "\">");
                                            }
                                            else
                                            {
                                                file.WriteLine("  <tr class='disabled_rule' id=\"" + curRuleId + "\">");
                                            }

                                            var sbCurRuleNumberColumnTag = new StringBuilder();
                                            sbCurRuleNumberColumnTag.Append("      <td class='indent_rule_number'/>");
                                            if (isSubSubPolicy)
                                            {
                                                sbCurRuleNumberColumnTag.Append("      <td class='rule_number' colspan='2' onclick='toggleSubRules(this)'>" +
                                                    string.Format(HtmlSubPolicyArrowImageTagFormat, curRuleId + "_img", HtmlDownArrowImageSourceData) + curRuleNumber);
                                            }
                                            else
                                            {
                                                sbCurRuleNumberColumnTag.Append("      <td class='rule_number' colspan='2'>");
                                                sbCurRuleNumberColumnTag.Append(curRuleNumber);
                                            }

                                            if (isInspectedRule)
                                            {
                                                sbCurRuleNumberColumnTag.Append(BuildInspectedRuleInfo(subRule.Tag));
                                            }
                                            if (subRule.ConversionIncidentType != ConversionIncidentType.None)
                                            {
                                                sbCurRuleNumberColumnTag.Append(BuildConversionIncidentLinkTag(subRule.ConvertedCommandId));
                                                ruleConversionIncidentType = subRule.ConversionIncidentType;
                                            }
                                            if (!subRule.Enabled)
                                            {
                                                sbCurRuleNumberColumnTag.Append(HtmlDisabledImageTag);
                                            }
                                            sbCurRuleNumberColumnTag.Append("</td>");
                                            file.WriteLine(sbCurRuleNumberColumnTag.ToString());

                                            file.WriteLine("      <td>" + subRule.Name + "</td>");
                                            file.WriteLine("      <td>" + RuleItemsList2Html(subRule.Source, subRule.SourceNegated, CheckPointObject.Any, ref ruleConversionIncidentType) + "</td>");
                                            file.WriteLine("      <td>" + RuleItemsList2Html(subRule.Destination, subRule.DestinationNegated, CheckPointObject.Any, ref ruleConversionIncidentType) + "</td>");
                                            file.WriteLine("      <td>" + RuleItemsList2Html(subRule.Service, false, CheckPointObject.Any, ref ruleConversionIncidentType) + "</td>");
                                            //file.WriteLine("      <td class='" + subRule.Action.ToString().ToLower() + "'>" + subRule.Action.ToString() + "</td>");
                                            file.WriteLine("      <td class='" + subActionStyle + "'>" + subAction + "</td>");
                                            file.WriteLine("      <td>" + RuleItemsList2Html(subRule.Time, false, CheckPointObject.Any, ref ruleConversionIncidentType) + "</td>");
                                            file.WriteLine("      <td>" + subRule.Track.ToString() + "</td>");
                                            file.WriteLine("      <td class='comments'>" + subRule.Comments + "</td>");
                                            file.WriteLine("      <td class='comments'>" + subRule.ConversionComments + "</td>");
                                            file.WriteLine("  </tr>");

                                            if (isSubSubPolicy)
                                            {
                                                foreach (CheckPoint_Layer subSubPolicy in package.SubPolicies)
                                                {
                                                    int subSubRuleNumber = 1;

                                                    foreach (CheckPoint_Rule subSubRule in subSubPolicy.Rules)
                                                    {
                                                        //if (subSubRule.Layer == subRule.SubPolicyName || subSubRule.Layer == subRule.SubPolicyName + "_opt")
                                                        if (subSubRule.Layer == subRule.SubPolicyName)
                                                        {
                                                            var subRuleConversionIncidentType = ConversionIncidentType.None;
                                                            string subCurRuleNumber = ruleNumber + "." + subRuleNumber + "." + subSubRuleNumber;
                                                            string subCurRuleId = ruleIdPrefix + subCurRuleNumber;

                                                            if (subSubRule.Enabled)
                                                            {
                                                                file.WriteLine("  <tr id=\"" + subCurRuleId + "\">");
                                                            }
                                                            else
                                                            {
                                                                file.WriteLine("  <tr class='disabled_rule' id=\"" + subCurRuleId + "\">");
                                                            }

                                                            var sbSubCurRuleNumberColumnTag = new StringBuilder();
                                                            sbSubCurRuleNumberColumnTag.Append("      <td class='indent_rule_number'/>");
                                                            sbSubCurRuleNumberColumnTag.Append("      <td class='indent_rule_number'/>");
                                                            sbSubCurRuleNumberColumnTag.Append("      <td class='rule_number'>");
                                                            sbSubCurRuleNumberColumnTag.Append(subCurRuleNumber);
                                                            if (subSubRule.ConversionIncidentType != ConversionIncidentType.None)
                                                            {
                                                                sbSubCurRuleNumberColumnTag.Append(BuildConversionIncidentLinkTag(subSubRule.ConvertedCommandId));
                                                                subRuleConversionIncidentType = subSubRule.ConversionIncidentType;
                                                            }
                                                            if (!subSubRule.Enabled)
                                                            {
                                                                sbSubCurRuleNumberColumnTag.Append(HtmlDisabledImageTag);
                                                            }
                                                            sbSubCurRuleNumberColumnTag.Append("</td>");
                                                            file.WriteLine(sbSubCurRuleNumberColumnTag.ToString());

                                                            file.WriteLine("      <td>" + subSubRule.Name + "</td>");
                                                            file.WriteLine("      <td>" + RuleItemsList2Html(subSubRule.Source, subSubRule.SourceNegated, CheckPointObject.Any, ref subRuleConversionIncidentType) + "</td>");
                                                            file.WriteLine("      <td>" + RuleItemsList2Html(subSubRule.Destination, subSubRule.DestinationNegated, CheckPointObject.Any, ref subRuleConversionIncidentType) + "</td>");
                                                            file.WriteLine("      <td>" + RuleItemsList2Html(subSubRule.Service, false, CheckPointObject.Any, ref subRuleConversionIncidentType) + "</td>");
                                                            file.WriteLine("      <td class='" + subSubRule.Action.ToString().ToLower() + "'>" + subSubRule.Action.ToString() + "</td>");
                                                            file.WriteLine("      <td>" + RuleItemsList2Html(subSubRule.Time, false, CheckPointObject.Any, ref subRuleConversionIncidentType) + "</td>");
                                                            file.WriteLine("      <td>" + subSubRule.Track.ToString() + "</td>");
                                                            file.WriteLine("      <td class='comments'>" + subSubRule.Comments + "</td>");
                                                            file.WriteLine("      <td class='comments'>" + subSubRule.ConversionComments + "</td>");
                                                            file.WriteLine("  </tr>");

                                                            subSubRuleNumber++;

                                                            if (package.ConversionIncidentType != ConversionIncidentType.None && subRuleConversionIncidentType != ConversionIncidentType.None)
                                                            {
                                                                if (subRuleConversionIncidentType == ConversionIncidentType.ManualActionRequired)
                                                                {
                                                                    rulesWithConversionErrors.Add(subCurRuleId, subSubRule);
                                                                }
                                                                else
                                                                {
                                                                    rulesWithConversionInfos.Add(subCurRuleId, subSubRule);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }


                                            subRuleNumber++;

                                            if (package.ConversionIncidentType != ConversionIncidentType.None && ruleConversionIncidentType != ConversionIncidentType.None)
                                            {
                                                if (ruleConversionIncidentType == ConversionIncidentType.ManualActionRequired)
                                                {
                                                    rulesWithConversionErrors.Add(curRuleId, subRule);
                                                }
                                                else
                                                {
                                                    rulesWithConversionInfos.Add(curRuleId, subRule);
                                                }
                                            }

                                            if (isInspectedRule)
                                            {
                                                string[] ciscoClassMapNames = subRule.Tag.Split(',');   // there may be several class-maps matching the same fw rule...
                                                subRule.Tag = curRuleId;   // replace class-map name (it is now the key of this dic) by curRuleId...

                                                foreach (var classMapName in ciscoClassMapNames)
                                                {
                                                    if (!rulesWithInspection.ContainsKey(classMapName))
                                                    {
                                                        var inspectedRules = new List<CheckPoint_Rule>();
                                                        rulesWithInspection.Add(classMapName, inspectedRules);
                                                    }
                                                    rulesWithInspection[classMapName].Add(subRule);
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            ruleNumber++;
                        }

                        file.WriteLine("</table>");

                        if (rulesWithConversionErrors.Count > 0 || rulesWithConversionInfos.Count > 0 || rulesWithInspection.Count > 0)
                        {
                            file.WriteLine("<div id=\"PolicyConversionIncidents\" style='margin-left: 20px;'><h2>Policy Conversion Issues</h2></div>");
                        }

                        // Generate the errors report
                        if (rulesWithConversionErrors.Count > 0)
                        {
                            file.WriteLine("<script>");
                            file.WriteLine("   errorsCounter = " + rulesWithConversionErrors.Count + ";");
                            file.WriteLine("</script>");

                            file.WriteLine("<div id=\"PolicyConversionErrors\" style='margin-left: 20px;'><h3>Conversion Errors</h3></div>");
                            file.WriteLine("<table style='background-color: rgb(255,255,150);'>");
                            file.WriteLine("   <tr>");
                            file.WriteLine("      <th class='errors_header'>No.</th> <th class='errors_header'>Name</th> <th class='errors_header'>Source</th> <th class='errors_header'>Destination</th> <th class='errors_header'>Service</th> <th class='errors_header'>Action</th> <th class='errors_header'>Time</th> <th class='errors_header'>Track</th> <th class='errors_header'>Comments</th> <th class='errors_header'>Conversion Comments</th>");
                            file.WriteLine("   </tr>");

                            foreach (var ruleEntry in rulesWithConversionErrors)
                            {
                                var dummy = ConversionIncidentType.None;

                                if (ruleEntry.Value.Enabled)
                                {
                                    file.WriteLine("  <tr>");
                                }
                                else
                                {
                                    file.WriteLine("  <tr class='disabled_rule'>");
                                }

                                var sbCurRuleNumberColumnTag = new StringBuilder();
                                sbCurRuleNumberColumnTag.Append("      <td class='rule_number'>");
                                sbCurRuleNumberColumnTag.Append("<a href=\"#");
                                sbCurRuleNumberColumnTag.Append(ruleEntry.Key);
                                sbCurRuleNumberColumnTag.Append("\">");
                                sbCurRuleNumberColumnTag.Append(ruleEntry.Key.Replace(ruleIdPrefix, ""));
                                sbCurRuleNumberColumnTag.Append("</a>");
                                if (ruleEntry.Value.ConversionIncidentType != ConversionIncidentType.None)
                                {
                                    sbCurRuleNumberColumnTag.Append(BuildConversionIncidentLinkTag(ruleEntry.Value.ConvertedCommandId));
                                }
                                if (!ruleEntry.Value.Enabled)
                                {
                                    sbCurRuleNumberColumnTag.Append(HtmlDisabledImageTag);
                                }
                                sbCurRuleNumberColumnTag.Append("</td>");
                                file.WriteLine(sbCurRuleNumberColumnTag.ToString());

                                file.WriteLine("      <td>" + ruleEntry.Value.Name + "</td>");
                                file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Source, ruleEntry.Value.SourceNegated, CheckPointObject.Any, ref dummy) + "</td>");
                                file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Destination, ruleEntry.Value.DestinationNegated, CheckPointObject.Any, ref dummy) + "</td>");
                                file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Service, false, CheckPointObject.Any, ref dummy) + "</td>");
                                file.WriteLine("      <td class='" + ruleEntry.Value.Action.ToString().ToLower() + "'>" + ruleEntry.Value.Action.ToString() + "</td>");
                                file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Time, false, CheckPointObject.Any, ref dummy) + "</td>");
                                file.WriteLine("      <td>" + ruleEntry.Value.Track.ToString() + "</td>");
                                file.WriteLine("      <td class='comments'>" + ruleEntry.Value.Comments + "</td>");
                                file.WriteLine("      <td class='comments'>" + ruleEntry.Value.ConversionComments + "</td>");
                                file.WriteLine("  </tr>");
                            }

                            file.WriteLine("</table>");
                        }

                        if (rulesWithConversionInfos.Count > 0 || rulesWithInspection.Count > 0)
                        {
                            int counter = (rulesWithInspection.Count > 0) ? 1 : 0;
                            counter += rulesWithConversionInfos.Count;

                            file.WriteLine("<script>");
                            file.WriteLine("   infosCounter = " + counter + ";");
                            file.WriteLine("</script>");
                            file.WriteLine("<div id=\"PolicyConversionInfos\" style='margin-left: 20px;'><h3>Conversion Notifications</h3></div>");
                        }

                        // Generate the information report
                        if (rulesWithConversionInfos.Count > 0)
                        {
                            file.WriteLine("<table style='background-color: rgb(220,240,247);'>");
                            file.WriteLine("   <tr>");
                            file.WriteLine("      <th class='errors_header'>No.</th> <th class='errors_header'>Name</th> <th class='errors_header'>Source</th> <th class='errors_header'>Destination</th> <th class='errors_header'>Service</th> <th class='errors_header'>Action</th> <th class='errors_header'>Time</th> <th class='errors_header'>Track</th> <th class='errors_header'>Comments</th> <th class='errors_header'>Conversion Comments</th>");
                            file.WriteLine("   </tr>");

                            foreach (var ruleEntry in rulesWithConversionInfos)
                            {
                                var dummy = ConversionIncidentType.None;

                                if (ruleEntry.Value.Enabled)
                                {
                                    file.WriteLine("  <tr>");
                                }
                                else
                                {
                                    file.WriteLine("  <tr class='disabled_rule'>");
                                }

                                var sbCurRuleNumberColumnTag = new StringBuilder();
                                sbCurRuleNumberColumnTag.Append("      <td class='rule_number'>");
                                sbCurRuleNumberColumnTag.Append("<a href=\"#");
                                sbCurRuleNumberColumnTag.Append(ruleEntry.Key);
                                sbCurRuleNumberColumnTag.Append("\">");
                                sbCurRuleNumberColumnTag.Append(ruleEntry.Key.Replace(ruleIdPrefix, ""));
                                sbCurRuleNumberColumnTag.Append("</a>");
                                if (ruleEntry.Value.ConversionIncidentType != ConversionIncidentType.None)
                                {
                                    sbCurRuleNumberColumnTag.Append(BuildConversionIncidentLinkTag(ruleEntry.Value.ConvertedCommandId));
                                }
                                if (!ruleEntry.Value.Enabled)
                                {
                                    sbCurRuleNumberColumnTag.Append(HtmlDisabledImageTag);
                                }
                                sbCurRuleNumberColumnTag.Append("</td>");
                                file.WriteLine(sbCurRuleNumberColumnTag.ToString());

                                file.WriteLine("      <td>" + ruleEntry.Value.Name + "</td>");
                                file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Source, ruleEntry.Value.SourceNegated, CheckPointObject.Any, ref dummy) + "</td>");
                                file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Destination, ruleEntry.Value.DestinationNegated, CheckPointObject.Any, ref dummy) + "</td>");
                                file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Service, false, CheckPointObject.Any, ref dummy) + "</td>");
                                file.WriteLine("      <td class='" + ruleEntry.Value.Action.ToString().ToLower() + "'>" + ruleEntry.Value.Action.ToString() + "</td>");
                                file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Value.Time, false, CheckPointObject.Any, ref dummy) + "</td>");
                                file.WriteLine("      <td>" + ruleEntry.Value.Track.ToString() + "</td>");
                                file.WriteLine("      <td class='comments'>" + ruleEntry.Value.Comments + "</td>");
                                file.WriteLine("      <td class='comments'>" + ruleEntry.Value.ConversionComments + "</td>");
                                file.WriteLine("  </tr>");
                            }

                            file.WriteLine("</table>");
                        }

                        // Generate the inspected rules report
                        if (rulesWithInspection.Count > 0)
                        {
                            file.WriteLine("<div style='margin-left: 20px;'><h3>Inspected Rules</h3></div>");
                            file.WriteLine("<div style='margin-left: 20px; margin-bottom: 20px;'>");
                            file.WriteLine("   <span style='vertical-align: middle;'>" + HtmlAlertImageTagFormat + "</span>");
                            file.WriteLine("   <span> The following firewall rules are matched by ");
                            file.WriteLine("      <a href='http://www.cisco.com/c/en/us/td/docs/security/asa/asa84/configuration/guide/asa_84_cli_config/mpf_inspect_maps.html' target='_blank'>Cisco Inspect classes</a>.");
                            file.WriteLine(" Please review for further possible modifications to rules after migration.</span>");
                            file.WriteLine("</div>");

                            foreach (var inspectionInfo in rulesWithInspection)
                            {
                                file.WriteLine("<div style='font-size: 14px; margin-left: 20px; margin-bottom: 15px;'>");
                                file.WriteLine("   <span>Cisco Inspect class-map: </span><span>" + BuildInspectedRuleLinkTag(inspectionInfo.Key) + "</span>");
                                file.WriteLine("</div>");

                                file.WriteLine("<table style='background-color: rgb(220,240,247);'>");
                                file.WriteLine("   <tr>");
                                file.WriteLine("      <th class='errors_header'>No.</th> <th class='errors_header'>Name</th> <th class='errors_header'>Source</th> <th class='errors_header'>Destination</th> <th class='errors_header'>Service</th> <th class='errors_header'>Action</th> <th class='errors_header'>Time</th> <th class='errors_header'>Track</th> <th class='errors_header'>Comments</th> <th class='errors_header'>Conversion Comments</th>");
                                file.WriteLine("   </tr>");

                                foreach (var ruleEntry in inspectionInfo.Value)
                                {
                                    var dummy = ConversionIncidentType.None;

                                    if (ruleEntry.Enabled)
                                    {
                                        file.WriteLine("  <tr>");
                                    }
                                    else
                                    {
                                        file.WriteLine("  <tr class='disabled_rule'>");
                                    }

                                    var sbRuleNumberColumnTag = new StringBuilder();
                                    sbRuleNumberColumnTag.Append("      <td class='rule_number'>");
                                    sbRuleNumberColumnTag.Append("<a href=\"#");
                                    sbRuleNumberColumnTag.Append(ruleEntry.Tag);
                                    sbRuleNumberColumnTag.Append("\">");
                                    sbRuleNumberColumnTag.Append(ruleEntry.Tag.Replace(ruleIdPrefix, ""));
                                    sbRuleNumberColumnTag.Append("</a>");
                                    if (ruleEntry.ConversionIncidentType != ConversionIncidentType.None)
                                    {
                                        sbRuleNumberColumnTag.Append(BuildConversionIncidentLinkTag(ruleEntry.ConvertedCommandId));
                                    }
                                    if (!ruleEntry.Enabled)
                                    {
                                        sbRuleNumberColumnTag.Append(HtmlDisabledImageTag);
                                    }
                                    sbRuleNumberColumnTag.Append("</td>");
                                    file.WriteLine(sbRuleNumberColumnTag.ToString());

                                    file.WriteLine("      <td>" + ruleEntry.Name + "</td>");
                                    file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Source, ruleEntry.SourceNegated, CheckPointObject.Any, ref dummy) + "</td>");
                                    file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Destination, ruleEntry.DestinationNegated, CheckPointObject.Any, ref dummy) + "</td>");
                                    file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Service, false, CheckPointObject.Any, ref dummy) + "</td>");
                                    file.WriteLine("      <td class='" + ruleEntry.Action.ToString().ToLower() + "'>" + ruleEntry.Action.ToString() + "</td>");
                                    file.WriteLine("      <td>" + RuleItemsList2Html(ruleEntry.Time, false, CheckPointObject.Any, ref dummy) + "</td>");
                                    file.WriteLine("      <td>" + ruleEntry.Track.ToString() + "</td>");
                                    file.WriteLine("      <td class='comments'>" + ruleEntry.Comments + "</td>");
                                    file.WriteLine("      <td class='comments'>" + ruleEntry.ConversionComments + "</td>");
                                    file.WriteLine("  </tr>");
                                }

                                file.WriteLine("</table>");
                            }
                        }

                        file.WriteLine("</body>");
                        file.WriteLine("</html>");
                    }
                }
            }
        }

        public int WarningsInConvertedPackage()
        {
            return _warningsList.Count;
        }

        public int ErrorsInConvertedPackage()
        {
            return _errorsList.Count;
        }

        protected override string GetVendorName()
        {
            return Vendor.CiscoASA.ToString();
        }
        #endregion
    }
}

public class NewAnalizStatistic
{
    public CheckPoint_Package _Package;
    public int _optPackageCount = 0;
    public int _fullrullPackcount = 0;
    public int _fullrullPackageCount = 0;
    public int _totalrullPackageCount = 0;
    public int _totalNetworkObjectsCount = 0;
    public int _unusedNetworkObjectsCount = 0;
    public int _duplicateNetworkObjectsCount = 0;
    public int _nestedNetworkGroupsCount = 0;
    public int _nestedNetworkGroupsCountAll = 0;

    public int _totalServicesObjectsCount = 0;
    public int _unusedServicesObjectsCount = 0;
    public int _duplicateServicesObjectsCount = 0;
    public int _nestedServicesGroupsCount = 0;
    public int _nestedServicesGroupsCountAll = 0;

    public int _totalServicesRulesCount = 0;
    public int _totalServicesRulesOptCount = 0;
    public int _rulesServicesutilizingServicesAnyCount = 0;
    public int _rulesServicesutilizingServicesAnySourceCount = 0;
    public int _rulesServicesutilizingServicesAnyDestinationCount = 0;
    public int _rulesServicesutilizingServicesAnyServiceCount = 0;
    public int _unrulesServicesutilizingServicesAnyCount = 0;
    public int _unrulesServicesutilizingServicesAnySourceCount = 0;
    public int _unrulesServicesutilizingServicesAnyDestinationCount = 0;
    public int _unrulesServicesutilizingServicesAnyServiceCount = 0;
    public int _disabledServicesRulesCount = 0;
    public int _undisabledServicesRulesCount = 0;
    public int _unnamedServicesRulesCount = 0;
    public int _timesServicesRulesCount = 0;
    public int _untimesServicesRulesCount = 0;
    public int _nonServicesLoggingServicesRulesCount = 0;
    public int _stealthServicesRuleCount = 0;
    public int _cleanupServicesRuleCount = 0;
    public int _uncommentedServicesRulesCount = 0;

    public int _totalFileRules = 0;
    public int _totalFileRulesOpt = 0;


    public int TotalNetworkObjectsPercent { get { return 100; } }
    public float UnusedNetworkObjectsPercent { get { return _totalNetworkObjectsCount > 0 ? ((float)_unusedNetworkObjectsCount / (float)_totalNetworkObjectsCount) * 100 : 0; } }
    public float DuplicateNetworkObjectsPercent { get { return _totalNetworkObjectsCount > 0 ? ((float)_duplicateNetworkObjectsCount / (float)_totalNetworkObjectsCount) * 100 : 0; } }
    public float NestedNetworkGroupsPercent { get { return _nestedNetworkGroupsCountAll > 0 ? ((float)_nestedNetworkGroupsCount / (float)_nestedNetworkGroupsCountAll) * 100 : 0; } }

    public float TotalServicesObjectsPercent { get { return 100; } }
    public float UnusedServicesObjectsPercent { get { return _totalServicesObjectsCount > 0 ? ((float)_unusedServicesObjectsCount / (float)_totalServicesObjectsCount) * 100 : 0; } }
    public float DuplicateServicesObjectsPercent { get { return _totalServicesObjectsCount > 0 ? ((float)_duplicateServicesObjectsCount / (float)_totalServicesObjectsCount) * 100 : 0; } }
    public float NestedServicesGroupsPercent { get { return _nestedServicesGroupsCountAll > 0 ? ((float)_nestedServicesGroupsCount / (float)_nestedServicesGroupsCountAll) * 100 : 0; } }

    public float TotalServicesRulesPercent { get { return 100; } }
    public float RulesServicesutilizingServicesAnyPercent { get { return _totalServicesRulesCount > 0 ? ((float)_unrulesServicesutilizingServicesAnyCount / (float)_totalServicesRulesCount) * 100 : 0; } }
    public float DisabledServicesRulesPercent { get { return _totalServicesRulesCount > 0 ? ((float)_undisabledServicesRulesCount / (float)_totalServicesRulesCount) * 100 : 0; } }
    public float UnnamedServicesRulesPercent { get { return _totalServicesRulesCount > 0 ? ((float)_unnamedServicesRulesCount / (float)_totalServicesRulesCount) * 100 : 0; } }
    public float TimesServicesRulesPercent { get { return _totalServicesRulesCount > 0 ? ((float)_untimesServicesRulesCount / (float)_totalServicesRulesCount) * 100 : 0; } }
    public float NonServicesLoggingServicesRulesPercent { get { return _totalServicesRulesCount > 0 ? ((float)_nonServicesLoggingServicesRulesCount / (float)_totalServicesRulesCount) * 100 : 0; } }
    public float StealthServicesRulePercent { get { return _totalServicesRulesCount > 0 ? ((float)_stealthServicesRuleCount / (float)_totalServicesRulesCount) * 100 : 0; } }
    public float CleanupServicesRulePercent { get { return _totalServicesRulesCount > 0 ? ((float)_cleanupServicesRuleCount / (float)_totalServicesRulesCount) * 100 : 0; } }
    public float UncommentedServicesRulesPercent { get { return _totalServicesRulesCount > 0 ? ((float)_uncommentedServicesRulesCount / (float)_totalServicesRulesCount) * 100 : 0; } }

    public NewAnalizStatistic(int fullpackcount, int totalpack)
    {
        _fullrullPackageCount = fullpackcount;
        _totalrullPackageCount = totalpack;
    }

    public void Flush()
    {
        _fullrullPackcount = 0;
        _totalServicesRulesCount = 0;
        _rulesServicesutilizingServicesAnyCount = 0;
        _rulesServicesutilizingServicesAnySourceCount = 0;
        _rulesServicesutilizingServicesAnyDestinationCount = 0;
        _rulesServicesutilizingServicesAnyServiceCount = 0;
        _disabledServicesRulesCount = 0;
        _unnamedServicesRulesCount = 0;
        _timesServicesRulesCount = 0;
        _nonServicesLoggingServicesRulesCount = 0;
        _stealthServicesRuleCount = 0;
        _cleanupServicesRuleCount = 0;
        _uncommentedServicesRulesCount = 0;
    }

    public void CalculateCorrectAll(List<CheckPoint_Network> _cpNetworks,
                                               List<CheckPoint_NetworkGroup> _cpNetworkGroups,
                                               List<CheckPoint_Host> _cpHosts,
                                               List<CheckPoint_Range> _cpRanges,
                                               List<CheckPoint_TcpService> _cpTcpServices,
                                               List<CheckPoint_UdpService> _cpUdpServices,
                                               List<CheckPoint_SctpService> _cpSctpServices,
                                               List<CheckPoint_IcmpService> _cpIcmpServices,
                                               List<CheckPoint_DceRpcService> _cpDceRpcServices,
                                               List<CheckPoint_OtherService> _cpOtherServices,
                                               List<CheckPoint_ServiceGroup> _cpServiceGroups)
    {
        _unusedNetworkObjectsCount = _unusedNetworkObjectsCount >= 0 ? _unusedNetworkObjectsCount : 0;
        _unusedServicesObjectsCount = _unusedServicesObjectsCount >= 0 ? _unusedServicesObjectsCount : 0;
        _undisabledServicesRulesCount = _disabledServicesRulesCount;
        _unrulesServicesutilizingServicesAnyCount = _rulesServicesutilizingServicesAnyCount;
        _unrulesServicesutilizingServicesAnySourceCount = _rulesServicesutilizingServicesAnySourceCount;
        _unrulesServicesutilizingServicesAnyDestinationCount = _rulesServicesutilizingServicesAnyDestinationCount;
        _unrulesServicesutilizingServicesAnyServiceCount = _rulesServicesutilizingServicesAnyServiceCount;
        _untimesServicesRulesCount = _timesServicesRulesCount;
        _totalNetworkObjectsCount = _cpNetworks.Count + _cpHosts.Count + _cpNetworkGroups.Count + _cpRanges.Count;

        //DUPLICATE CALCULATION
        foreach (var item in _cpNetworks)
        {
            if (_cpNetworks.Where(nt => nt.Netmask == item.Netmask & nt.Subnet == nt.Subnet).Count() > 1) { _duplicateNetworkObjectsCount++; }
        }
        foreach (var item in _cpHosts)
        {
            if (_cpHosts.Where(nt => nt.IpAddress == item.IpAddress).Count() > 1) { _duplicateNetworkObjectsCount++; }
        }
        foreach (var item in _cpRanges)
        {
            if (_cpRanges.Where(nt => nt.RangeFrom == item.RangeFrom & nt.RangeTo == nt.RangeTo).Count() > 1) { _duplicateNetworkObjectsCount++; }
        }
        //
        List<string> vs = new List<string>();
        foreach (var item in _cpNetworkGroups) { vs.AddRange(item.Members); }
        var count = _nestedNetworkGroupsCountAll = vs.Count;
        _nestedNetworkGroupsCount = count - vs.Distinct().Count();
        /////////////////////////////////
        _totalServicesObjectsCount = _cpTcpServices.Count + _cpUdpServices.Count + _cpSctpServices.Count + _cpIcmpServices.Count + _cpDceRpcServices.Count + _cpOtherServices.Count + _cpServiceGroups.Count;
        //
        List<string> allServiceNames = new List<string>();
        _duplicateServicesObjectsCount += _cpTcpServices.Count - _cpTcpServices.Select(n => n.Port).Distinct().Count();
        _duplicateServicesObjectsCount += _cpUdpServices.Count - _cpUdpServices.Select(n => n.Port).Distinct().Count();
        //
        vs = new List<string>();
        foreach (var item in _cpServiceGroups) { vs.AddRange(item.Members); }
        count = _nestedServicesGroupsCountAll = vs.Count;
        _nestedServicesGroupsCount = count - vs.Distinct().Count();
    }
}
